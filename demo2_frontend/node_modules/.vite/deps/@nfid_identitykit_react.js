"use client";
import {
  require_jsx_runtime
} from "./chunk-FSUDOGWJ.js";
import {
  D,
  Delegation,
  DelegationChain,
  DelegationIdentity,
  ECDSAKeyIdentity,
  Ed25519KeyIdentity,
  INVALID_REQUEST_ERROR,
  IdbStorage,
  NOT_SUPPORTED_ERROR,
  PartialDelegationIdentity,
  PartialIdentity,
  Signer,
  SignerAgent,
  _,
  fromBase64,
  getDelegationChain,
  getIdentity,
  isDelegationValid,
  isJsonRpcRequest,
  isJsonRpcResponse,
  removeDelegationChain,
  removeIdentity,
  setDelegationChain,
  setIdentity,
  toBase64,
  ze
} from "./chunk-A3G77H63.js";
import {
  polling_exports
} from "./chunk-KPLXDLSU.js";
import {
  AnonymousIdentity,
  HttpAgent,
  Principal,
  cbor_exports,
  esm_exports,
  fromHex,
  init_esm,
  requestIdOf,
  toHex
} from "./chunk-CGUMSA2O.js";
import {
  require_react_dom,
  require_scheduler
} from "./chunk-KHASWD55.js";
import {
  require_react
} from "./chunk-X2JUFD43.js";
import {
  __commonJS,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// ../../node_modules/@dfinity/identity/lib/cjs/identity/partial.js
var require_partial = __commonJS({
  "../../node_modules/@dfinity/identity/lib/cjs/identity/partial.js"(exports) {
    "use strict";
    var __classPrivateFieldSet13 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f22) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f22)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet13 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f22) {
      if (kind === "a" && !f22)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
    };
    var _PartialIdentity_inner;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PartialIdentity = void 0;
    var principal_1 = (init_esm(), __toCommonJS(esm_exports));
    var PartialIdentity3 = class {
      constructor(inner2) {
        _PartialIdentity_inner.set(this, void 0);
        __classPrivateFieldSet13(this, _PartialIdentity_inner, inner2, "f");
      }
      /**
       * The raw public key of this identity.
       */
      get rawKey() {
        return __classPrivateFieldGet13(this, _PartialIdentity_inner, "f").rawKey;
      }
      /**
       * The DER-encoded public key of this identity.
       */
      get derKey() {
        return __classPrivateFieldGet13(this, _PartialIdentity_inner, "f").derKey;
      }
      /**
       * The DER-encoded public key of this identity.
       */
      toDer() {
        return __classPrivateFieldGet13(this, _PartialIdentity_inner, "f").toDer();
      }
      /**
       * The inner {@link PublicKey} used by this identity.
       */
      getPublicKey() {
        return __classPrivateFieldGet13(this, _PartialIdentity_inner, "f");
      }
      /**
       * The {@link Principal} of this identity.
       */
      getPrincipal() {
        return principal_1.Principal.from(__classPrivateFieldGet13(this, _PartialIdentity_inner, "f").rawKey);
      }
      /**
       * Required for the Identity interface, but cannot implemented for just a public key.
       */
      transformRequest() {
        return Promise.reject("Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.");
      }
    };
    exports.PartialIdentity = PartialIdentity3;
    _PartialIdentity_inner = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/use-async-memo/index.js
var require_use_async_memo = __commonJS({
  "../../node_modules/use-async-memo/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAsyncMemo = void 0;
    var react_1 = require_react();
    function useAsyncMemo2(factory, deps, initial) {
      var _a4 = (0, react_1.useState)(initial), val = _a4[0], setVal = _a4[1];
      (0, react_1.useEffect)(function() {
        var cancel = false;
        var promise = factory();
        if (promise === void 0 || promise === null)
          return;
        promise.then(function(val2) {
          if (!cancel) {
            setVal(val2);
          }
        });
        return function() {
          cancel = true;
        };
      }, deps);
      return val;
    }
    exports.useAsyncMemo = useAsyncMemo2;
  }
});

// ../../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../../node_modules/picocolors/picocolors.browser.js"(exports, module) {
    var x10 = String;
    var create = function() {
      return { isColorSupported: false, reset: x10, bold: x10, dim: x10, italic: x10, underline: x10, inverse: x10, hidden: x10, strikethrough: x10, black: x10, red: x10, green: x10, yellow: x10, blue: x10, magenta: x10, cyan: x10, white: x10, gray: x10, bgBlack: x10, bgRed: x10, bgGreen: x10, bgYellow: x10, bgBlue: x10, bgMagenta: x10, bgCyan: x10, bgWhite: x10, blackBright: x10, redBright: x10, greenBright: x10, yellowBright: x10, blueBright: x10, magentaBright: x10, cyanBright: x10, whiteBright: x10, bgBlackBright: x10, bgRedBright: x10, bgGreenBright: x10, bgYellowBright: x10, bgBlueBright: x10, bgMagentaBright: x10, bgCyanBright: x10, bgWhiteBright: x10 };
    };
    module.exports = create();
    module.exports.createColors = create;
  }
});

// ../../node_modules/tailwindcss/lib/util/log.js
var require_log = __commonJS({
  "../../node_modules/tailwindcss/lib/util/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      dim: function() {
        return dim;
      },
      default: function() {
        return _default;
      }
    });
    var _picocolors = _interop_require_default(require_picocolors_browser());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var alreadyShown = /* @__PURE__ */ new Set();
    function log(type, messages, key) {
      if (typeof process !== "undefined" && process.env.JEST_WORKER_ID)
        return;
      if (key && alreadyShown.has(key))
        return;
      if (key)
        alreadyShown.add(key);
      console.warn("");
      messages.forEach((message) => console.warn(type, "-", message));
    }
    function dim(input) {
      return _picocolors.default.dim(input);
    }
    var _default = {
      info(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.cyan("info")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      },
      warn(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.yellow("warn")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      },
      risk(key, messages) {
        log(_picocolors.default.bold(_picocolors.default.magenta("risk")), ...Array.isArray(key) ? [
          key
        ] : [
          messages,
          key
        ]);
      }
    };
  }
});

// ../../node_modules/tailwindcss/lib/public/colors.js
var require_colors = __commonJS({
  "../../node_modules/tailwindcss/lib/public/colors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _log = _interop_require_default(require_log());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function warn2({ version, from, to }) {
      _log.default.warn(`${from}-color-renamed`, [
        `As of Tailwind CSS ${version}, \`${from}\` has been renamed to \`${to}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    var _default = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a",
        950: "#020617"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827",
        950: "#030712"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b",
        950: "#09090b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717",
        950: "#0a0a0a"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917",
        950: "#0c0a09"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d",
        950: "#450a0a"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12",
        950: "#431407"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f",
        950: "#451a03"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12",
        950: "#422006"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314",
        950: "#1a2e05"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d",
        950: "#052e16"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b",
        950: "#022c22"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a",
        950: "#042f2e"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63",
        950: "#083344"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e",
        950: "#082f49"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a",
        950: "#172554"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81",
        950: "#1e1b4b"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95",
        950: "#2e1065"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87",
        950: "#3b0764"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75",
        950: "#4a044e"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843",
        950: "#500724"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337",
        950: "#4c0519"
      },
      get lightBlue() {
        warn2({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        });
        return this.sky;
      },
      get warmGray() {
        warn2({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        });
        return this.stone;
      },
      get trueGray() {
        warn2({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        });
        return this.neutral;
      },
      get coolGray() {
        warn2({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        });
        return this.gray;
      },
      get blueGray() {
        warn2({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        });
        return this.slate;
      }
    };
  }
});

// ../../node_modules/tailwindcss/colors.js
var require_colors2 = __commonJS({
  "../../node_modules/tailwindcss/colors.js"(exports, module) {
    var colors2 = require_colors();
    module.exports = (colors2.__esModule ? colors2 : { default: colors2 }).default;
  }
});

// ../../node_modules/@nfid/identitykit/dist/libs/react/index.esm.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var import_react116 = __toESM(require_react());

// ../../node_modules/use-context-selector/dist/index.js
var import_react = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var CONTEXT_VALUE = Symbol();
var ORIGINAL_PROVIDER = Symbol();
var isSSR = typeof window === "undefined" || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);
var useIsomorphicLayoutEffect = isSSR ? import_react.useEffect : import_react.useLayoutEffect;
var runWithNormalPriority = import_scheduler.unstable_runWithPriority ? (fn) => {
  try {
    (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, fn);
  } catch (e8) {
    if (e8.message === "Not implemented.") {
      fn();
    } else {
      throw e8;
    }
  }
} : (fn) => fn();
var createProvider = (ProviderOrig) => {
  const ContextProvider = ({ value, children }) => {
    const valueRef = (0, import_react.useRef)(value);
    const versionRef = (0, import_react.useRef)(0);
    const [resolve, setResolve] = (0, import_react.useState)(null);
    if (resolve) {
      resolve(value);
      setResolve(null);
    }
    const contextValue = (0, import_react.useRef)();
    if (!contextValue.current) {
      const listeners = /* @__PURE__ */ new Set();
      const update = (fn, options) => {
        versionRef.current += 1;
        const action = {
          n: versionRef.current
        };
        if (options === null || options === void 0 ? void 0 : options.suspense) {
          action.n *= -1;
          action.p = new Promise((r18) => {
            setResolve(() => (v4) => {
              action.v = v4;
              delete action.p;
              r18(v4);
            });
          });
        }
        listeners.forEach((listener) => listener(action));
        fn();
      };
      contextValue.current = {
        [CONTEXT_VALUE]: {
          /* "v"alue     */
          v: valueRef,
          /* versio"n"   */
          n: versionRef,
          /* "l"isteners */
          l: listeners,
          /* "u"pdate    */
          u: update
        }
      };
    }
    useIsomorphicLayoutEffect(() => {
      valueRef.current = value;
      versionRef.current += 1;
      runWithNormalPriority(() => {
        contextValue.current[CONTEXT_VALUE].l.forEach((listener) => {
          listener({ n: versionRef.current, v: value });
        });
      });
    }, [value]);
    return (0, import_react.createElement)(ProviderOrig, { value: contextValue.current }, children);
  };
  return ContextProvider;
};
var identity = (x10) => x10;
function createContext(defaultValue) {
  const context = (0, import_react.createContext)({
    [CONTEXT_VALUE]: {
      /* "v"alue     */
      v: { current: defaultValue },
      /* versio"n"   */
      n: { current: -1 },
      /* "l"isteners */
      l: /* @__PURE__ */ new Set(),
      /* "u"pdate    */
      u: (f22) => f22()
    }
  });
  context[ORIGINAL_PROVIDER] = context.Provider;
  context.Provider = createProvider(context.Provider);
  delete context.Consumer;
  return context;
}
function useContextSelector(context, selector) {
  const contextValue = (0, import_react.useContext)(context)[CONTEXT_VALUE];
  if (typeof process === "object" && true) {
    if (!contextValue) {
      throw new Error("useContextSelector requires special context");
    }
  }
  const {
    /* "v"alue     */
    v: { current: value },
    /* versio"n"   */
    n: { current: version },
    /* "l"isteners */
    l: listeners
  } = contextValue;
  const selected = selector(value);
  const [state, dispatch] = (0, import_react.useReducer)((prev, action) => {
    if (!action) {
      return [value, selected];
    }
    if ("p" in action) {
      throw action.p;
    }
    if (action.n === version) {
      if (Object.is(prev[1], selected)) {
        return prev;
      }
      return [value, selected];
    }
    try {
      if ("v" in action) {
        if (Object.is(prev[0], action.v)) {
          return prev;
        }
        const nextSelected = selector(action.v);
        if (Object.is(prev[1], nextSelected)) {
          return prev;
        }
        return [action.v, nextSelected];
      }
    } catch (_e4) {
    }
    return [...prev];
  }, [value, selected]);
  if (!Object.is(state[1], selected)) {
    dispatch();
  }
  useIsomorphicLayoutEffect(() => {
    listeners.add(dispatch);
    return () => {
      listeners.delete(dispatch);
    };
  }, [listeners]);
  return state[1];
}
function useContext(context) {
  return useContextSelector(context, identity);
}

// ../../node_modules/@nfid/identitykit/dist/libs/react/index.esm.js
init_esm();

// ../../node_modules/@slide-computer/signer-web/lib/esm/icrc29/postMessageChannel.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _PostMessageChannel_closeListeners;
var _PostMessageChannel_options;
var _PostMessageChannel_closed;
var PostMessageChannel = class {
  constructor(options) {
    _PostMessageChannel_closeListeners.set(this, /* @__PURE__ */ new Set());
    _PostMessageChannel_options.set(this, void 0);
    _PostMessageChannel_closed.set(this, false);
    __classPrivateFieldSet(this, _PostMessageChannel_options, Object.assign({ window: globalThis.window, manageFocus: true }, options), "f");
  }
  get closed() {
    return __classPrivateFieldGet(this, _PostMessageChannel_closed, "f");
  }
  addEventListener(...[event, listener]) {
    switch (event) {
      case "close":
        __classPrivateFieldGet(this, _PostMessageChannel_closeListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet(this, _PostMessageChannel_closeListeners, "f").delete(listener);
        };
      case "response":
        const messageListener = async (event2) => {
          if (event2.source !== __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerWindow || event2.origin !== __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerOrigin || !isJsonRpcResponse(event2.data)) {
            return;
          }
          listener(event2.data);
        };
        __classPrivateFieldGet(this, _PostMessageChannel_options, "f").window.addEventListener("message", messageListener);
        return () => {
          __classPrivateFieldGet(this, _PostMessageChannel_options, "f").window.removeEventListener("message", messageListener);
        };
    }
  }
  async send(request) {
    if (__classPrivateFieldGet(this, _PostMessageChannel_closed, "f")) {
      throw new PostMessageTransportError("Communication channel is closed");
    }
    __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerWindow.postMessage(request, __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerOrigin);
    if (__classPrivateFieldGet(this, _PostMessageChannel_options, "f").manageFocus) {
      __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerWindow.focus();
    }
  }
  async close() {
    if (__classPrivateFieldGet(this, _PostMessageChannel_closed, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _PostMessageChannel_closed, true, "f");
    __classPrivateFieldGet(this, _PostMessageChannel_options, "f").signerWindow.close();
    if (__classPrivateFieldGet(this, _PostMessageChannel_options, "f").manageFocus) {
      __classPrivateFieldGet(this, _PostMessageChannel_options, "f").window.focus();
    }
    __classPrivateFieldGet(this, _PostMessageChannel_closeListeners, "f").forEach((listener) => listener());
  }
};
_PostMessageChannel_closeListeners = /* @__PURE__ */ new WeakMap(), _PostMessageChannel_options = /* @__PURE__ */ new WeakMap(), _PostMessageChannel_closed = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@slide-computer/signer-web/lib/esm/utils.js
var urlIsSecureContext = (value) => {
  try {
    const url = new URL(value);
    return url.protocol === "https:" || url.hostname === "127.0.0.1" || url.hostname.split(".").slice(-1)[0] === "localhost";
  } catch (_a4) {
    return false;
  }
};

// ../../node_modules/@slide-computer/signer-web/lib/esm/icrc29/heartbeat.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _HeartbeatClient_instances;
var _HeartbeatClient_options;
var _HeartbeatClient_establish;
var _HeartbeatClient_maintain;
var _HeartbeatClient_receiveReadyResponse;
var _HeartbeatClient_sendStatusRequest;
var _HeartbeatServer_instances;
var _HeartbeatServer_options;
var _HeartbeatServer_establish;
var _HeartbeatServer_maintain;
var _HeartbeatServer_receiveStatusRequest;
var _HeartbeatServer_sendReadyResponse;
var HeartbeatClient = class {
  constructor(options) {
    _HeartbeatClient_instances.add(this);
    _HeartbeatClient_options.set(this, void 0);
    __classPrivateFieldSet2(this, _HeartbeatClient_options, Object.assign({ establishTimeout: 1e4, disconnectTimeout: 2e3, statusPollingRate: 300, window: globalThis.window, crypto: globalThis.crypto }, options), "f");
    __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_establish).call(this);
  }
};
_HeartbeatClient_options = /* @__PURE__ */ new WeakMap(), _HeartbeatClient_instances = /* @__PURE__ */ new WeakSet(), _HeartbeatClient_establish = function _HeartbeatClient_establish2() {
  const pending = [];
  const create = () => {
    const id = __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").crypto.randomUUID();
    pending.push(id);
    return id;
  };
  const listener = __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_receiveReadyResponse).call(this, (response) => {
    if (pending.includes(response.data.id)) {
      listener();
      clearInterval(interval);
      clearTimeout(timeout);
      __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").onEstablish(response.origin);
      __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_maintain).call(this, response.origin);
    }
  });
  const timeout = setTimeout(() => {
    listener();
    clearInterval(interval);
    __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").onEstablishTimeout();
  }, __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").establishTimeout);
  const interval = setInterval(() => __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_sendStatusRequest).call(this, create()), __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").statusPollingRate);
}, _HeartbeatClient_maintain = function _HeartbeatClient_maintain2(origin) {
  let interval;
  let timeout;
  let pending = [];
  const consume = (id) => {
    const index3 = pending.findIndex((entry) => entry.id === id);
    if (index3 > -1) {
      pending.splice(index3, 1);
    }
    return index3 > -1;
  };
  const create = () => {
    const id = __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").crypto.randomUUID();
    const time = (/* @__PURE__ */ new Date()).getTime();
    pending = pending.filter((entry) => time - __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").disconnectTimeout > entry.time);
    pending.push({ id, time });
    return id;
  };
  const resetTimeout = () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      listener();
      clearInterval(interval);
      __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").onDisconnect();
    }, __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").disconnectTimeout);
  };
  const listener = __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_receiveReadyResponse).call(this, (response) => {
    if (response.origin === origin && consume(response.data.id)) {
      resetTimeout();
    }
  });
  resetTimeout();
  interval = setInterval(() => __classPrivateFieldGet2(this, _HeartbeatClient_instances, "m", _HeartbeatClient_sendStatusRequest).call(this, create()), __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").statusPollingRate);
}, _HeartbeatClient_receiveReadyResponse = function _HeartbeatClient_receiveReadyResponse2(handler) {
  const listener = (event) => {
    if (event.source === __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").signerWindow && isJsonRpcResponse(event.data) && "result" in event.data && event.data.result === "ready") {
      handler(event);
    }
  };
  __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").window.addEventListener("message", listener);
  return () => __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").window.removeEventListener("message", listener);
}, _HeartbeatClient_sendStatusRequest = function _HeartbeatClient_sendStatusRequest2(id) {
  __classPrivateFieldGet2(this, _HeartbeatClient_options, "f").signerWindow.postMessage({ jsonrpc: "2.0", id, method: "icrc29_status" }, "*");
};
_HeartbeatServer_options = /* @__PURE__ */ new WeakMap(), _HeartbeatServer_instances = /* @__PURE__ */ new WeakSet(), _HeartbeatServer_establish = function _HeartbeatServer_establish2() {
  const listener = __classPrivateFieldGet2(this, _HeartbeatServer_instances, "m", _HeartbeatServer_receiveStatusRequest).call(this, (request) => {
    if (!request.source) {
      return;
    }
    listener();
    clearTimeout(timeout);
    __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").onEstablish(request.origin);
    __classPrivateFieldGet2(this, _HeartbeatServer_instances, "m", _HeartbeatServer_maintain).call(this, request.origin, request.source);
  });
  const timeout = setTimeout(() => {
    listener();
    __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").onEstablishTimeout();
  }, __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").establishTimeout);
}, _HeartbeatServer_maintain = function _HeartbeatServer_maintain2(origin, source) {
  let interval;
  let timeout;
  let pending = [];
  const consume = (id) => {
    const index3 = pending.findIndex((entry) => entry.id === id);
    if (index3 > -1) {
      pending.splice(index3, 1);
    }
    return index3 > -1;
  };
  const create = () => {
    const id = __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").crypto.randomUUID();
    const time = (/* @__PURE__ */ new Date()).getTime();
    pending = pending.filter((entry) => time - __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").disconnectTimeout > entry.time);
    pending.push({ id, time });
    return id;
  };
  const resetTimeout = () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      listener();
      clearInterval(interval);
      __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").onDisconnect();
    }, __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").disconnectTimeout);
  };
  const listener = __classPrivateFieldGet2(this, _HeartbeatServer_instances, "m", _HeartbeatServer_receiveStatusRequest).call(this, (response) => {
    if (response.origin === origin && consume(response.data.id)) {
      resetTimeout();
    }
  });
  resetTimeout();
  interval = setInterval(() => __classPrivateFieldGet2(this, _HeartbeatServer_instances, "m", _HeartbeatServer_sendReadyResponse).call(this, create()), __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").statusPollingRate);
}, _HeartbeatServer_receiveStatusRequest = function _HeartbeatServer_receiveStatusRequest2(handler) {
  const listener = (event) => {
    if (isJsonRpcRequest(event.data) && event.data.method === "icrc29_status") {
      handler(event);
    }
  };
  __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").window.addEventListener("message", listener);
  return () => __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").window.removeEventListener("message", listener);
}, _HeartbeatServer_sendReadyResponse = function _HeartbeatServer_sendReadyResponse2(id) {
  __classPrivateFieldGet2(this, _HeartbeatServer_options, "f").signerWindow.postMessage({ jsonrpc: "2.0", id, method: "icrc29_status" }, "*");
};

// ../../node_modules/@slide-computer/signer-web/lib/esm/icrc29/postMessageTransport.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _PostMessageTransport_options;
var NON_CLICK_ESTABLISHMENT_LINK = "https://github.com/slide-computer/signer-js/blob/main/packages/signer-web/README.md#channels-must-be-established-in-a-click-handler";
var PostMessageTransportError = class _PostMessageTransportError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _PostMessageTransportError.prototype);
  }
};
var withinClick = false;
if (globalThis.window) {
  globalThis.window.addEventListener("click", () => withinClick = true, true);
  globalThis.window.addEventListener("click", () => withinClick = false);
}
var PostMessageTransport = class {
  constructor(options) {
    _PostMessageTransport_options.set(this, void 0);
    if (!urlIsSecureContext(options.url)) {
      throw new PostMessageTransportError("Invalid signer RPC url");
    }
    __classPrivateFieldSet3(this, _PostMessageTransport_options, Object.assign({ windowOpenerFeatures: "", window: globalThis.window, establishTimeout: 12e4, disconnectTimeout: 2e3, statusPollingRate: 300, crypto: globalThis.crypto, manageFocus: true, closeOnEstablishTimeout: true, detectNonClickEstablishment: true }, options), "f");
  }
  async establishChannel() {
    if (__classPrivateFieldGet3(this, _PostMessageTransport_options, "f").detectNonClickEstablishment && !withinClick) {
      throw new PostMessageTransportError(`Signer window should not be opened outside of click handler, see: ${NON_CLICK_ESTABLISHMENT_LINK}`);
    }
    const signerWindow = __classPrivateFieldGet3(this, _PostMessageTransport_options, "f").window.open(__classPrivateFieldGet3(this, _PostMessageTransport_options, "f").url, "signerWindow", __classPrivateFieldGet3(this, _PostMessageTransport_options, "f").windowOpenerFeatures);
    if (!signerWindow) {
      throw new PostMessageTransportError("Signer window could not be opened");
    }
    return new Promise((resolve, reject) => {
      let channel;
      new HeartbeatClient(Object.assign(Object.assign({}, __classPrivateFieldGet3(this, _PostMessageTransport_options, "f")), { signerWindow, onEstablish: (origin) => {
        channel = new PostMessageChannel(Object.assign(Object.assign({}, __classPrivateFieldGet3(this, _PostMessageTransport_options, "f")), { signerOrigin: origin, signerWindow }));
        resolve(channel);
      }, onEstablishTimeout: () => {
        if (__classPrivateFieldGet3(this, _PostMessageTransport_options, "f").closeOnEstablishTimeout) {
          signerWindow.close();
        }
        reject(new PostMessageTransportError("Communication channel could not be established within a reasonable time"));
      }, onDisconnect: () => channel.close() }));
    });
  }
};
_PostMessageTransport_options = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@slide-computer/signer-extension/lib/esm/icrc94/browserExtensionChannel.js
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _BrowserExtensionChannel_closeListeners;
var _BrowserExtensionChannel_responseListeners;
var _BrowserExtensionChannel_options;
var _BrowserExtensionChannel_closed;
var BrowserExtensionChannel = class {
  constructor(options) {
    _BrowserExtensionChannel_closeListeners.set(this, /* @__PURE__ */ new Set());
    _BrowserExtensionChannel_responseListeners.set(this, /* @__PURE__ */ new Set());
    _BrowserExtensionChannel_options.set(this, void 0);
    _BrowserExtensionChannel_closed.set(this, false);
    __classPrivateFieldSet4(this, _BrowserExtensionChannel_options, Object.assign({ window: globalThis.window }, options), "f");
    const closeListener = () => {
      __classPrivateFieldGet4(this, _BrowserExtensionChannel_options, "f").window.removeEventListener("icrc94:unexpectedlyClosed", closeListener);
      __classPrivateFieldSet4(this, _BrowserExtensionChannel_closed, true, "f");
      __classPrivateFieldGet4(this, _BrowserExtensionChannel_closeListeners, "f").forEach((listener) => listener());
    };
    __classPrivateFieldGet4(this, _BrowserExtensionChannel_options, "f").window.addEventListener("icrc94:unexpectedlyClosed", closeListener);
  }
  get closed() {
    return __classPrivateFieldGet4(this, _BrowserExtensionChannel_closed, "f");
  }
  addEventListener(...[event, listener]) {
    switch (event) {
      case "close":
        __classPrivateFieldGet4(this, _BrowserExtensionChannel_closeListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet4(this, _BrowserExtensionChannel_closeListeners, "f").delete(listener);
        };
      case "response":
        __classPrivateFieldGet4(this, _BrowserExtensionChannel_responseListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet4(this, _BrowserExtensionChannel_responseListeners, "f").delete(listener);
        };
    }
  }
  async send(request) {
    if (__classPrivateFieldGet4(this, _BrowserExtensionChannel_closed, "f")) {
      throw new BrowserExtensionTransportError("Communication channel is closed");
    }
    const response = await __classPrivateFieldGet4(this, _BrowserExtensionChannel_options, "f").providerDetail.sendMessage(request);
    if (!isJsonRpcResponse(response)) {
      return;
    }
    __classPrivateFieldGet4(this, _BrowserExtensionChannel_responseListeners, "f").forEach((listener) => listener(response));
  }
  async close() {
    if (__classPrivateFieldGet4(this, _BrowserExtensionChannel_closed, "f")) {
      return;
    }
    __classPrivateFieldSet4(this, _BrowserExtensionChannel_closed, true, "f");
    await __classPrivateFieldGet4(this, _BrowserExtensionChannel_options, "f").providerDetail.dismiss();
    __classPrivateFieldGet4(this, _BrowserExtensionChannel_closeListeners, "f").forEach((listener) => listener());
  }
};
_BrowserExtensionChannel_closeListeners = /* @__PURE__ */ new WeakMap(), _BrowserExtensionChannel_responseListeners = /* @__PURE__ */ new WeakMap(), _BrowserExtensionChannel_options = /* @__PURE__ */ new WeakMap(), _BrowserExtensionChannel_closed = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@slide-computer/signer-extension/lib/esm/icrc94/browserExtensionTransport.js
var __classPrivateFieldSet5 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet5 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _BrowserExtensionTransport_options;
var BrowserExtensionTransportError = class _BrowserExtensionTransportError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _BrowserExtensionTransportError.prototype);
  }
};
var BrowserExtensionTransport = class _BrowserExtensionTransport {
  constructor(options) {
    _BrowserExtensionTransport_options.set(this, void 0);
    __classPrivateFieldSet5(this, _BrowserExtensionTransport_options, Object.assign({ window: globalThis.window }, options), "f");
  }
  static async discover({ discoveryDuration = 100, window: window2 = globalThis.window } = {}) {
    const providerDetails = [];
    window2.addEventListener("icrc94:announceProvider", (event) => {
      if (providerDetails.find((providerDetail) => providerDetail.uuid === event.detail.uuid)) {
        return;
      }
      providerDetails.push(event.detail);
    });
    window2.dispatchEvent(new CustomEvent("icrc94:requestProvider"));
    await new Promise((resolve) => setTimeout(resolve, discoveryDuration));
    return providerDetails;
  }
  static async findTransport(options) {
    const providerDetails = await _BrowserExtensionTransport.discover(options);
    const providerDetail = providerDetails.find(({ uuid }) => uuid === options.uuid);
    if (!providerDetail) {
      throw new BrowserExtensionTransportError("Browser extension couldn't be found, make sure it's installed and enabled for this page.");
    }
    return new _BrowserExtensionTransport(Object.assign(Object.assign({}, options), { providerDetail }));
  }
  async establishChannel() {
    return new BrowserExtensionChannel(__classPrivateFieldGet5(this, _BrowserExtensionTransport_options, "f"));
  }
};
_BrowserExtensionTransport_options = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@dfinity/auth-client/lib/esm/idleManager.js
var events = ["mousedown", "mousemove", "keydown", "touchstart", "wheel"];
var IdleManager = class {
  /**
   * @protected
   * @param options {@link IdleManagerOptions}
   */
  constructor(options = {}) {
    var _a4;
    this.callbacks = [];
    this.idleTimeout = 10 * 60 * 1e3;
    this.timeoutID = void 0;
    const { onIdle, idleTimeout = 10 * 60 * 1e3 } = options || {};
    this.callbacks = onIdle ? [onIdle] : [];
    this.idleTimeout = idleTimeout;
    const _resetTimer = this._resetTimer.bind(this);
    window.addEventListener("load", _resetTimer, true);
    events.forEach(function(name) {
      document.addEventListener(name, _resetTimer, true);
    });
    const debounce2 = (func, wait) => {
      let timeout;
      return (...args) => {
        const context = this;
        const later = function() {
          timeout = void 0;
          func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = window.setTimeout(later, wait);
      };
    };
    if (options === null || options === void 0 ? void 0 : options.captureScroll) {
      const scroll = debounce2(_resetTimer, (_a4 = options === null || options === void 0 ? void 0 : options.scrollDebounce) !== null && _a4 !== void 0 ? _a4 : 100);
      window.addEventListener("scroll", scroll, true);
    }
    _resetTimer();
  }
  /**
   * Creates an {@link IdleManager}
   * @param {IdleManagerOptions} options Optional configuration
   * @see {@link IdleManagerOptions}
   * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user
   * @param options.idleTimeout timeout in ms
   * @param options.captureScroll capture scroll events
   * @param options.scrollDebounce scroll debounce time in ms
   */
  static create(options = {}) {
    return new this(options);
  }
  /**
   * @param {IdleCB} callback function to be called when user goes idle
   */
  registerCallback(callback) {
    this.callbacks.push(callback);
  }
  /**
   * Cleans up the idle manager and its listeners
   */
  exit() {
    clearTimeout(this.timeoutID);
    window.removeEventListener("load", this._resetTimer, true);
    const _resetTimer = this._resetTimer.bind(this);
    events.forEach(function(name) {
      document.removeEventListener(name, _resetTimer, true);
    });
    this.callbacks.forEach((cb) => cb());
  }
  /**
   * Resets the timeouts during cleanup
   */
  _resetTimer() {
    const exit = this.exit.bind(this);
    window.clearTimeout(this.timeoutID);
    this.timeoutID = window.setTimeout(exit, this.idleTimeout);
  }
};

// ../../node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object, constructors) => constructors.some((c15) => object instanceof c15);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error2);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error2 = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error2);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error2);
      tx.removeEventListener("abort", error2);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error2 = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error2);
    tx.addEventListener("abort", error2);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// ../../node_modules/idb/build/index.js
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// ../../node_modules/@dfinity/auth-client/lib/esm/db.js
var AUTH_DB_NAME = "auth-client-db";
var OBJECT_STORE_NAME = "ic-keyval";
var _openDbStore = async (dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version) => {
  if (isBrowser && (localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem(KEY_STORAGE_DELEGATION))) {
    localStorage.removeItem(KEY_STORAGE_DELEGATION);
    localStorage.removeItem(KEY_STORAGE_KEY);
  }
  return await openDB(dbName, version, {
    upgrade: (database) => {
      if (database.objectStoreNames.contains(storeName)) {
        database.clear(storeName);
      }
      database.createObjectStore(storeName);
    }
  });
};
async function _getValue(db, storeName, key) {
  return await db.get(storeName, key);
}
async function _setValue(db, storeName, key, value) {
  return await db.put(storeName, value, key);
}
async function _removeValue(db, storeName, key) {
  return await db.delete(storeName, key);
}
var IdbKeyVal = class _IdbKeyVal {
  // Do not use - instead prefer create
  constructor(_db, _storeName) {
    this._db = _db;
    this._storeName = _storeName;
  }
  /**
   * @param {DBCreateOptions} options - DBCreateOptions
   * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database
   * @default
   * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store
   * @default
   * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade
   * @constructs an {@link IdbKeyVal}
   */
  static async create(options) {
    const { dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version = DB_VERSION } = options !== null && options !== void 0 ? options : {};
    const db = await _openDbStore(dbName, storeName, version);
    return new _IdbKeyVal(db, storeName);
  }
  /**
   * Basic setter
   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
   * @param value value to set
   * @returns void
   */
  async set(key, value) {
    return await _setValue(this._db, this._storeName, key, value);
  }
  /**
   * Basic getter
   * Pass in a type T for type safety if you know the type the value will have if it is found
   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
   * @returns `Promise<T | null>`
   * @example
   * await get<string>('exampleKey') -> 'exampleValue'
   */
  async get(key) {
    var _a4;
    return (_a4 = await _getValue(this._db, this._storeName, key)) !== null && _a4 !== void 0 ? _a4 : null;
  }
  /**
   * Remove a key
   * @param key {@link IDBValidKey}
   * @returns void
   */
  async remove(key) {
    return await _removeValue(this._db, this._storeName, key);
  }
};

// ../../node_modules/@dfinity/auth-client/lib/esm/storage.js
var __classPrivateFieldSet6 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _IdbStorage_options;
var KEY_STORAGE_KEY = "identity";
var KEY_STORAGE_DELEGATION = "delegation";
var KEY_VECTOR = "iv";
var DB_VERSION = 1;
var isBrowser = typeof window !== "undefined";
var LocalStorage = class {
  constructor(prefix = "ic-", _localStorage) {
    this.prefix = prefix;
    this._localStorage = _localStorage;
  }
  get(key) {
    return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));
  }
  set(key, value) {
    this._getLocalStorage().setItem(this.prefix + key, value);
    return Promise.resolve();
  }
  remove(key) {
    this._getLocalStorage().removeItem(this.prefix + key);
    return Promise.resolve();
  }
  _getLocalStorage() {
    if (this._localStorage) {
      return this._localStorage;
    }
    const ls = typeof window === "undefined" ? typeof globalThis === "undefined" ? typeof self === "undefined" ? void 0 : self.localStorage : globalThis.localStorage : window.localStorage;
    if (!ls) {
      throw new Error("Could not find local storage.");
    }
    return ls;
  }
};
var IdbStorage2 = class {
  /**
   * @param options - DBCreateOptions
   * @param options.dbName - name for the indexeddb database
   * @param options.storeName - name for the indexeddb Data Store
   * @param options.version - version of the database. Increment to safely upgrade
   * @constructs an {@link IdbStorage}
   * @example
   * ```typescript
   * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });
   * ```
   */
  constructor(options) {
    _IdbStorage_options.set(this, void 0);
    __classPrivateFieldSet6(this, _IdbStorage_options, options !== null && options !== void 0 ? options : {}, "f");
  }
  get _db() {
    return new Promise((resolve) => {
      if (this.initializedDb) {
        resolve(this.initializedDb);
        return;
      }
      IdbKeyVal.create(__classPrivateFieldGet6(this, _IdbStorage_options, "f")).then((db) => {
        this.initializedDb = db;
        resolve(db);
      });
    });
  }
  async get(key) {
    const db = await this._db;
    return await db.get(key);
  }
  async set(key, value) {
    const db = await this._db;
    await db.set(key, value);
  }
  async remove(key) {
    const db = await this._db;
    await db.remove(key);
  }
};
_IdbStorage_options = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@dfinity/auth-client/lib/esm/index.js
var IDENTITY_PROVIDER_DEFAULT = "https://identity.ic0.app";
var IDENTITY_PROVIDER_ENDPOINT = "#authorize";
var ECDSA_KEY_LABEL = "ECDSA";
var ED25519_KEY_LABEL = "Ed25519";
var INTERRUPT_CHECK_INTERVAL = 500;
var ERROR_USER_INTERRUPT = "UserInterrupt";
var AuthClient = class {
  constructor(_identity, _key, _chain, _storage, idleManager, _createOptions, _idpWindow, _eventHandler) {
    this._identity = _identity;
    this._key = _key;
    this._chain = _chain;
    this._storage = _storage;
    this.idleManager = idleManager;
    this._createOptions = _createOptions;
    this._idpWindow = _idpWindow;
    this._eventHandler = _eventHandler;
    this._registerDefaultIdleCallback();
  }
  /**
   * Create an AuthClient to manage authentication and identity
   * @constructs
   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}
   * @see {@link AuthClientCreateOptions}
   * @param options.identity Optional Identity to use as the base
   * @see {@link SignIdentity}
   * @param options.storage Storage mechanism for delegration credentials
   * @see {@link AuthClientStorage}
   * @param options.keyType Type of key to use for the base key
   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}
   * @see {@link IdleOptions}
   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.
   * @example
   * const authClient = await AuthClient.create({
   *   idleOptions: {
   *     disableIdle: true
   *   }
   * })
   */
  static async create(options = {}) {
    var _a4, _b, _c;
    const storage = (_a4 = options.storage) !== null && _a4 !== void 0 ? _a4 : new IdbStorage2();
    const keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;
    let key = null;
    if (options.identity) {
      key = options.identity;
    } else {
      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);
      if (!maybeIdentityStorage && isBrowser) {
        try {
          const fallbackLocalStorage = new LocalStorage();
          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);
          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);
          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {
            console.log("Discovered an identity stored in localstorage. Migrating to IndexedDB");
            await storage.set(KEY_STORAGE_DELEGATION, localChain);
            await storage.set(KEY_STORAGE_KEY, localKey);
            maybeIdentityStorage = localChain;
            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);
            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);
          }
        } catch (error2) {
          console.error("error while attempting to recover localstorage: " + error2);
        }
      }
      if (maybeIdentityStorage) {
        try {
          if (typeof maybeIdentityStorage === "object") {
            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === "string") {
              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
            } else {
              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);
            }
          } else if (typeof maybeIdentityStorage === "string") {
            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
          }
        } catch (_d) {
        }
      }
    }
    let identity2 = new AnonymousIdentity();
    let chain = null;
    if (key) {
      try {
        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);
        if (typeof chainStorage === "object" && chainStorage !== null) {
          throw new Error("Delegation chain is incorrectly stored. A delegation chain should be stored as a string.");
        }
        if (options.identity) {
          identity2 = options.identity;
        } else if (chainStorage) {
          chain = DelegationChain.fromJSON(chainStorage);
          if (!isDelegationValid(chain)) {
            await _deleteStorage(storage);
            key = null;
          } else {
            if ("toDer" in key) {
              identity2 = PartialDelegationIdentity.fromDelegation(key, chain);
            } else {
              identity2 = DelegationIdentity.fromDelegation(key, chain);
            }
          }
        }
      } catch (e8) {
        console.error(e8);
        await _deleteStorage(storage);
        key = null;
      }
    }
    let idleManager = void 0;
    if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {
      idleManager = void 0;
    } else if (chain || options.identity) {
      idleManager = IdleManager.create(options.idleOptions);
    }
    if (!key) {
      if (keyType === ED25519_KEY_LABEL) {
        key = await Ed25519KeyIdentity.generate();
        await storage.set(KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));
      } else {
        if (options.storage && keyType === ECDSA_KEY_LABEL) {
          console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);
        }
        key = await ECDSAKeyIdentity.generate();
        await storage.set(KEY_STORAGE_KEY, key.getKeyPair());
      }
    }
    return new this(identity2, key, chain, storage, idleManager, options);
  }
  _registerDefaultIdleCallback() {
    var _a4, _b;
    const idleOptions = (_a4 = this._createOptions) === null || _a4 === void 0 ? void 0 : _a4.idleOptions;
    if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {
      (_b = this.idleManager) === null || _b === void 0 ? void 0 : _b.registerCallback(() => {
        this.logout();
        location.reload();
      });
    }
  }
  async _handleSuccess(message, onSuccess) {
    var _a4, _b;
    const delegations = message.delegations.map((signedDelegation) => {
      return {
        delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
        signature: signedDelegation.signature.buffer
      };
    });
    const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
    const key = this._key;
    if (!key) {
      return;
    }
    this._chain = delegationChain;
    if ("toDer" in key) {
      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);
    } else {
      this._identity = DelegationIdentity.fromDelegation(key, this._chain);
    }
    (_a4 = this._idpWindow) === null || _a4 === void 0 ? void 0 : _a4.close();
    const idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;
    if (!this.idleManager && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableIdle)) {
      this.idleManager = IdleManager.create(idleOptions);
      this._registerDefaultIdleCallback();
    }
    this._removeEventListener();
    delete this._idpWindow;
    if (this._chain) {
      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));
    }
    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(message);
  }
  getIdentity() {
    return this._identity;
  }
  async isAuthenticated() {
    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;
  }
  /**
   * AuthClient Login -
   * Opens up a new window to authenticate with Internet Identity
   * @param {AuthClientLoginOptions} options - Options for logging in
   * @param options.identityProvider Identity provider
   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds
   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).
   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity
   * @param options.windowOpenerFeatures Configures the opened authentication window
   * @param options.onSuccess Callback once login has completed
   * @param options.onError Callback in case authentication fails
   * @example
   * const authClient = await AuthClient.create();
   * authClient.login({
   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',
   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week
   *  windowOpenerFeatures: "toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100",
   *  onSuccess: () => {
   *    console.log('Login Successful!');
   *  },
   *  onError: (error) => {
   *    console.error('Login Failed: ', error);
   *  }
   * });
   */
  async login(options) {
    var _a4, _b, _c, _d;
    const defaultTimeToLive = (
      /* hours */
      BigInt(8) * /* nanoseconds */
      BigInt(36e11)
    );
    const identityProviderUrl = new URL(((_a4 = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a4 === void 0 ? void 0 : _a4.toString()) || IDENTITY_PROVIDER_DEFAULT);
    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;
    (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();
    this._removeEventListener();
    this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({ maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive }, options));
    window.addEventListener("message", this._eventHandler);
    this._idpWindow = (_d = window.open(identityProviderUrl.toString(), "idpWindow", options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : void 0;
    const checkInterruption = () => {
      if (this._idpWindow) {
        if (this._idpWindow.closed) {
          this._handleFailure(ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);
        } else {
          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);
        }
      }
    };
    checkInterruption();
  }
  _getEventHandler(identityProviderUrl, options) {
    return async (event) => {
      var _a4, _b, _c;
      if (event.origin !== identityProviderUrl.origin) {
        return;
      }
      const message = event.data;
      switch (message.kind) {
        case "authorize-ready": {
          const request = Object.assign({ kind: "authorize-client", sessionPublicKey: new Uint8Array((_a4 = this._key) === null || _a4 === void 0 ? void 0 : _a4.getPublicKey().toDer()), maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive, allowPinAuthentication: options === null || options === void 0 ? void 0 : options.allowPinAuthentication, derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString() }, options === null || options === void 0 ? void 0 : options.customValues);
          (_c = this._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);
          break;
        }
        case "authorize-client-success":
          try {
            await this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);
          } catch (err) {
            this._handleFailure(err.message, options === null || options === void 0 ? void 0 : options.onError);
          }
          break;
        case "authorize-client-failure":
          this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);
          break;
        default:
          break;
      }
    };
  }
  _handleFailure(errorMessage, onError) {
    var _a4;
    (_a4 = this._idpWindow) === null || _a4 === void 0 ? void 0 : _a4.close();
    onError === null || onError === void 0 ? void 0 : onError(errorMessage);
    this._removeEventListener();
    delete this._idpWindow;
  }
  _removeEventListener() {
    if (this._eventHandler) {
      window.removeEventListener("message", this._eventHandler);
    }
    this._eventHandler = void 0;
  }
  async logout(options = {}) {
    await _deleteStorage(this._storage);
    this._identity = new AnonymousIdentity();
    this._chain = null;
    if (options.returnTo) {
      try {
        window.history.pushState({}, "", options.returnTo);
      } catch (_a4) {
        window.location.href = options.returnTo;
      }
    }
  }
};
async function _deleteStorage(storage) {
  await storage.remove(KEY_STORAGE_KEY);
  await storage.remove(KEY_STORAGE_DELEGATION);
  await storage.remove(KEY_VECTOR);
}

// ../../node_modules/@slide-computer/signer-transport-auth-client/lib/esm/authClientConnection.js
var __classPrivateFieldSet7 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _AuthClientConnection_instances;
var _AuthClientConnection_options;
var _AuthClientConnection_disconnectListeners;
var _AuthClientConnection_disconnectMonitorInterval;
var _AuthClientConnection_monitorDisconnect;
var AuthClientConnection = class {
  constructor(options) {
    _AuthClientConnection_instances.add(this);
    _AuthClientConnection_options.set(this, void 0);
    _AuthClientConnection_disconnectListeners.set(this, /* @__PURE__ */ new Set());
    _AuthClientConnection_disconnectMonitorInterval.set(this, void 0);
    __classPrivateFieldSet7(this, _AuthClientConnection_options, Object.assign({ authClientLoginOptions: {}, authClientDisconnectMonitoringInterval: 3e3 }, options), "f");
    if (this.connected) {
      __classPrivateFieldGet7(this, _AuthClientConnection_instances, "m", _AuthClientConnection_monitorDisconnect).call(this);
    }
  }
  get connected() {
    const identity2 = __classPrivateFieldGet7(this, _AuthClientConnection_options, "f").authClient.getIdentity();
    if (identity2.getPrincipal().isAnonymous()) {
      return false;
    }
    const delegationIdentity = identity2;
    return isDelegationValid(delegationIdentity.getDelegation());
  }
  async connect() {
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet7(this, _AuthClientConnection_options, "f").authClient.login(Object.assign(Object.assign({}, __classPrivateFieldGet7(this, _AuthClientConnection_options, "f").authClientLoginOptions), { onSuccess: () => {
        __classPrivateFieldGet7(this, _AuthClientConnection_instances, "m", _AuthClientConnection_monitorDisconnect).call(this);
        resolve();
      }, onError: (error2) => reject(new AuthClientTransportError(error2 !== null && error2 !== void 0 ? error2 : "AuthClient login failed")) }));
    });
  }
  async disconnect() {
    clearInterval(__classPrivateFieldGet7(this, _AuthClientConnection_disconnectMonitorInterval, "f"));
    await __classPrivateFieldGet7(this, _AuthClientConnection_options, "f").authClient.logout();
    __classPrivateFieldGet7(this, _AuthClientConnection_disconnectListeners, "f").forEach((listener) => listener());
  }
  addEventListener(event, listener) {
    switch (event) {
      case "disconnect":
        __classPrivateFieldGet7(this, _AuthClientConnection_disconnectListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet7(this, _AuthClientConnection_disconnectListeners, "f").delete(listener);
        };
    }
  }
};
_AuthClientConnection_options = /* @__PURE__ */ new WeakMap(), _AuthClientConnection_disconnectListeners = /* @__PURE__ */ new WeakMap(), _AuthClientConnection_disconnectMonitorInterval = /* @__PURE__ */ new WeakMap(), _AuthClientConnection_instances = /* @__PURE__ */ new WeakSet(), _AuthClientConnection_monitorDisconnect = function _AuthClientConnection_monitorDisconnect2() {
  __classPrivateFieldSet7(this, _AuthClientConnection_disconnectMonitorInterval, setInterval(() => {
    if (!this.connected) {
      __classPrivateFieldGet7(this, _AuthClientConnection_disconnectListeners, "f").forEach((listener) => listener());
      clearInterval(__classPrivateFieldGet7(this, _AuthClientConnection_disconnectMonitorInterval, "f"));
    }
  }, __classPrivateFieldGet7(this, _AuthClientConnection_options, "f").authClientDisconnectMonitoringInterval), "f");
};

// ../../node_modules/@slide-computer/signer-transport-auth-client/lib/esm/authClientTransport.js
var __classPrivateFieldGet8 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var __classPrivateFieldSet8 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var _a;
var _AuthClientTransport_isInternalConstructing;
var _AuthClientTransport_connection;
var _AuthClientTransport_authClient;
var AuthClientTransportError = class _AuthClientTransportError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _AuthClientTransportError.prototype);
  }
};
var AuthClientTransport = class {
  constructor(authClient, connection) {
    _AuthClientTransport_connection.set(this, void 0);
    _AuthClientTransport_authClient.set(this, void 0);
    const throwError = !__classPrivateFieldGet8(_a, _a, "f", _AuthClientTransport_isInternalConstructing);
    __classPrivateFieldSet8(_a, _a, false, "f", _AuthClientTransport_isInternalConstructing);
    if (throwError) {
      throw new AuthClientTransportError("AuthClientTransport is not constructable");
    }
    __classPrivateFieldSet8(this, _AuthClientTransport_authClient, authClient, "f");
    __classPrivateFieldSet8(this, _AuthClientTransport_connection, connection, "f");
  }
  get connection() {
    return __classPrivateFieldGet8(this, _AuthClientTransport_connection, "f");
  }
  static async create(options) {
    const authClient = await AuthClient.create(options.authClientCreateOptions);
    const connection = new AuthClientConnection({
      authClient,
      authClientLoginOptions: options.authClientLoginOptions,
      authClientDisconnectMonitoringInterval: options.authClientDisconnectMonitoringInterval
    });
    __classPrivateFieldSet8(_a, _a, true, "f", _AuthClientTransport_isInternalConstructing);
    return new _a(authClient, connection);
  }
  async establishChannel() {
    if (!__classPrivateFieldGet8(this, _AuthClientTransport_connection, "f").connected) {
      throw new AuthClientTransportError("AuthClientTransport is not connected");
    }
    return new AuthClientChannel({
      authClient: __classPrivateFieldGet8(this, _AuthClientTransport_authClient, "f"),
      connection: __classPrivateFieldGet8(this, _AuthClientTransport_connection, "f")
    });
  }
};
_a = AuthClientTransport, _AuthClientTransport_connection = /* @__PURE__ */ new WeakMap(), _AuthClientTransport_authClient = /* @__PURE__ */ new WeakMap();
_AuthClientTransport_isInternalConstructing = { value: false };

// ../../node_modules/@slide-computer/signer-transport-auth-client/lib/esm/constants.js
var supportedStandards = [
  {
    name: "ICRC-25",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-25/ICRC-25.md"
  },
  {
    name: "ICRC-34",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-34/ICRC-34.md"
  }
];
var scopes = [
  {
    scope: {
      method: "icrc34_delegation"
    },
    state: "granted"
  }
];

// ../../node_modules/@slide-computer/signer-transport-auth-client/lib/esm/authClientChannel.js
var __classPrivateFieldSet9 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet9 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _AuthClientChannel_instances;
var _AuthClientChannel_options;
var _AuthClientChannel_closed;
var _AuthClientChannel_closeListeners;
var _AuthClientChannel_responseListeners;
var _AuthClientChannel_createResponse;
var AuthClientChannel = class {
  constructor(options) {
    _AuthClientChannel_instances.add(this);
    _AuthClientChannel_options.set(this, void 0);
    _AuthClientChannel_closed.set(this, false);
    _AuthClientChannel_closeListeners.set(this, /* @__PURE__ */ new Set());
    _AuthClientChannel_responseListeners.set(this, /* @__PURE__ */ new Set());
    __classPrivateFieldSet9(this, _AuthClientChannel_options, options, "f");
    __classPrivateFieldGet9(this, _AuthClientChannel_options, "f").connection.addEventListener("disconnect", () => __classPrivateFieldSet9(this, _AuthClientChannel_closed, true, "f"));
  }
  get closed() {
    return __classPrivateFieldGet9(this, _AuthClientChannel_closed, "f") || !__classPrivateFieldGet9(this, _AuthClientChannel_options, "f").connection.connected;
  }
  addEventListener(...[event, listener]) {
    switch (event) {
      case "close":
        __classPrivateFieldGet9(this, _AuthClientChannel_closeListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet9(this, _AuthClientChannel_closeListeners, "f").delete(listener);
        };
      case "response":
        __classPrivateFieldGet9(this, _AuthClientChannel_responseListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet9(this, _AuthClientChannel_responseListeners, "f").delete(listener);
        };
    }
  }
  async send(request) {
    if (this.closed) {
      throw new AuthClientTransportError("Communication channel is closed");
    }
    const id = request.id;
    if (id === void 0) {
      return;
    }
    const response = await __classPrivateFieldGet9(this, _AuthClientChannel_instances, "m", _AuthClientChannel_createResponse).call(this, Object.assign({ id }, request));
    __classPrivateFieldGet9(this, _AuthClientChannel_responseListeners, "f").forEach((listener) => listener(response));
  }
  async close() {
    __classPrivateFieldSet9(this, _AuthClientChannel_closed, true, "f");
    __classPrivateFieldGet9(this, _AuthClientChannel_closeListeners, "f").forEach((listener) => listener());
  }
};
_AuthClientChannel_options = /* @__PURE__ */ new WeakMap(), _AuthClientChannel_closed = /* @__PURE__ */ new WeakMap(), _AuthClientChannel_closeListeners = /* @__PURE__ */ new WeakMap(), _AuthClientChannel_responseListeners = /* @__PURE__ */ new WeakMap(), _AuthClientChannel_instances = /* @__PURE__ */ new WeakSet(), _AuthClientChannel_createResponse = async function _AuthClientChannel_createResponse2(request) {
  const id = request.id;
  if (!isJsonRpcRequest(request)) {
    return {
      id,
      jsonrpc: "2.0",
      error: { code: INVALID_REQUEST_ERROR, message: "Invalid request" }
    };
  }
  switch (request.method) {
    case "icrc25_supported_standards":
      return {
        id,
        jsonrpc: "2.0",
        result: { supportedStandards }
      };
    case "icrc25_permissions":
    case "icrc25_request_permissions":
      return {
        id,
        jsonrpc: "2.0",
        result: { scopes }
      };
    case "icrc34_delegation":
      const delegationRequest = request;
      if (!delegationRequest.params) {
        throw new AuthClientTransportError("Required params missing in request");
      }
      const identity2 = __classPrivateFieldGet9(this, _AuthClientChannel_options, "f").authClient.getIdentity();
      const publicKey = fromBase64(delegationRequest.params.publicKey);
      const expiration = delegationRequest.params.maxTimeToLive ? new Date(Date.now() + Number(BigInt(delegationRequest.params.maxTimeToLive) / BigInt(1e6))) : void 0;
      const delegation = await DelegationChain.create(identity2, { toDer: () => publicKey }, expiration, {
        previous: identity2.getDelegation()
      });
      return {
        id,
        jsonrpc: "2.0",
        result: {
          publicKey: toBase64(delegation.publicKey),
          signerDelegation: delegation.delegations.map(({ delegation: delegation2, signature }) => ({
            delegation: Object.assign({ pubkey: toBase64(delegation2.pubkey), expiration: delegation2.expiration.toString() }, delegation2.targets ? {
              targets: delegation2.targets.map((target) => target.toText())
            } : {}),
            signature: toBase64(signature)
          }))
        }
      };
    default:
      return {
        id,
        jsonrpc: "2.0",
        error: { code: NOT_SUPPORTED_ERROR, message: "Not supported" }
      };
  }
};

// ../../node_modules/@slide-computer/signer-transport-stoic/lib/esm/stoicConnection.js
var import_partial = __toESM(require_partial());
init_esm();
var __classPrivateFieldGet10 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var __classPrivateFieldSet10 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var _StoicConnection_instances;
var _a2;
var _StoicConnection_isInternalConstructing;
var _StoicConnection_options;
var _StoicConnection_delegationChain;
var _StoicConnection_accounts;
var _StoicConnection_disconnectListeners;
var _StoicConnection_disconnectMonitorInterval;
var _StoicConnection_monitorDisconnect;
var ECDSA_KEY_LABEL2 = "ECDSA";
var IDENTITY_STORAGE_KEY = "stoic-base-identity";
var DELEGATION_STORAGE_KEY = "stoic-delegation-chain";
var ACCOUNTS_STORAGE_KEY = "stoic-account-count";
var STOIC_ORIGIN = "https://www.stoicwallet.com";
var STOIC_WINDOW = "stoic";
var StoicConnection = class {
  constructor(options, delegationChain, accounts) {
    _StoicConnection_instances.add(this);
    _StoicConnection_options.set(this, void 0);
    _StoicConnection_delegationChain.set(this, void 0);
    _StoicConnection_accounts.set(this, void 0);
    _StoicConnection_disconnectListeners.set(this, /* @__PURE__ */ new Set());
    _StoicConnection_disconnectMonitorInterval.set(this, void 0);
    const throwError = !__classPrivateFieldGet10(_a2, _a2, "f", _StoicConnection_isInternalConstructing);
    __classPrivateFieldSet10(_a2, _a2, false, "f", _StoicConnection_isInternalConstructing);
    if (throwError) {
      throw new StoicTransportError("StoicTransport is not constructable");
    }
    __classPrivateFieldSet10(this, _StoicConnection_options, options, "f");
    __classPrivateFieldSet10(this, _StoicConnection_delegationChain, delegationChain, "f");
    __classPrivateFieldSet10(this, _StoicConnection_accounts, accounts, "f");
    if (this.connected) {
      __classPrivateFieldGet10(this, _StoicConnection_instances, "m", _StoicConnection_monitorDisconnect).call(this);
    }
  }
  get connected() {
    if (!__classPrivateFieldGet10(this, _StoicConnection_delegationChain, "f")) {
      return false;
    }
    return isDelegationValid(__classPrivateFieldGet10(this, _StoicConnection_delegationChain, "f"));
  }
  get identity() {
    return __classPrivateFieldGet10(this, _StoicConnection_options, "f").identity;
  }
  get delegationChain() {
    return __classPrivateFieldGet10(this, _StoicConnection_delegationChain, "f");
  }
  get accounts() {
    return __classPrivateFieldGet10(this, _StoicConnection_accounts, "f");
  }
  static async create(options) {
    var _b, _c, _d, _e4, _f, _g;
    const maxTimeToLive = (_b = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _b !== void 0 ? _b : BigInt(8) * BigInt(36e11);
    const keyType = (_c = options === null || options === void 0 ? void 0 : options.keyType) !== null && _c !== void 0 ? _c : ECDSA_KEY_LABEL2;
    const storage = (_d = options === null || options === void 0 ? void 0 : options.storage) !== null && _d !== void 0 ? _d : new IdbStorage();
    const crypto2 = (_e4 = options === null || options === void 0 ? void 0 : options.crypto) !== null && _e4 !== void 0 ? _e4 : globalThis.crypto;
    const disconnectMonitoringInterval = (_f = options === null || options === void 0 ? void 0 : options.disconnectMonitoringInterval) !== null && _f !== void 0 ? _f : 3e3;
    let identity2 = (_g = options === null || options === void 0 ? void 0 : options.identity) !== null && _g !== void 0 ? _g : await getIdentity(IDENTITY_STORAGE_KEY, storage);
    if (!identity2) {
      const createdIdentity = await (keyType === "Ed25519" ? Ed25519KeyIdentity.generate(crypto2.getRandomValues(new Uint8Array(32))) : ECDSAKeyIdentity.generate());
      await setIdentity(IDENTITY_STORAGE_KEY, createdIdentity, storage);
      identity2 = createdIdentity;
    }
    const delegationChain = await getDelegationChain(DELEGATION_STORAGE_KEY, storage);
    const accounts = await storage.get(ACCOUNTS_STORAGE_KEY);
    __classPrivateFieldSet10(_a2, _a2, true, "f", _StoicConnection_isInternalConstructing);
    return new _a2({
      maxTimeToLive,
      keyType,
      identity: identity2,
      storage,
      crypto: crypto2,
      disconnectMonitoringInterval
    }, delegationChain, accounts ? Number(accounts) : void 0);
  }
  async connect() {
    return new Promise(async (resolve, reject) => {
      __classPrivateFieldSet10(this, _StoicConnection_delegationChain, void 0, "f");
      const keypair = {
        current: await __classPrivateFieldGet10(this, _StoicConnection_options, "f").crypto.subtle.generateKey({
          name: "ECDSA",
          namedCurve: "P-384"
        }, false, ["sign", "verify"])
      };
      const apikey = toHex(await __classPrivateFieldGet10(this, _StoicConnection_options, "f").crypto.subtle.exportKey("spki", keypair.current.publicKey));
      const tunnel = document.createElement("iframe");
      tunnel.width = "0";
      tunnel.height = "0";
      tunnel.style.borderWidth = "0";
      const delegation = new Delegation(__classPrivateFieldGet10(this, _StoicConnection_options, "f").identity.getPublicKey().toDer(), BigInt(Date.now()) * BigInt(1e6) + __classPrivateFieldGet10(this, _StoicConnection_options, "f").maxTimeToLive);
      let publicKey;
      const complete = async () => {
        window.removeEventListener("message", listener);
        document.body.removeChild(tunnel);
        await setDelegationChain(DELEGATION_STORAGE_KEY, __classPrivateFieldGet10(this, _StoicConnection_delegationChain, "f"), __classPrivateFieldGet10(this, _StoicConnection_options, "f").storage);
        await __classPrivateFieldGet10(this, _StoicConnection_options, "f").storage.set(ACCOUNTS_STORAGE_KEY, `${__classPrivateFieldGet10(this, _StoicConnection_accounts, "f")}`);
        __classPrivateFieldGet10(this, _StoicConnection_instances, "m", _StoicConnection_monitorDisconnect).call(this);
        resolve();
      };
      const listener = (event) => {
        var _b;
        if (!stoicWindow || event.origin !== STOIC_ORIGIN) {
          return;
        }
        if (event.source === tunnel.contentWindow && event.data.target === "STOIC-EXT") {
          if (!event.data.success) {
            window.removeEventListener("message", listener);
            document.body.removeChild(tunnel);
            reject(new StoicTransportError(event.data.data));
            return;
          }
          switch (event.data.action) {
            case "accounts":
              __classPrivateFieldSet10(this, _StoicConnection_accounts, JSON.parse(event.data.data).length, "f");
              if (__classPrivateFieldGet10(this, _StoicConnection_delegationChain, "f")) {
                complete();
              }
              break;
            case "sign":
              const data = JSON.parse(event.data.data);
              const signature = fromHex(data.signed);
              const previousDelegationChain = data.chain && DelegationChain.fromJSON(data.chain);
              __classPrivateFieldSet10(this, _StoicConnection_delegationChain, DelegationChain.fromDelegations([
                ...(_b = previousDelegationChain === null || previousDelegationChain === void 0 ? void 0 : previousDelegationChain.delegations) !== null && _b !== void 0 ? _b : [],
                { delegation, signature }
              ], publicKey), "f");
              if (__classPrivateFieldGet10(this, _StoicConnection_accounts, "f")) {
                complete();
              }
              break;
          }
          return;
        }
        if (event.source !== stoicWindow) {
          return;
        }
        switch (event.data.action) {
          case "initiateStoicConnect":
            stoicWindow.postMessage({ action: "requestAuthorization", apikey }, STOIC_ORIGIN);
            break;
          case "rejectAuthorization":
            stoicWindow.close();
            window.removeEventListener("message", listener);
            reject(new StoicTransportError("Connection is rejected"));
            break;
          case "confirmAuthorization":
            publicKey = new Uint8Array(Object.values(event.data.key)).buffer;
            const principal = Principal.selfAuthenticating(new Uint8Array(publicKey)).toText();
            stoicWindow.close();
            document.body.appendChild(tunnel);
            tunnel.onload = async () => {
              if (!tunnel.contentWindow) {
                reject(new StoicTransportError("Tunnel could not be established"));
                return;
              }
              tunnel.contentWindow.postMessage({
                target: "STOIC-IFRAME",
                action: "accounts",
                payload: "accounts",
                principal,
                apikey,
                sig: toHex(await window.crypto.subtle.sign({
                  name: "ECDSA",
                  hash: { name: "SHA-384" }
                }, keypair.current.privateKey, new TextEncoder().encode("accounts")))
              }, STOIC_ORIGIN);
              const challenge = toHex(new Uint8Array([
                ...new TextEncoder().encode("ic-request-auth-delegation"),
                ...new Uint8Array(requestIdOf(Object.assign({}, delegation)))
              ]).buffer);
              tunnel.contentWindow.postMessage({
                target: "STOIC-IFRAME",
                action: "sign",
                payload: challenge,
                principal,
                apikey,
                sig: toHex(await window.crypto.subtle.sign({
                  name: "ECDSA",
                  hash: { name: "SHA-384" }
                }, keypair.current.privateKey, new TextEncoder().encode(challenge)))
              }, STOIC_ORIGIN);
              delete keypair.current;
            };
            tunnel.src = new URL("?stoicTunnel", STOIC_ORIGIN).href;
            break;
        }
      };
      window.addEventListener("message", listener);
      const stoicWindow = window.open(new URL("?authorizeApp", STOIC_ORIGIN), STOIC_WINDOW);
    });
  }
  async disconnect() {
    clearInterval(__classPrivateFieldGet10(this, _StoicConnection_disconnectMonitorInterval, "f"));
    await removeDelegationChain(DELEGATION_STORAGE_KEY, __classPrivateFieldGet10(this, _StoicConnection_options, "f").storage);
    await __classPrivateFieldGet10(this, _StoicConnection_options, "f").storage.remove(ACCOUNTS_STORAGE_KEY);
    __classPrivateFieldSet10(this, _StoicConnection_delegationChain, void 0, "f");
    __classPrivateFieldSet10(this, _StoicConnection_accounts, void 0, "f");
    __classPrivateFieldGet10(this, _StoicConnection_disconnectListeners, "f").forEach((listener) => listener());
  }
  addEventListener(event, listener) {
    switch (event) {
      case "disconnect":
        __classPrivateFieldGet10(this, _StoicConnection_disconnectListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet10(this, _StoicConnection_disconnectListeners, "f").delete(listener);
        };
    }
  }
};
_a2 = StoicConnection, _StoicConnection_options = /* @__PURE__ */ new WeakMap(), _StoicConnection_delegationChain = /* @__PURE__ */ new WeakMap(), _StoicConnection_accounts = /* @__PURE__ */ new WeakMap(), _StoicConnection_disconnectListeners = /* @__PURE__ */ new WeakMap(), _StoicConnection_disconnectMonitorInterval = /* @__PURE__ */ new WeakMap(), _StoicConnection_instances = /* @__PURE__ */ new WeakSet(), _StoicConnection_monitorDisconnect = function _StoicConnection_monitorDisconnect2() {
  __classPrivateFieldSet10(this, _StoicConnection_disconnectMonitorInterval, setInterval(() => {
    if (!this.connected) {
      __classPrivateFieldGet10(this, _StoicConnection_disconnectListeners, "f").forEach((listener) => listener());
      clearInterval(__classPrivateFieldGet10(this, _StoicConnection_disconnectMonitorInterval, "f"));
    }
  }, __classPrivateFieldGet10(this, _StoicConnection_options, "f").disconnectMonitoringInterval), "f");
};
_StoicConnection_isInternalConstructing = { value: false };

// ../../node_modules/@slide-computer/signer-transport-stoic/lib/esm/stoicTransport.js
var __classPrivateFieldGet11 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var __classPrivateFieldSet11 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var _a3;
var _StoicTransport_isInternalConstructing;
var _StoicTransport_connection;
var _StoicTransport_agent;
var StoicTransportError = class _StoicTransportError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _StoicTransportError.prototype);
  }
};
var StoicTransport = class {
  constructor(connection, agent) {
    _StoicTransport_connection.set(this, void 0);
    _StoicTransport_agent.set(this, void 0);
    const throwError = !__classPrivateFieldGet11(_a3, _a3, "f", _StoicTransport_isInternalConstructing);
    __classPrivateFieldSet11(_a3, _a3, false, "f", _StoicTransport_isInternalConstructing);
    if (throwError) {
      throw new StoicTransportError("StoicTransport is not constructable");
    }
    __classPrivateFieldSet11(this, _StoicTransport_connection, connection, "f");
    __classPrivateFieldSet11(this, _StoicTransport_agent, agent, "f");
  }
  get connection() {
    return __classPrivateFieldGet11(this, _StoicTransport_connection, "f");
  }
  static async create(options) {
    const connection = await StoicConnection.create(options);
    __classPrivateFieldSet11(_a3, _a3, true, "f", _StoicTransport_isInternalConstructing);
    return new _a3(connection, options === null || options === void 0 ? void 0 : options.agent);
  }
  async establishChannel() {
    if (!__classPrivateFieldGet11(this, _StoicTransport_connection, "f").connected) {
      throw new StoicTransportError("StoicTransport is not connected");
    }
    return new StoicChannel(__classPrivateFieldGet11(this, _StoicTransport_connection, "f"), __classPrivateFieldGet11(this, _StoicTransport_agent, "f"));
  }
};
_a3 = StoicTransport, _StoicTransport_connection = /* @__PURE__ */ new WeakMap(), _StoicTransport_agent = /* @__PURE__ */ new WeakMap();
_StoicTransport_isInternalConstructing = { value: false };

// ../../node_modules/@slide-computer/signer-transport-stoic/lib/esm/constants.js
var supportedStandards2 = [
  {
    name: "ICRC-25",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-25/ICRC-25.md"
  },
  {
    name: "ICRC-27",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-27/ICRC-27.md"
  },
  {
    name: "ICRC-34",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-34/ICRC-34.md"
  },
  {
    name: "ICRC-49",
    url: "https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-49/ICRC-49.md"
  }
];
var scopes2 = [
  {
    scope: {
      method: "icrc27_accounts"
    },
    state: "granted"
  },
  {
    scope: {
      method: "icrc34_delegation"
    },
    state: "granted"
  },
  {
    scope: {
      method: "icrc49_call_canister"
    },
    state: "granted"
  }
];

// ../../node_modules/@slide-computer/signer-transport-stoic/lib/esm/stoicChannel.js
init_esm();
var __classPrivateFieldSet12 = function(receiver, state, value, kind, f22) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f22.call(receiver, value) : f22 ? f22.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet12 = function(receiver, state, kind, f22) {
  if (kind === "a" && !f22)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f22 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f22 : kind === "a" ? f22.call(receiver) : f22 ? f22.value : state.get(receiver);
};
var _StoicChannel_instances;
var _StoicChannel_connection;
var _StoicChannel_agent;
var _StoicChannel_closeListeners;
var _StoicChannel_responseListeners;
var _StoicChannel_closed;
var _StoicChannel_createResponse;
var StoicChannel = class {
  constructor(connection, agent) {
    _StoicChannel_instances.add(this);
    _StoicChannel_connection.set(this, void 0);
    _StoicChannel_agent.set(this, void 0);
    _StoicChannel_closeListeners.set(this, /* @__PURE__ */ new Set());
    _StoicChannel_responseListeners.set(this, /* @__PURE__ */ new Set());
    _StoicChannel_closed.set(this, false);
    __classPrivateFieldSet12(this, _StoicChannel_connection, connection, "f");
    __classPrivateFieldSet12(this, _StoicChannel_agent, agent, "f");
    __classPrivateFieldGet12(this, _StoicChannel_connection, "f").addEventListener("disconnect", () => __classPrivateFieldSet12(this, _StoicChannel_closed, true, "f"));
  }
  get closed() {
    return __classPrivateFieldGet12(this, _StoicChannel_closed, "f") || !__classPrivateFieldGet12(this, _StoicChannel_connection, "f").connected;
  }
  addEventListener(...[event, listener]) {
    switch (event) {
      case "close":
        __classPrivateFieldGet12(this, _StoicChannel_closeListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet12(this, _StoicChannel_closeListeners, "f").delete(listener);
        };
      case "response":
        __classPrivateFieldGet12(this, _StoicChannel_responseListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet12(this, _StoicChannel_responseListeners, "f").delete(listener);
        };
    }
  }
  async send(request) {
    if (this.closed) {
      throw new StoicTransportError("Communication channel is closed");
    }
    const id = request.id;
    if (id === void 0) {
      return;
    }
    const response = await __classPrivateFieldGet12(this, _StoicChannel_instances, "m", _StoicChannel_createResponse).call(this, Object.assign({ id }, request));
    __classPrivateFieldGet12(this, _StoicChannel_responseListeners, "f").forEach((listener) => listener(response));
  }
  async close() {
    __classPrivateFieldSet12(this, _StoicChannel_closed, true, "f");
    __classPrivateFieldGet12(this, _StoicChannel_closeListeners, "f").forEach((listener) => listener());
  }
};
_StoicChannel_connection = /* @__PURE__ */ new WeakMap(), _StoicChannel_agent = /* @__PURE__ */ new WeakMap(), _StoicChannel_closeListeners = /* @__PURE__ */ new WeakMap(), _StoicChannel_responseListeners = /* @__PURE__ */ new WeakMap(), _StoicChannel_closed = /* @__PURE__ */ new WeakMap(), _StoicChannel_instances = /* @__PURE__ */ new WeakSet(), _StoicChannel_createResponse = async function _StoicChannel_createResponse2(request) {
  var _a4, _b, _c, _d;
  const id = request.id;
  if (!isJsonRpcRequest(request)) {
    return {
      id,
      jsonrpc: "2.0",
      error: { code: INVALID_REQUEST_ERROR, message: "Invalid request" }
    };
  }
  switch (request.method) {
    case "icrc25_supported_standards":
      return {
        id,
        jsonrpc: "2.0",
        result: { supportedStandards: supportedStandards2 }
      };
    case "icrc25_permissions":
    case "icrc25_request_permissions":
      return {
        id,
        jsonrpc: "2.0",
        result: { scopes: scopes2 }
      };
    case "icrc27_accounts":
      const owner = Principal.selfAuthenticating(new Uint8Array(__classPrivateFieldGet12(this, _StoicChannel_connection, "f").delegationChain.publicKey)).toText();
      return {
        id,
        jsonrpc: "2.0",
        result: {
          accounts: Array.from({
            length: (_a4 = __classPrivateFieldGet12(this, _StoicChannel_connection, "f").accounts) !== null && _a4 !== void 0 ? _a4 : 0
          }).map((_9, index3) => {
            const buffer = new ArrayBuffer(32);
            new DataView(buffer).setBigUint64(24, BigInt(index3), false);
            return {
              owner,
              subaccount: toBase64(buffer)
            };
          })
        }
      };
    case "icrc34_delegation":
      const delegationRequest = request;
      const identity2 = __classPrivateFieldGet12(this, _StoicChannel_connection, "f").identity;
      const delegationChain = __classPrivateFieldGet12(this, _StoicChannel_connection, "f").delegationChain;
      const expiration = new Date(Date.now() + Number(delegationRequest.params.maxTimeToLive ? BigInt(delegationRequest.params.maxTimeToLive) / BigInt(1e6) : BigInt(8) * BigInt(36e5)));
      const signedDelegationChain = await DelegationChain.create(identity2, { toDer: () => fromBase64(delegationRequest.params.publicKey) }, expiration, {
        previous: delegationChain,
        targets: (_b = delegationRequest.params.targets) === null || _b === void 0 ? void 0 : _b.map((target) => Principal.fromText(target))
      });
      return {
        id,
        jsonrpc: "2.0",
        result: {
          publicKey: toBase64(signedDelegationChain.publicKey),
          signerDelegation: signedDelegationChain.delegations.map(({ delegation, signature }) => ({
            delegation: Object.assign({ pubkey: toBase64(delegation.pubkey), expiration: delegation.expiration.toString() }, delegation.targets ? {
              targets: delegation.targets.map((target) => target.toText())
            } : {}),
            signature: toBase64(signature)
          }))
        }
      };
    case "icrc49_call_canister":
      const callCanisterRequest = request;
      const { pollForResponse, defaultStrategy } = polling_exports;
      const canisterId = Principal.fromText(callCanisterRequest.params.canisterId);
      const delegationIdentity = DelegationIdentity.fromDelegation(__classPrivateFieldGet12(this, _StoicChannel_connection, "f").identity, __classPrivateFieldGet12(this, _StoicChannel_connection, "f").delegationChain);
      if (((_c = callCanisterRequest.params) === null || _c === void 0 ? void 0 : _c.sender) !== delegationIdentity.getPrincipal().toString()) {
        throw new StoicTransportError("Sender does not match Stoic identity");
      }
      const agent = await HttpAgent.from((_d = __classPrivateFieldGet12(this, _StoicChannel_agent, "f")) !== null && _d !== void 0 ? _d : await HttpAgent.create());
      agent.replaceIdentity(delegationIdentity);
      let contentMap;
      agent.addTransform("update", async (agentRequest) => {
        contentMap = cbor_exports.encode(agentRequest.body);
        return agentRequest;
      });
      const submitResponse = await agent.call(canisterId, {
        effectiveCanisterId: canisterId,
        methodName: callCanisterRequest.params.method,
        arg: fromBase64(callCanisterRequest.params.arg)
      });
      await pollForResponse(agent, canisterId, submitResponse.requestId, defaultStrategy());
      const { certificate } = await agent.readState(canisterId, {
        paths: [
          [
            new TextEncoder().encode("request_status"),
            submitResponse.requestId
          ]
        ]
      });
      return {
        id,
        jsonrpc: "2.0",
        result: {
          contentMap: toBase64(contentMap),
          certificate: toBase64(certificate)
        }
      };
    default:
      return {
        id,
        jsonrpc: "2.0",
        error: { code: NOT_SUPPORTED_ERROR, message: "Not supported" }
      };
  }
};

// ../../node_modules/@nfid/identitykit/dist/libs/react/index.esm.js
var import_use_async_memo = __toESM(require_use_async_memo());

// ../../node_modules/clsx/dist/clsx.mjs
function r(e8) {
  var t11, f22, n13 = "";
  if ("string" == typeof e8 || "number" == typeof e8)
    n13 += e8;
  else if ("object" == typeof e8)
    if (Array.isArray(e8)) {
      var o17 = e8.length;
      for (t11 = 0; t11 < o17; t11++)
        e8[t11] && (f22 = r(e8[t11])) && (n13 && (n13 += " "), n13 += f22);
    } else
      for (f22 in e8)
        e8[f22] && (n13 && (n13 += " "), n13 += f22);
  return n13;
}
function clsx() {
  for (var e8, t11, f22 = 0, n13 = "", o17 = arguments.length; f22 < o17; f22++)
    (e8 = arguments[f22]) && (t11 = r(e8)) && (n13 && (n13 += " "), n13 += t11);
  return n13;
}
var clsx_default = clsx;

// ../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs
var import_react2 = __toESM(require_react(), 1);
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, import_react2.default).useLayoutEffect : () => {
};

// ../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs
var import_react3 = __toESM(require_react(), 1);
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
  const ref = (0, import_react3.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    ref.current = fn;
  }, [
    fn
  ]);
  return (0, import_react3.useCallback)((...args) => {
    const f22 = ref.current;
    return f22 === null || f22 === void 0 ? void 0 : f22(...args);
  }, []);
}

// ../../node_modules/@react-aria/utils/dist/useValueEffect.mjs
var import_react4 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useId.mjs
var import_react6 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/ssr/dist/SSRProvider.mjs
var import_react5 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react5.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react5.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled2 = false) {
  let ctx = (0, import_react5.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react5.useRef)(null);
  if (ref.current === null && !isDisabled2) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react5.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react5.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM)
    console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id = (0, import_react5.default).useId();
  let [didSSR] = (0, import_react5.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix}-${id}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react5.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react5.default)["useSyncExternalStore"] === "function")
    return (0, import_react5.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react5.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// ../../node_modules/@react-aria/utils/dist/useId.mjs
var $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$export$d41a04c74483c6ef = /* @__PURE__ */ new Map();
var $bdb11010cef70236$var$registry;
if (typeof FinalizationRegistry !== "undefined")
  $bdb11010cef70236$var$registry = new FinalizationRegistry((heldValue) => {
    $bdb11010cef70236$export$d41a04c74483c6ef.delete(heldValue);
  });
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
  if (idA === idB)
    return idA;
  let setIdsA = $bdb11010cef70236$export$d41a04c74483c6ef.get(idA);
  if (setIdsA) {
    setIdsA.forEach((ref) => ref.current = idB);
    return idB;
  }
  let setIdsB = $bdb11010cef70236$export$d41a04c74483c6ef.get(idB);
  if (setIdsB) {
    setIdsB.forEach((ref) => ref.current = idA);
    return idA;
  }
  return idB;
}

// ../../node_modules/@react-aria/utils/dist/chain.mjs
function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {
  return (...args) => {
    for (let callback of callbacks)
      if (typeof callback === "function")
        callback(...args);
  };
}

// ../../node_modules/@react-aria/utils/dist/domHelpers.mjs
var $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el)
    return el;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc.defaultView || window;
};
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
  return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node;
}

// ../../node_modules/@react-stately/flags/dist/import.mjs
var $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}

// ../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
  if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)())
    return otherNode && node ? node.contains(otherNode) : false;
  if (!node || !otherNode)
    return false;
  let currentNode = otherNode;
  while (currentNode !== null) {
    if (currentNode === node)
      return true;
    if (currentNode.tagName === "SLOT" && currentNode.assignedSlot)
      currentNode = currentNode.assignedSlot.parentNode;
    else if ((0, $431fbd86ca7dc216$export$af51f0f06c0f328a)(currentNode))
      currentNode = currentNode.host;
    else
      currentNode = currentNode.parentNode;
  }
  return false;
}
var $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)())
    return doc.activeElement;
  let activeElement2 = doc.activeElement;
  while (activeElement2 && "shadowRoot" in activeElement2 && ((_activeElement_shadowRoot = activeElement2.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement))
    activeElement2 = activeElement2.shadowRoot.activeElement;
  return activeElement2;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  if ((0, $f4e2df6bd15f8569$export$98658e8c59125e6a)() && event.target.shadowRoot) {
    if (event.composedPath)
      return event.composedPath()[0];
  }
  return event.target;
}

// ../../node_modules/@react-aria/utils/dist/mergeProps.mjs
function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {
  let result = {
    ...args[0]
  };
  for (let i15 = 1; i15 < args.length; i15++) {
    let props = args[i15];
    for (let key in props) {
      let a20 = result[key];
      let b9 = props[key];
      if (typeof a20 === "function" && typeof b9 === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90)
        result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a20, b9);
      else if ((key === "className" || key === "UNSAFE_className") && typeof a20 === "string" && typeof b9 === "string")
        result[key] = (0, clsx_default)(a20, b9);
      else if (key === "id" && a20 && b9)
        result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a20, b9);
      else
        result[key] = b9 !== void 0 ? b9 : a20;
    }
  }
  return result;
}

// ../../node_modules/@react-aria/utils/dist/mergeRefs.mjs
function $5dc95899b306f630$export$c9058316764c140e(...refs) {
  if (refs.length === 1 && refs[0])
    return refs[0];
  return (value) => {
    for (let ref of refs) {
      if (typeof ref === "function")
        ref(value);
      else if (ref != null)
        ref.current = value;
    }
  };
}

// ../../node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs
function $7215afc6de606d6b$export$de79e2c695e052f3(element) {
  if ($7215afc6de606d6b$var$supportsPreventScroll())
    element.focus({
      preventScroll: true
    });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);
    element.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element) {
  let parent = element.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth)
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement)
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element, scrollTop, scrollLeft } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}

// ../../node_modules/@react-aria/utils/dist/platform.mjs
function $c87311424ea30a05$var$testUserAgent(re5) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null)
    return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re5.test(brand.brand))) || re5.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re5) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re5.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
  let res = null;
  return () => {
    if (res == null)
      res = fn();
    return res;
  };
}
var $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
var $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
var $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
var $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
var $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
var $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
var $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
var $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
var $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});

// ../../node_modules/@react-aria/utils/dist/openLink.mjs
var import_react7 = __toESM(require_react(), 1);
var $ea8dcbcb9ea1b556$var$RouterContext = (0, import_react7.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink,
  useHref: (href) => href
});
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea10)())
      metaKey = true;
    else
      ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {
  if (target instanceof HTMLAnchorElement)
    open(target);
  else if (target.hasAttribute("data-href")) {
    let link = document.createElement("a");
    link.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target"))
      link.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel"))
      link.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download"))
      link.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping"))
      link.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy"))
      link.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link);
    open(link);
    target.removeChild(link);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link) => $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));
}

// ../../node_modules/@react-aria/utils/dist/runAfterTransition.mjs
var $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined")
    return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e8) => {
    if (!isTransitionEvent(e8) || !e8.target)
      return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e8.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e8.target, transitions);
      e8.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e8.propertyName);
  };
  let onTransitionEnd = (e8) => {
    if (!isTransitionEvent(e8) || !e8.target)
      return;
    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e8.target);
    if (!properties)
      return;
    properties.delete(e8.propertyName);
    if (properties.size === 0) {
      e8.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e8.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)
        cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading")
    $bbed8b41f857bcc0$var$setupGlobalEvents();
  else
    document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn) {
  requestAnimationFrame(() => {
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0)
      fn();
    else
      $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);
  });
}

// ../../node_modules/@react-aria/utils/dist/useDrag1D.mjs
var import_react8 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
var import_react9 = __toESM(require_react(), 1);
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = (0, import_react9.useRef)(/* @__PURE__ */ new Map());
  let addGlobalListener = (0, import_react9.useCallback)((eventTarget, type, listener, options) => {
    let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    });
    eventTarget.addEventListener(type, fn, options);
  }, []);
  let removeGlobalListener = (0, import_react9.useCallback)((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = (0, import_react9.useCallback)(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  (0, import_react9.useEffect)(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}

// ../../node_modules/@react-aria/utils/dist/useObjectRef.mjs
var import_react10 = __toESM(require_react(), 1);
function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {
  const objRef = (0, import_react10.useRef)(null);
  return (0, import_react10.useMemo)(() => ({
    get current() {
      return objRef.current;
    },
    set current(value) {
      objRef.current = value;
      if (typeof forwardedRef === "function")
        forwardedRef(value);
      else if (forwardedRef)
        forwardedRef.current = value;
    }
  }), [
    forwardedRef
  ]);
}

// ../../node_modules/@react-aria/utils/dist/useUpdateEffect.mjs
var import_react11 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useUpdateLayoutEffect.mjs
var import_react12 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useResizeObserver.mjs
var import_react13 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useSyncRef.mjs
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        if (context.ref)
          context.ref.current = null;
      };
    }
  });
}

// ../../node_modules/@react-aria/utils/dist/useViewportSize.mjs
var import_react14 = __toESM(require_react(), 1);
var $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;

// ../../node_modules/@react-aria/utils/dist/useDescription.mjs
var import_react15 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useEvent.mjs
var import_react16 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted)
    return true;
  if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType)
    return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
  return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}

// ../../node_modules/@react-aria/utils/dist/useDeepMemo.mjs
var import_react17 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useFormReset.mjs
var import_react18 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/useLoadMore.mjs
var import_react19 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/inertValue.mjs
var import_react20 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/animation.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react21 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/utils/dist/isFocusable.mjs
var $b4b717babfbb907b$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])'
];
var $b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$b4b717babfbb907b$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $b4b717babfbb907b$var$TABBABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $b4b717babfbb907b$export$4c063cf1350e6fed(element) {
  return element.matches($b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR);
}

// ../../node_modules/@react-stately/utils/dist/useControlledState.mjs
var import_react22 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/interactions/dist/textSelection.mjs
var $14c0b72509d70225$var$state = "default";
var $14c0b72509d70225$var$savedUserSelect = "";
var $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style[property]);
    target.style[property] = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state !== "disabled")
      return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none")
            documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
      if (target.style[property] === "none")
        target.style[property] = targetOldUserSelect;
      if (target.getAttribute("style") === "")
        target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}

// ../../node_modules/@react-aria/interactions/dist/context.mjs
var import_react23 = __toESM(require_react(), 1);
var $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, import_react23.default).createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";

// ../../node_modules/@react-aria/interactions/dist/utils.mjs
var import_react24 = __toESM(require_react(), 1);
var $8a9cb279dc87e130$export$905e7fc544a71f36 = class {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation();
    this.isPropagationStopped = () => true;
  }
  isPropagationStopped() {
    return false;
  }
  persist() {
  }
  constructor(type, nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.currentTarget = nativeEvent.currentTarget;
    this.relatedTarget = nativeEvent.relatedTarget;
    this.bubbles = nativeEvent.bubbles;
    this.cancelable = nativeEvent.cancelable;
    this.defaultPrevented = nativeEvent.defaultPrevented;
    this.eventPhase = nativeEvent.eventPhase;
    this.isTrusted = nativeEvent.isTrusted;
    this.timeStamp = nativeEvent.timeStamp;
    this.type = type;
  }
};
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = (0, import_react24.useRef)({
    isFocused: false,
    observer: null
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e8) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e8);
  });
  return (0, import_react24.useCallback)((e8) => {
    if (e8.target instanceof HTMLButtonElement || e8.target instanceof HTMLInputElement || e8.target instanceof HTMLTextAreaElement || e8.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e8.target;
      let onBlurHandler = (e9) => {
        stateRef.current.isFocused = false;
        if (target.disabled)
          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e9));
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
var $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
function $8a9cb279dc87e130$export$cabe61c495ee3649(target) {
  while (target && !(0, $b4b717babfbb907b$export$4c063cf1350e6fed)(target))
    target = target.parentElement;
  let window2 = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(target);
  let activeElement2 = window2.document.activeElement;
  if (!activeElement2 || activeElement2 === target)
    return;
  $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;
  let isRefocusing = false;
  let onBlur = (e8) => {
    if (e8.target === activeElement2 || isRefocusing)
      e8.stopImmediatePropagation();
  };
  let onFocusOut = (e8) => {
    if (e8.target === activeElement2 || isRefocusing) {
      e8.stopImmediatePropagation();
      if (!target && !isRefocusing) {
        isRefocusing = true;
        (0, $7215afc6de606d6b$export$de79e2c695e052f3)(activeElement2);
        cleanup2();
      }
    }
  };
  let onFocus = (e8) => {
    if (e8.target === target || isRefocusing)
      e8.stopImmediatePropagation();
  };
  let onFocusIn = (e8) => {
    if (e8.target === target || isRefocusing) {
      e8.stopImmediatePropagation();
      if (!isRefocusing) {
        isRefocusing = true;
        (0, $7215afc6de606d6b$export$de79e2c695e052f3)(activeElement2);
        cleanup2();
      }
    }
  };
  window2.addEventListener("blur", onBlur, true);
  window2.addEventListener("focusout", onFocusOut, true);
  window2.addEventListener("focusin", onFocusIn, true);
  window2.addEventListener("focus", onFocus, true);
  let cleanup2 = () => {
    cancelAnimationFrame(raf);
    window2.removeEventListener("blur", onBlur, true);
    window2.removeEventListener("focusout", onFocusOut, true);
    window2.removeEventListener("focusin", onFocusIn, true);
    window2.removeEventListener("focus", onFocus, true);
    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
    isRefocusing = false;
  };
  let raf = requestAnimationFrame(cleanup2);
  return cleanup2;
}

// ../../node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get)
    return descriptor.get.call(receiver);
  return descriptor.value;
}

// ../../node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// ../../node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// ../../node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// ../../node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// ../../node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}

// ../../node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value);
  return value;
}

// ../../node_modules/@react-aria/interactions/dist/usePress.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_react25 = __toESM(require_react(), 1);
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = (0, import_react25.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  if (context) {
    let { register, ...contextProps } = context;
    props = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(contextProps, props);
    register();
  }
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
var $f6c31cce2adf654f$var$PressEvent = class {
  continuePropagation() {
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return (0, _class_private_field_get)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type, pointerType, originalEvent, state) {
    (0, _class_private_field_init)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    var _state_target;
    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;
    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();
    let x10, y9 = 0;
    let clientX, clientY = null;
    if (originalEvent.clientX != null && originalEvent.clientY != null) {
      clientX = originalEvent.clientX;
      clientY = originalEvent.clientY;
    }
    if (rect) {
      if (clientX != null && clientY != null) {
        x10 = clientX - rect.left;
        y9 = clientY - rect.top;
      } else {
        x10 = rect.width / 2;
        y9 = rect.height / 2;
      }
    }
    this.type = type;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
    this.x = x10;
    this.y = y9;
  }
};
var $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled: isDisabled2,
    isPressed: isPressedProp,
    preventFocusOnPress,
    shouldCancelOnPointerExit,
    allowTextSelectionOnPress,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _9,
    ...domProps
  } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = (0, import_react25.useState)(false);
  let ref = (0, import_react25.useRef)({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null,
    disposables: []
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let triggerPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled2 || state.didFirePressStart)
      return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart)
      return false;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled2) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled2)
      return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e8) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.didFirePressStart && state.pointerType != null)
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e8), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
      for (let dispose of state.disposables)
        dispose();
      state.disposables = [];
    }
  });
  let cancelOnPointerExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e8) => {
    if (shouldCancelOnPointerExit)
      cancel(e8);
  });
  let pressProps = (0, import_react25.useMemo)(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e8) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e8.nativeEvent, e8.currentTarget) && (0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent))) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent), e8.key))
            e8.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e8.repeat) {
            state.target = e8.currentTarget;
            state.isPressed = true;
            state.pointerType = "keyboard";
            shouldStopPropagation = triggerPressStart(e8, "keyboard");
            let originalTarget = e8.currentTarget;
            let pressUp = (e9) => {
              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e9, originalTarget) && !e9.repeat && (0, $d4ee10de306f2510$export$4282f70798064fe0)(originalTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e9)) && state.target)
                triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e9), "keyboard");
            };
            addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.currentTarget), "keyup", (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(pressUp, onKeyUp), true);
          }
          if (shouldStopPropagation)
            e8.stopPropagation();
          if (e8.metaKey && (0, $c87311424ea30a05$export$9ac100e40613ea10)())
            (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e8.key, e8.nativeEvent);
        } else if (e8.key === "Meta")
          state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onClick(e8) {
        if (e8 && !(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (e8 && e8.button === 0 && !state.isTriggeringEvent && !(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled2)
            e8.preventDefault();
          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $6a7db85432448f7f$export$60278871457622de)(e8.nativeEvent))) {
            let stopPressStart = triggerPressStart(e8, "virtual");
            let stopPressUp = triggerPressUp(e8, "virtual");
            let stopPressEnd = triggerPressEnd(e8, "virtual");
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          } else if (state.isPressed && state.pointerType !== "keyboard") {
            let pointerType = state.pointerType || e8.nativeEvent.pointerType || "virtual";
            shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(e8.currentTarget, e8), pointerType, true);
            state.isOverTarget = false;
            cancel(e8);
          }
          state.ignoreEmulatedMouseEvents = false;
          if (shouldStopPropagation)
            e8.stopPropagation();
        }
      }
    };
    let onKeyUp = (e8) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e8, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8), e8.key))
          e8.preventDefault();
        let target = (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8);
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e8), "keyboard", (0, $d4ee10de306f2510$export$4282f70798064fe0)(state.target, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8)));
        removeAllGlobalListeners();
        if (e8.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && (0, $d4ee10de306f2510$export$4282f70798064fe0)(state.target, target) && !e8[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e8[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          (0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7)(state.target, e8, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e8.key);
      } else if (e8.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events3 = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events3.values())
          (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e8) => {
        if (e8.button !== 0 || !(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if ((0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e8.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        state.pointerType = e8.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e8.pointerId;
          state.target = e8.currentTarget;
          if (!allowTextSelectionOnPress)
            (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
          shouldStopPropagation = triggerPressStart(e8, state.pointerType);
          let target = (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent);
          if ("releasePointerCapture" in target)
            target.releasePointerCapture(e8.pointerId);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation)
          e8.stopPropagation();
      };
      pressProps2.onMouseDown = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (e8.button === 0) {
          if (preventFocusOnPress) {
            let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e8.target);
            if (dispose)
              state.disposables.push(dispose);
          }
          e8.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)) || state.pointerType === "virtual")
          return;
        if (e8.button === 0)
          triggerPressUp(e8, state.pointerType || e8.pointerType);
      };
      pressProps2.onPointerEnter = (e8) => {
        if (e8.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = true;
          triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e8), state.pointerType);
        }
      };
      pressProps2.onPointerLeave = (e8) => {
        if (e8.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e8), state.pointerType, false);
          cancelOnPointerExit(e8);
        }
      };
      let onPointerUp = (e8) => {
        if (e8.pointerId === state.activePointerId && state.isPressed && e8.button === 0 && state.target) {
          if ((0, $d4ee10de306f2510$export$4282f70798064fe0)(state.target, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8)) && state.pointerType != null) {
            let clicked = false;
            let timeout = setTimeout(() => {
              if (state.isPressed && state.target instanceof HTMLElement) {
                if (clicked)
                  cancel(e8);
                else {
                  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(state.target);
                  state.target.click();
                }
              }
            }, 80);
            addGlobalListener(e8.currentTarget, "click", () => clicked = true, true);
            state.disposables.push(() => clearTimeout(timeout));
          } else
            cancel(e8);
          state.isOverTarget = false;
        }
      };
      let onPointerCancel = (e8) => {
        cancel(e8);
      };
      pressProps2.onDragStart = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        cancel(e8);
      };
    } else {
      pressProps2.onMouseDown = (e8) => {
        if (e8.button !== 0 || !(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (state.ignoreEmulatedMouseEvents) {
          e8.stopPropagation();
          return;
        }
        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e8.currentTarget;
        state.pointerType = (0, $6a7db85432448f7f$export$60278871457622de)(e8.nativeEvent) ? "virtual" : "mouse";
        let shouldStopPropagation = (0, import_react_dom2.flushSync)(() => triggerPressStart(e8, state.pointerType));
        if (shouldStopPropagation)
          e8.stopPropagation();
        if (preventFocusOnPress) {
          let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e8.target);
          if (dispose)
            state.disposables.push(dispose);
        }
        addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.currentTarget), "mouseup", onMouseUp, false);
      };
      pressProps2.onMouseEnter = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = true;
          shouldStopPropagation = triggerPressStart(e8, state.pointerType);
        }
        if (shouldStopPropagation)
          e8.stopPropagation();
      };
      pressProps2.onMouseLeave = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e8, state.pointerType, false);
          cancelOnPointerExit(e8);
        }
        if (shouldStopPropagation)
          e8.stopPropagation();
      };
      pressProps2.onMouseUp = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (!state.ignoreEmulatedMouseEvents && e8.button === 0)
          triggerPressUp(e8, state.pointerType || "mouse");
      };
      let onMouseUp = (e8) => {
        if (e8.button !== 0)
          return;
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }
        if (state.target && state.target.contains(e8.target) && state.pointerType != null)
          ;
        else
          cancel(e8);
        state.isOverTarget = false;
      };
      pressProps2.onTouchStart = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e8.nativeEvent);
        if (!touch)
          return;
        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e8.currentTarget;
        state.pointerType = "touch";
        if (!allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
        let shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType);
        if (shouldStopPropagation)
          e8.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e8.currentTarget), "scroll", onScroll, true);
      };
      pressProps2.onTouchMove = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (!state.isPressed) {
          e8.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e8.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e8.currentTarget)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType);
          }
        } else if (state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType, false);
          cancelOnPointerExit($f6c31cce2adf654f$var$createTouchEvent(state.target, e8));
        }
        if (shouldStopPropagation)
          e8.stopPropagation();
      };
      pressProps2.onTouchEnd = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        if (!state.isPressed) {
          e8.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e8.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e8.currentTarget) && state.pointerType != null) {
          triggerPressUp($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType);
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType);
        } else if (state.isOverTarget && state.pointerType != null)
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e8), state.pointerType, false);
        if (shouldStopPropagation)
          e8.stopPropagation();
        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        if (state.target && !allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        removeAllGlobalListeners();
      };
      pressProps2.onTouchCancel = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        e8.stopPropagation();
        if (state.isPressed)
          cancel($f6c31cce2adf654f$var$createTouchEvent(state.target, e8));
      };
      let onScroll = (e8) => {
        if (state.isPressed && (0, $d4ee10de306f2510$export$4282f70798064fe0)((0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8), state.target))
          cancel({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false,
            altKey: false
          });
      };
      pressProps2.onDragStart = (e8) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(e8.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)))
          return;
        cancel(e8);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled2,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp
  ]);
  (0, import_react25.useEffect)(() => {
    let state = ref.current;
    return () => {
      var _state_target;
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : void 0);
      for (let dispose of state.disposables)
        dispose();
      state.disposables = [];
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, pressProps)
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key, code } = event;
  const element = currentTarget;
  const role = element.getAttribute("role");
  return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$getTouchFromEvent(event) {
  const { targetTouches } = event;
  if (targetTouches.length > 0)
    return targetTouches[0];
  return null;
}
function $f6c31cce2adf654f$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;
  for (let i15 = 0; i15 < changedTouches.length; i15++) {
    const touch = changedTouches[i15];
    if (touch.identifier === pointerId)
      return touch;
  }
  return null;
}
function $f6c31cce2adf654f$var$createTouchEvent(target, e8) {
  let clientX = 0;
  let clientY = 0;
  if (e8.targetTouches && e8.targetTouches.length === 1) {
    clientX = e8.targetTouches[0].clientX;
    clientY = e8.targetTouches[0].clientY;
  }
  return {
    currentTarget: target,
    shiftKey: e8.shiftKey,
    ctrlKey: e8.ctrlKey,
    metaKey: e8.metaKey,
    altKey: e8.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$createEvent(target, e8) {
  let clientX = e8.clientX;
  let clientY = e8.clientY;
  return {
    currentTarget: target,
    shiftKey: e8.shiftKey,
    ctrlKey: e8.ctrlKey,
    metaKey: e8.metaKey,
    altKey: e8.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$getPointClientRect(point) {
  let offsetX = 0;
  let offsetY = 0;
  if (point.width !== void 0)
    offsetX = point.width / 2;
  else if (point.radiusX !== void 0)
    offsetX = point.radiusX;
  if (point.height !== void 0)
    offsetY = point.height / 2;
  else if (point.radiusY !== void 0)
    offsetY = point.radiusY;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function $f6c31cce2adf654f$var$areRectanglesOverlapping(a20, b9) {
  if (a20.left > b9.right || b9.left > a20.right)
    return false;
  if (a20.top > b9.bottom || b9.top > a20.bottom)
    return false;
  return true;
}
function $f6c31cce2adf654f$var$isOverTarget(point, target) {
  let rect = target.getBoundingClientRect();
  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);
  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);
}
function $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {
  if (target instanceof HTMLInputElement)
    return false;
  if (target instanceof HTMLButtonElement)
    return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target))
    return false;
  return true;
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement)
    return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);
}
var $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
  return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}

// ../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs
var import_react26 = __toESM(require_react(), 1);
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e8) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers)
    handler(modality, e8);
}
function $507fabe10e71c6fb$var$isValidKey(e8) {
  return !(e8.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e8.altKey || e8.ctrlKey || e8.key === "Control" || e8.key === "Shift" || e8.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e8) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e8)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e8);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e8) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e8.type === "mousedown" || e8.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e8);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e8) {
  if ((0, $6a7db85432448f7f$export$60278871457622de)(e8)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e8) {
  if (e8.target === window || e8.target === document || (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) || !e8.isTrusted)
    return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e8);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  if (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48)
    return;
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element)))
    return;
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
  let focus2 = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus2.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus: focus2
  });
}
var $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
  if (loadListener)
    documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject))
    return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
  let loadListener;
  if (documentObject.readyState !== "loading")
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined")
  $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
var $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e8) {
  let document1 = (0, $431fbd86ca7dc216$export$b204af158042fbac)(e8 === null || e8 === void 0 ? void 0 : e8.target);
  const IHTMLInputElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e8 === null || e8 === void 0 ? void 0 : e8.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e8 === null || e8 === void 0 ? void 0 : e8.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e8 === null || e8 === void 0 ? void 0 : e8.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e8 === null || e8 === void 0 ? void 0 : e8.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e8 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e8.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  (0, import_react26.useEffect)(() => {
    let handler = (modality, e8) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e8))
        return;
      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}

// ../../node_modules/@react-aria/interactions/dist/focusSafely.mjs
function $3ad3f6e1647bc98d$export$80f3e147d781571c(element) {
  const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
  const activeElement2 = (0, $d4ee10de306f2510$export$cd4e5573fbe2b576)(ownerDocument);
  if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "virtual") {
    let lastFocusedElement = activeElement2;
    (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
      if ((0, $d4ee10de306f2510$export$cd4e5573fbe2b576)(ownerDocument) === lastFocusedElement && element.isConnected)
        (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element);
    });
  } else
    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element);
}

// ../../node_modules/@react-aria/interactions/dist/useFocus.mjs
var import_react27 = __toESM(require_react(), 1);
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled: isDisabled2, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = (0, import_react27.useCallback)((e8) => {
    if (e8.target === e8.currentTarget) {
      if (onBlurProp)
        onBlurProp(e8);
      if (onFocusChange)
        onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  const onFocus = (0, import_react27.useCallback)((e8) => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.target);
    const activeElement2 = ownerDocument ? (0, $d4ee10de306f2510$export$cd4e5573fbe2b576)(ownerDocument) : (0, $d4ee10de306f2510$export$cd4e5573fbe2b576)();
    if (e8.target === e8.currentTarget && activeElement2 === (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)) {
      if (onFocusProp)
        onFocusProp(e8);
      if (onFocusChange)
        onFocusChange(true);
      onSyntheticFocus(e8);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled2 && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled2 && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}

// ../../node_modules/@react-aria/interactions/dist/createEventHandler.mjs
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler)
    return void 0;
  let shouldStopPropagation = true;
  return (e8) => {
    let event = {
      ...e8,
      preventDefault() {
        e8.preventDefault();
      },
      isDefaultPrevented() {
        return e8.isDefaultPrevented();
      },
      stopPropagation() {
        if (shouldStopPropagation)
          console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
        else
          shouldStopPropagation = true;
      },
      continuePropagation() {
        shouldStopPropagation = false;
      },
      isPropagationStopped() {
        return shouldStopPropagation;
      }
    };
    handler(event);
    if (shouldStopPropagation)
      e8.stopPropagation();
  };
}

// ../../node_modules/@react-aria/interactions/dist/useKeyboard.mjs
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
      onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
    }
  };
}

// ../../node_modules/@react-aria/interactions/dist/useFocusable.mjs
var import_react28 = __toESM(require_react(), 1);
var $f645667febf57a63$export$f9762fab77588ecb = (0, import_react28.default).createContext(null);
function $f645667febf57a63$var$useFocusableContext(ref) {
  let context = (0, import_react28.useContext)($f645667febf57a63$export$f9762fab77588ecb) || {};
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, ref);
  let { ref: _9, ...otherProps } = context;
  return otherProps;
}
var $f645667febf57a63$export$13f3202a3e5ddd5 = (0, import_react28.default).forwardRef(function FocusableProvider(props, ref) {
  let { children, ...otherProps } = props;
  let objRef = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let context = {
    ...otherProps,
    ref: objRef
  };
  return (0, import_react28.default).createElement($f645667febf57a63$export$f9762fab77588ecb.Provider, {
    value: context
  }, children);
});
function $f645667febf57a63$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)(props);
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)(props);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusProps, keyboardProps);
  let domProps = $f645667febf57a63$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = (0, import_react28.useRef)(props.autoFocus);
  (0, import_react28.useEffect)(() => {
    if (autoFocusRef.current && domRef.current)
      (0, $3ad3f6e1647bc98d$export$80f3e147d781571c)(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  let tabIndex = props.excludeFromTabOrder ? -1 : 0;
  if (props.isDisabled)
    tabIndex = void 0;
  return {
    focusableProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)({
      ...interactions,
      tabIndex
    }, interactionProps)
  };
}
var $f645667febf57a63$export$35a3bebf7ef2d934 = (0, import_react28.forwardRef)(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let { focusableProps } = $f645667febf57a63$export$4c014de7c8940b4c(props, ref);
  let child = (0, import_react28.default).Children.only(children);
  (0, import_react28.useEffect)(() => {
    let el = ref.current;
    if (!el || !(el instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(el).Element)) {
      console.error("<Focusable> child must forward its ref to a DOM element.");
      return;
    }
    if (!props.isDisabled && !(0, $b4b717babfbb907b$export$4c063cf1350e6fed)(el)) {
      console.warn("<Focusable> child must be focusable. Please ensure the tabIndex prop is passed through.");
      return;
    }
    if (el.localName !== "button" && el.localName !== "input" && el.localName !== "select" && el.localName !== "textarea" && el.localName !== "a" && el.localName !== "area" && el.localName !== "summary" && el.localName !== "img" && el.localName !== "svg") {
      let role = el.getAttribute("role");
      if (!role)
        console.warn("<Focusable> child must have an interactive ARIA role.");
      else if (
        // https://w3c.github.io/aria/#widget_roles
        role !== "application" && role !== "button" && role !== "checkbox" && role !== "combobox" && role !== "gridcell" && role !== "link" && role !== "menuitem" && role !== "menuitemcheckbox" && role !== "menuitemradio" && role !== "option" && role !== "radio" && role !== "searchbox" && role !== "separator" && role !== "slider" && role !== "spinbutton" && role !== "switch" && role !== "tab" && role !== "tabpanel" && role !== "textbox" && role !== "treeitem" && // aria-describedby is also announced on these roles
        role !== "img" && role !== "meter" && role !== "progressbar"
      )
        console.warn(`<Focusable> child must have an interactive ARIA role. Got "${role}".`);
    }
  }, [
    ref,
    props.isDisabled
  ]);
  let childRef = parseInt((0, import_react28.default).version, 10) < 19 ? child.ref : child.props.ref;
  return (0, import_react28.default).cloneElement(child, {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, child.props),
    // @ts-ignore
    ref: (0, $5dc95899b306f630$export$c9058316764c140e)(childRef, ref)
  });
});

// ../../node_modules/@react-aria/interactions/dist/Pressable.mjs
var import_react29 = __toESM(require_react(), 1);
var $3b117e43dc0ca95d$export$27c701ed9e449e99 = (0, import_react29.default).forwardRef(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    ...props,
    ref
  });
  let { focusableProps } = (0, $f645667febf57a63$export$4c014de7c8940b4c)(props, ref);
  let child = (0, import_react29.default).Children.only(children);
  (0, import_react29.useEffect)(() => {
    let el = ref.current;
    if (!el || !(el instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(el).Element)) {
      console.error("<Pressable> child must forward its ref to a DOM element.");
      return;
    }
    if (!(0, $b4b717babfbb907b$export$4c063cf1350e6fed)(el)) {
      console.warn("<Pressable> child must be focusable. Please ensure the tabIndex prop is passed through.");
      return;
    }
    if (el.localName !== "button" && el.localName !== "input" && el.localName !== "select" && el.localName !== "textarea" && el.localName !== "a" && el.localName !== "area" && el.localName !== "summary") {
      let role = el.getAttribute("role");
      if (!role)
        console.warn("<Pressable> child must have an interactive ARIA role.");
      else if (
        // https://w3c.github.io/aria/#widget_roles
        role !== "application" && role !== "button" && role !== "checkbox" && role !== "combobox" && role !== "gridcell" && role !== "link" && role !== "menuitem" && role !== "menuitemcheckbox" && role !== "menuitemradio" && role !== "option" && role !== "radio" && role !== "searchbox" && role !== "separator" && role !== "slider" && role !== "spinbutton" && role !== "switch" && role !== "tab" && role !== "textbox" && role !== "treeitem"
      )
        console.warn(`<Pressable> child must have an interactive ARIA role. Got "${role}".`);
    }
  }, [
    ref
  ]);
  let childRef = parseInt((0, import_react29.default).version, 10) < 19 ? child.ref : child.props.ref;
  return (0, import_react29.default).cloneElement(child, {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps, child.props),
    // @ts-ignore
    ref: (0, $5dc95899b306f630$export$c9058316764c140e)(childRef, ref)
  });
});

// ../../node_modules/@react-aria/interactions/dist/PressResponder.mjs
var import_react30 = __toESM(require_react(), 1);
var $f1ab8c75478c6f73$export$3351871ee4b288b8 = (0, import_react30.default).forwardRef(({ children, ...props }, ref) => {
  let isRegistered = (0, import_react30.useRef)(false);
  let prevContext = (0, import_react30.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
  let context = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(prevContext || {}, {
    ...props,
    ref,
    register() {
      isRegistered.current = true;
      if (prevContext)
        prevContext.register();
    }
  });
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(prevContext, ref);
  (0, import_react30.useEffect)(() => {
    if (!isRegistered.current) {
      console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
      isRegistered.current = true;
    }
  }, []);
  return (0, import_react30.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
});

// ../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs
var import_react31 = __toESM(require_react(), 1);
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled: isDisabled2, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = (0, import_react31.useRef)({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let onBlur = (0, import_react31.useCallback)((e8) => {
    if (!e8.currentTarget.contains(e8.target))
      return;
    if (state.current.isFocusWithin && !e8.currentTarget.contains(e8.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin)
        onBlurWithin(e8);
      if (onFocusWithinChange)
        onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  let onFocus = (0, import_react31.useCallback)((e8) => {
    if (!e8.currentTarget.contains(e8.target))
      return;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(e8.target);
    const activeElement2 = (0, $d4ee10de306f2510$export$cd4e5573fbe2b576)(ownerDocument);
    if (!state.current.isFocusWithin && activeElement2 === (0, $d4ee10de306f2510$export$e58f029f0fbfdb29)(e8.nativeEvent)) {
      if (onFocusWithin)
        onFocusWithin(e8);
      if (onFocusWithinChange)
        onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e8);
      let currentTarget = e8.currentTarget;
      addGlobalListener(ownerDocument, "focus", (e9) => {
        if (state.current.isFocusWithin && !(0, $d4ee10de306f2510$export$4282f70798064fe0)(currentTarget, e9.target)) {
          let event = new (0, $8a9cb279dc87e130$export$905e7fc544a71f36)("blur", new ownerDocument.defaultView.FocusEvent("blur", {
            relatedTarget: e9.target
          }));
          event.target = currentTarget;
          event.currentTarget = currentTarget;
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled2)
    return {
      focusWithinProps: {
        // These cannot be null, that would conflict in mergeProps
        onFocus: void 0,
        onBlur: void 0
      }
    };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}

// ../../node_modules/@react-aria/interactions/dist/useHover.mjs
var import_react32 = __toESM(require_react(), 1);
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e8) {
  if (e8.pointerType === "touch")
    $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined")
    return;
  if (typeof PointerEvent !== "undefined")
    document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  else
    document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0)
      return;
    if (typeof PointerEvent !== "undefined")
      document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else
      document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled: isDisabled2 } = props;
  let [isHovered, setHovered] = (0, import_react32.useState)(false);
  let state = (0, import_react32.useRef)({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  (0, import_react32.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let { hoverProps, triggerHoverEnd } = (0, import_react32.useMemo)(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled2 || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target))
        return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(event.target), "pointerover", (e8) => {
        if (state.isHovered && state.target && !(0, $d4ee10de306f2510$export$4282f70798064fe0)(state.target, e8.target))
          triggerHoverEnd2(e8, e8.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart)
        onHoverStart({
          type: "hoverstart",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target)
        return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd)
        onHoverEnd({
          type: "hoverend",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e8) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e8.pointerType === "mouse")
          return;
        triggerHoverStart(e8, e8.pointerType);
      };
      hoverProps2.onPointerLeave = (e8) => {
        if (!isDisabled2 && e8.currentTarget.contains(e8.target))
          triggerHoverEnd2(e8, e8.pointerType);
      };
    } else {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e8) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents)
          triggerHoverStart(e8, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e8) => {
        if (!isDisabled2 && e8.currentTarget.contains(e8.target))
          triggerHoverEnd2(e8, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled2,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  (0, import_react32.useEffect)(() => {
    if (isDisabled2)
      triggerHoverEnd({
        currentTarget: state.target
      }, state.pointerType);
  }, [
    isDisabled2
  ]);
  return {
    hoverProps,
    isHovered
  };
}

// ../../node_modules/@react-aria/interactions/dist/useInteractOutside.mjs
var import_react33 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/interactions/dist/useMove.mjs
var import_react34 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/interactions/dist/useScrollWheel.mjs
var import_react35 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/interactions/dist/useLongPress.mjs
var import_react36 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/focus/dist/FocusScope.mjs
var import_react37 = __toESM(require_react(), 1);
var $9bf71ea28793e738$var$FocusContext = (0, import_react37.default).createContext(null);
function $9bf71ea28793e738$var$isElementInScope(element, scope) {
  if (!element)
    return false;
  if (!scope)
    return false;
  return scope.some((node) => node.contains(element));
}
var $9bf71ea28793e738$var$Tree = class _$9bf71ea28793e738$var$Tree {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(data) {
    return this.fastMap.get(data);
  }
  addTreeNode(scopeRef, parent, nodeToRestore) {
    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
    if (!parentNode)
      return;
    let node = new $9bf71ea28793e738$var$TreeNode({
      scopeRef
    });
    parentNode.addChild(node);
    node.parent = parentNode;
    this.fastMap.set(scopeRef, node);
    if (nodeToRestore)
      node.nodeToRestore = nodeToRestore;
  }
  addNode(node) {
    this.fastMap.set(node.scopeRef, node);
  }
  removeTreeNode(scopeRef) {
    if (scopeRef === null)
      return;
    let node = this.fastMap.get(scopeRef);
    if (!node)
      return;
    let parentNode = node.parent;
    for (let current of this.traverse())
      if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current))
        current.nodeToRestore = node.nodeToRestore;
    let children = node.children;
    if (parentNode) {
      parentNode.removeChild(node);
      if (children.size > 0)
        children.forEach((child) => parentNode && parentNode.addChild(child));
    }
    this.fastMap.delete(node.scopeRef);
  }
  // Pre Order Depth First
  *traverse(node = this.root) {
    if (node.scopeRef != null)
      yield node;
    if (node.children.size > 0)
      for (let child of node.children)
        yield* this.traverse(child);
  }
  clone() {
    var _node_parent;
    let newTree = new _$9bf71ea28793e738$var$Tree();
    var _node_parent_scopeRef;
    for (let node of this.traverse())
      newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);
    return newTree;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map();
    this.root = new $9bf71ea28793e738$var$TreeNode({
      scopeRef: null
    });
    this.fastMap.set(null, this.root);
  }
};
var $9bf71ea28793e738$var$TreeNode = class {
  addChild(node) {
    this.children.add(node);
    node.parent = this;
  }
  removeChild(node) {
    this.children.delete(node);
    node.parent = void 0;
  }
  constructor(props) {
    this.children = /* @__PURE__ */ new Set();
    this.contain = false;
    this.scopeRef = props.scopeRef;
  }
};
var $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();

// ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs
var import_react38 = __toESM(require_react(), 1);
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = (0, import_react38.useRef)({
    isFocused: false,
    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
  });
  let [isFocused, setFocused] = (0, import_react38.useState)(false);
  let [isFocusVisibleState, setFocusVisible] = (0, import_react38.useState)(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = (0, import_react38.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = (0, import_react38.useCallback)((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}

// ../../node_modules/@react-aria/focus/dist/FocusRing.mjs
var import_react39 = __toESM(require_react(), 1);

// ../../node_modules/@react-aria/focus/dist/useHasTabbableChild.mjs
var import_react40 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/components/button/button.js
var import_react48 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
var import_react45 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t11, e8, n13) => e8 in t11 ? i(t11, e8, { enumerable: true, configurable: true, writable: true, value: n13 }) : t11[e8] = n13;
var r2 = (t11, e8, n13) => (d(t11, typeof e8 != "symbol" ? e8 + "" : e8, n13), n13);
var o = class {
  constructor() {
    r2(this, "current", this.detect());
    r2(this, "handoffState", "pending");
    r2(this, "currentId", 0);
  }
  set(e8) {
    this.current !== e8 && (this.handoffState = "pending", this.currentId = 0, this.current = e8);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// ../../node_modules/@headlessui/react/dist/utils/owner.js
function u(r18) {
  return s.isServer ? null : r18 instanceof Node ? r18.ownerDocument : r18 != null && r18.hasOwnProperty("current") && r18.current instanceof Node ? r18.current.ownerDocument : document;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react41 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/micro-task.js
function t(e8) {
  typeof queueMicrotask == "function" ? queueMicrotask(e8) : Promise.resolve().then(e8).catch((o17) => setTimeout(() => {
    throw o17;
  }));
}

// ../../node_modules/@headlessui/react/dist/utils/disposables.js
function o2() {
  let n13 = [], r18 = { addEventListener(e8, t11, s13, a20) {
    return e8.addEventListener(t11, s13, a20), r18.add(() => e8.removeEventListener(t11, s13, a20));
  }, requestAnimationFrame(...e8) {
    let t11 = requestAnimationFrame(...e8);
    return r18.add(() => cancelAnimationFrame(t11));
  }, nextFrame(...e8) {
    return r18.requestAnimationFrame(() => r18.requestAnimationFrame(...e8));
  }, setTimeout(...e8) {
    let t11 = setTimeout(...e8);
    return r18.add(() => clearTimeout(t11));
  }, microTask(...e8) {
    let t11 = { current: true };
    return t(() => {
      t11.current && e8[0]();
    }), r18.add(() => {
      t11.current = false;
    });
  }, style(e8, t11, s13) {
    let a20 = e8.style.getPropertyValue(t11);
    return Object.assign(e8.style, { [t11]: s13 }), this.add(() => {
      Object.assign(e8.style, { [t11]: a20 });
    });
  }, group(e8) {
    let t11 = o2();
    return e8(t11), this.add(() => t11.dispose());
  }, add(e8) {
    return n13.includes(e8) || n13.push(e8), () => {
      let t11 = n13.indexOf(e8);
      if (t11 >= 0)
        for (let s13 of n13.splice(t11, 1))
          s13();
    };
  }, dispose() {
    for (let e8 of n13.splice(0))
      e8();
  } };
  return r18;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e8] = (0, import_react41.useState)(o2);
  return (0, import_react41.useEffect)(() => () => e8.dispose(), [e8]), e8;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react44 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react43 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react42 = __toESM(require_react(), 1);
var n = (e8, t11) => {
  s.isServer ? (0, import_react42.useEffect)(e8, t11) : (0, import_react42.useLayoutEffect)(e8, t11);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
function s3(e8) {
  let r18 = (0, import_react43.useRef)(e8);
  return n(() => {
    r18.current = e8;
  }, [e8]), r18;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var o4 = function(t11) {
  let e8 = s3(t11);
  return import_react44.default.useCallback((...r18) => e8.current(...r18), [e8]);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
function E(e8) {
  let t11 = e8.width / 2, n13 = e8.height / 2;
  return { top: e8.clientY - n13, right: e8.clientX + t11, bottom: e8.clientY + n13, left: e8.clientX - t11 };
}
function P(e8, t11) {
  return !(!e8 || !t11 || e8.right < t11.left || e8.left > t11.right || e8.bottom < t11.top || e8.top > t11.bottom);
}
function w({ disabled: e8 = false } = {}) {
  let t11 = (0, import_react45.useRef)(null), [n13, l14] = (0, import_react45.useState)(false), r18 = p(), o17 = o4(() => {
    t11.current = null, l14(false), r18.dispose();
  }), f22 = o4((s13) => {
    if (r18.dispose(), t11.current === null) {
      t11.current = s13.currentTarget, l14(true);
      {
        let i15 = u(s13.currentTarget);
        r18.addEventListener(i15, "pointerup", o17, false), r18.addEventListener(i15, "pointermove", (c15) => {
          if (t11.current) {
            let p6 = E(c15);
            l14(P(p6, t11.current.getBoundingClientRect()));
          }
        }, false), r18.addEventListener(i15, "pointercancel", o17, false);
      }
    }
  });
  return { pressed: n13, pressProps: e8 ? {} : { onPointerDown: f22, onPointerUp: o17, onClick: o17 } };
}

// ../../node_modules/@headlessui/react/dist/internal/disabled.js
var import_react46 = __toESM(require_react(), 1);
var e = (0, import_react46.createContext)(void 0);
function a3() {
  return (0, import_react46.useContext)(e);
}
function l({ value: t11, children: o17 }) {
  return import_react46.default.createElement(e.Provider, { value: t11 }, o17);
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var import_react47 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/class-names.js
function t3(...r18) {
  return Array.from(new Set(r18.flatMap((n13) => typeof n13 == "string" ? n13.split(" ") : []))).filter(Boolean).join(" ");
}

// ../../node_modules/@headlessui/react/dist/utils/match.js
function u2(r18, n13, ...a20) {
  if (r18 in n13) {
    let e8 = n13[r18];
    return typeof e8 == "function" ? e8(...a20) : e8;
  }
  let t11 = new Error(`Tried to handle "${r18}" but there is no handler defined. Only defined handlers are: ${Object.keys(n13).map((e8) => `"${e8}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t11, u2), t11;
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var O = ((a20) => (a20[a20.None = 0] = "None", a20[a20.RenderStrategy = 1] = "RenderStrategy", a20[a20.Static = 2] = "Static", a20))(O || {});
var A = ((e8) => (e8[e8.Unmount = 0] = "Unmount", e8[e8.Hidden = 1] = "Hidden", e8))(A || {});
function L() {
  let n13 = U();
  return (0, import_react47.useCallback)((r18) => C({ mergeRefs: n13, ...r18 }), [n13]);
}
function C({ ourProps: n13, theirProps: r18, slot: e8, defaultTag: a20, features: s13, visible: t11 = true, name: l14, mergeRefs: i15 }) {
  i15 = i15 != null ? i15 : $;
  let o17 = P2(r18, n13);
  if (t11)
    return F(o17, e8, a20, l14, i15);
  let y9 = s13 != null ? s13 : 0;
  if (y9 & 2) {
    let { static: f22 = false, ...u17 } = o17;
    if (f22)
      return F(u17, e8, a20, l14, i15);
  }
  if (y9 & 1) {
    let { unmount: f22 = true, ...u17 } = o17;
    return u2(f22 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return F({ ...u17, hidden: true, style: { display: "none" } }, e8, a20, l14, i15);
    } });
  }
  return F(o17, e8, a20, l14, i15);
}
function F(n13, r18 = {}, e8, a20, s13) {
  let { as: t11 = e8, children: l14, refName: i15 = "ref", ...o17 } = h(n13, ["unmount", "static"]), y9 = n13.ref !== void 0 ? { [i15]: n13.ref } : {}, f22 = typeof l14 == "function" ? l14(r18) : l14;
  "className" in o17 && o17.className && typeof o17.className == "function" && (o17.className = o17.className(r18)), o17["aria-labelledby"] && o17["aria-labelledby"] === o17.id && (o17["aria-labelledby"] = void 0);
  let u17 = {};
  if (r18) {
    let d13 = false, p6 = [];
    for (let [c15, T10] of Object.entries(r18))
      typeof T10 == "boolean" && (d13 = true), T10 === true && p6.push(c15.replace(/([A-Z])/g, (g6) => `-${g6.toLowerCase()}`));
    if (d13) {
      u17["data-headlessui-state"] = p6.join(" ");
      for (let c15 of p6)
        u17[`data-${c15}`] = "";
    }
  }
  if (t11 === import_react47.Fragment && (Object.keys(m2(o17)).length > 0 || Object.keys(m2(u17)).length > 0))
    if (!(0, import_react47.isValidElement)(f22) || Array.isArray(f22) && f22.length > 1) {
      if (Object.keys(m2(o17)).length > 0)
        throw new Error(['Passing props on "Fragment"!', "", `The current component <${a20} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m2(o17)).concat(Object.keys(m2(u17))).map((d13) => `  - ${d13}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d13) => `  - ${d13}`).join(`
`)].join(`
`));
    } else {
      let d13 = f22.props, p6 = d13 == null ? void 0 : d13.className, c15 = typeof p6 == "function" ? (...R9) => t3(p6(...R9), o17.className) : t3(p6, o17.className), T10 = c15 ? { className: c15 } : {}, g6 = P2(f22.props, m2(h(o17, ["ref"])));
      for (let R9 in u17)
        R9 in g6 && delete u17[R9];
      return (0, import_react47.cloneElement)(f22, Object.assign({}, g6, u17, y9, { ref: s13(H(f22), y9.ref) }, T10));
    }
  return (0, import_react47.createElement)(t11, Object.assign({}, h(o17, ["ref"]), t11 !== import_react47.Fragment && y9, t11 !== import_react47.Fragment && u17), f22);
}
function U() {
  let n13 = (0, import_react47.useRef)([]), r18 = (0, import_react47.useCallback)((e8) => {
    for (let a20 of n13.current)
      a20 != null && (typeof a20 == "function" ? a20(e8) : a20.current = e8);
  }, []);
  return (...e8) => {
    if (!e8.every((a20) => a20 == null))
      return n13.current = e8, r18;
  };
}
function $(...n13) {
  return n13.every((r18) => r18 == null) ? void 0 : (r18) => {
    for (let e8 of n13)
      e8 != null && (typeof e8 == "function" ? e8(r18) : e8.current = r18);
  };
}
function P2(...n13) {
  var a20;
  if (n13.length === 0)
    return {};
  if (n13.length === 1)
    return n13[0];
  let r18 = {}, e8 = {};
  for (let s13 of n13)
    for (let t11 in s13)
      t11.startsWith("on") && typeof s13[t11] == "function" ? ((a20 = e8[t11]) != null || (e8[t11] = []), e8[t11].push(s13[t11])) : r18[t11] = s13[t11];
  if (r18.disabled || r18["aria-disabled"])
    for (let s13 in e8)
      /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s13) && (e8[s13] = [(t11) => {
        var l14;
        return (l14 = t11 == null ? void 0 : t11.preventDefault) == null ? void 0 : l14.call(t11);
      }]);
  for (let s13 in e8)
    Object.assign(r18, { [s13](t11, ...l14) {
      let i15 = e8[s13];
      for (let o17 of i15) {
        if ((t11 instanceof Event || (t11 == null ? void 0 : t11.nativeEvent) instanceof Event) && t11.defaultPrevented)
          return;
        o17(t11, ...l14);
      }
    } });
  return r18;
}
function _2(...n13) {
  var a20;
  if (n13.length === 0)
    return {};
  if (n13.length === 1)
    return n13[0];
  let r18 = {}, e8 = {};
  for (let s13 of n13)
    for (let t11 in s13)
      t11.startsWith("on") && typeof s13[t11] == "function" ? ((a20 = e8[t11]) != null || (e8[t11] = []), e8[t11].push(s13[t11])) : r18[t11] = s13[t11];
  for (let s13 in e8)
    Object.assign(r18, { [s13](...t11) {
      let l14 = e8[s13];
      for (let i15 of l14)
        i15 == null || i15(...t11);
    } });
  return r18;
}
function K(n13) {
  var r18;
  return Object.assign((0, import_react47.forwardRef)(n13), { displayName: (r18 = n13.displayName) != null ? r18 : n13.name });
}
function m2(n13) {
  let r18 = Object.assign({}, n13);
  for (let e8 in r18)
    r18[e8] === void 0 && delete r18[e8];
  return r18;
}
function h(n13, r18 = []) {
  let e8 = Object.assign({}, n13);
  for (let a20 of r18)
    a20 in e8 && delete e8[a20];
  return e8;
}
function H(n13) {
  return import_react47.default.version.split(".")[0] >= "19" ? n13.props.ref : n13.ref;
}

// ../../node_modules/@headlessui/react/dist/components/button/button.js
var R = "button";
function v2(a20, u17) {
  var p6;
  let l14 = a3(), { disabled: e8 = l14 || false, autoFocus: t11 = false, ...o17 } = a20, { isFocusVisible: r18, focusProps: i15 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t11 }), { isHovered: s13, hoverProps: T10 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), { pressed: n13, pressProps: d13 } = w({ disabled: e8 }), f22 = _2({ ref: u17, type: (p6 = o17.type) != null ? p6 : "button", disabled: e8 || void 0, autoFocus: t11 }, i15, T10, d13), m10 = (0, import_react48.useMemo)(() => ({ disabled: e8, hover: s13, focus: r18, active: n13, autofocus: t11 }), [e8, s13, r18, n13, t11]);
  return L()({ ourProps: f22, theirProps: o17, slot: m10, defaultTag: R, name: "Button" });
}
var H2 = K(v2);

// ../../node_modules/@headlessui/react/dist/components/checkbox/checkbox.js
var import_react57 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-controllable.js
var import_react49 = __toESM(require_react(), 1);
function T(l14, r18, c15) {
  let [i15, s13] = (0, import_react49.useState)(c15), e8 = l14 !== void 0, t11 = (0, import_react49.useRef)(e8), u17 = (0, import_react49.useRef)(false), d13 = (0, import_react49.useRef)(false);
  return e8 && !t11.current && !u17.current ? (u17.current = true, t11.current = e8, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e8 && t11.current && !d13.current && (d13.current = true, t11.current = e8, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e8 ? l14 : i15, o4((n13) => (e8 || s13(n13), r18 == null ? void 0 : r18(n13)))];
}

// ../../node_modules/@headlessui/react/dist/hooks/use-default-value.js
var import_react50 = __toESM(require_react(), 1);
function l2(e8) {
  let [t11] = (0, import_react50.useState)(e8);
  return t11;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react51 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/internal/form-fields.js
var import_react52 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);

// ../../node_modules/@headlessui/react/dist/utils/form.js
function e2(i15 = {}, s13 = null, t11 = []) {
  for (let [r18, n13] of Object.entries(i15))
    o6(t11, f3(s13, r18), n13);
  return t11;
}
function f3(i15, s13) {
  return i15 ? i15 + "[" + s13 + "]" : s13;
}
function o6(i15, s13, t11) {
  if (Array.isArray(t11))
    for (let [r18, n13] of t11.entries())
      o6(i15, f3(s13, r18.toString()), n13);
  else
    t11 instanceof Date ? i15.push([s13, t11.toISOString()]) : typeof t11 == "boolean" ? i15.push([s13, t11 ? "1" : "0"]) : typeof t11 == "string" ? i15.push([s13, t11]) : typeof t11 == "number" ? i15.push([s13, `${t11}`]) : t11 == null ? i15.push([s13, ""]) : e2(t11, s13, i15);
}
function p2(i15) {
  var t11, r18;
  let s13 = (t11 = i15 == null ? void 0 : i15.form) != null ? t11 : i15.closest("form");
  if (s13) {
    for (let n13 of s13.elements)
      if (n13 !== i15 && (n13.tagName === "INPUT" && n13.type === "submit" || n13.tagName === "BUTTON" && n13.type === "submit" || n13.nodeName === "INPUT" && n13.type === "image")) {
        n13.click();
        return;
      }
    (r18 = s13.requestSubmit) == null || r18.call(s13);
  }
}

// ../../node_modules/@headlessui/react/dist/internal/hidden.js
var a4 = "span";
var s4 = ((e8) => (e8[e8.None = 1] = "None", e8[e8.Focusable = 2] = "Focusable", e8[e8.Hidden = 4] = "Hidden", e8))(s4 || {});
function l3(t11, r18) {
  var n13;
  let { features: d13 = 1, ...e8 } = t11, o17 = { ref: r18, "aria-hidden": (d13 & 2) === 2 ? true : (n13 = e8["aria-hidden"]) != null ? n13 : void 0, hidden: (d13 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(d13 & 4) === 4 && (d13 & 2) !== 2 && { display: "none" } } };
  return L()({ ourProps: o17, theirProps: e8, slot: {}, defaultTag: a4, name: "Hidden" });
}
var f4 = K(l3);

// ../../node_modules/@headlessui/react/dist/internal/form-fields.js
var f5 = (0, import_react52.createContext)(null);
function W(t11) {
  let [e8, r18] = (0, import_react52.useState)(null);
  return import_react52.default.createElement(f5.Provider, { value: { target: e8 } }, t11.children, import_react52.default.createElement(f4, { features: s4.Hidden, ref: r18 }));
}
function c2({ children: t11 }) {
  let e8 = (0, import_react52.useContext)(f5);
  if (!e8)
    return import_react52.default.createElement(import_react52.default.Fragment, null, t11);
  let { target: r18 } = e8;
  return r18 ? (0, import_react_dom3.createPortal)(import_react52.default.createElement(import_react52.default.Fragment, null, t11), r18) : null;
}
function j2({ data: t11, form: e8, disabled: r18, onReset: n13, overrides: F6 }) {
  let [i15, a20] = (0, import_react52.useState)(null), p6 = p();
  return (0, import_react52.useEffect)(() => {
    if (n13 && i15)
      return p6.addEventListener(i15, "reset", n13);
  }, [i15, e8, n13]), import_react52.default.createElement(c2, null, import_react52.default.createElement(C2, { setForm: a20, formId: e8 }), e2(t11).map(([s13, v4]) => import_react52.default.createElement(f4, { features: s4.Hidden, ...m2({ key: s13, as: "input", type: "hidden", hidden: true, readOnly: true, form: e8, disabled: r18, name: s13, value: v4, ...F6 }) })));
}
function C2({ setForm: t11, formId: e8 }) {
  return (0, import_react52.useEffect)(() => {
    if (e8) {
      let r18 = document.getElementById(e8);
      r18 && t11(r18);
    }
  }, [t11, e8]), e8 ? null : import_react52.default.createElement(f4, { features: s4.Hidden, as: "input", type: "hidden", hidden: true, readOnly: true, ref: (r18) => {
    if (!r18)
      return;
    let n13 = r18.closest("form");
    n13 && t11(n13);
  } });
}

// ../../node_modules/@headlessui/react/dist/internal/id.js
var import_react53 = __toESM(require_react(), 1);
var e3 = (0, import_react53.createContext)(void 0);
function u5() {
  return (0, import_react53.useContext)(e3);
}
function f6({ id: t11, children: r18 }) {
  return import_react53.default.createElement(e3.Provider, { value: t11 }, r18);
}

// ../../node_modules/@headlessui/react/dist/utils/bugs.js
function r5(n13) {
  let e8 = n13.parentElement, l14 = null;
  for (; e8 && !(e8 instanceof HTMLFieldSetElement); )
    e8 instanceof HTMLLegendElement && (l14 = e8), e8 = e8.parentElement;
  let t11 = (e8 == null ? void 0 : e8.getAttribute("disabled")) === "";
  return t11 && i4(l14) ? false : t11;
}
function i4(n13) {
  if (!n13)
    return false;
  let e8 = n13.previousElementSibling;
  for (; e8 !== null; ) {
    if (e8 instanceof HTMLLegendElement)
      return false;
    e8 = e8.previousElementSibling;
  }
  return true;
}

// ../../node_modules/@headlessui/react/dist/components/description/description.js
var import_react55 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react54 = __toESM(require_react(), 1);
var u6 = Symbol();
function T2(t11, n13 = true) {
  return Object.assign(t11, { [u6]: n13 });
}
function y(...t11) {
  let n13 = (0, import_react54.useRef)(t11);
  (0, import_react54.useEffect)(() => {
    n13.current = t11;
  }, [t11]);
  let c15 = o4((e8) => {
    for (let o17 of n13.current)
      o17 != null && (typeof o17 == "function" ? o17(e8) : o17.current = e8);
  });
  return t11.every((e8) => e8 == null || (e8 == null ? void 0 : e8[u6])) ? void 0 : c15;
}

// ../../node_modules/@headlessui/react/dist/components/description/description.js
var a5 = (0, import_react55.createContext)(null);
a5.displayName = "DescriptionContext";
function f7() {
  let r18 = (0, import_react55.useContext)(a5);
  if (r18 === null) {
    let e8 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e8, f7), e8;
  }
  return r18;
}
function U2() {
  var r18, e8;
  return (e8 = (r18 = (0, import_react55.useContext)(a5)) == null ? void 0 : r18.value) != null ? e8 : void 0;
}
function w3() {
  let [r18, e8] = (0, import_react55.useState)([]);
  return [r18.length > 0 ? r18.join(" ") : void 0, (0, import_react55.useMemo)(() => function(t11) {
    let i15 = o4((n13) => (e8((s13) => [...s13, n13]), () => e8((s13) => {
      let o17 = s13.slice(), p6 = o17.indexOf(n13);
      return p6 !== -1 && o17.splice(p6, 1), o17;
    }))), l14 = (0, import_react55.useMemo)(() => ({ register: i15, slot: t11.slot, name: t11.name, props: t11.props, value: t11.value }), [i15, t11.slot, t11.name, t11.props, t11.value]);
    return import_react55.default.createElement(a5.Provider, { value: l14 }, t11.children);
  }, [e8])];
}
var S2 = "p";
function C3(r18, e8) {
  let d13 = (0, import_react51.useId)(), t11 = a3(), { id: i15 = `headlessui-description-${d13}`, ...l14 } = r18, n13 = f7(), s13 = y(e8);
  n(() => n13.register(i15), [i15, n13.register]);
  let o17 = t11 || false, p6 = (0, import_react55.useMemo)(() => ({ ...n13.slot, disabled: o17 }), [n13.slot, o17]), D7 = { ref: s13, ...n13.props, id: i15 };
  return L()({ ourProps: D7, theirProps: l14, slot: p6, defaultTag: S2, name: n13.name || "Description" });
}
var _3 = K(C3);
var H4 = Object.assign(_3, {});

// ../../node_modules/@headlessui/react/dist/components/keyboard.js
var o8 = ((r18) => (r18.Space = " ", r18.Enter = "Enter", r18.Escape = "Escape", r18.Backspace = "Backspace", r18.Delete = "Delete", r18.ArrowLeft = "ArrowLeft", r18.ArrowUp = "ArrowUp", r18.ArrowRight = "ArrowRight", r18.ArrowDown = "ArrowDown", r18.Home = "Home", r18.End = "End", r18.PageUp = "PageUp", r18.PageDown = "PageDown", r18.Tab = "Tab", r18))(o8 || {});

// ../../node_modules/@headlessui/react/dist/components/label/label.js
var import_react56 = __toESM(require_react(), 1);
var c4 = (0, import_react56.createContext)(null);
c4.displayName = "LabelContext";
function P5() {
  let r18 = (0, import_react56.useContext)(c4);
  if (r18 === null) {
    let l14 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l14, P5), l14;
  }
  return r18;
}
function I(r18) {
  var a20, e8, o17;
  let l14 = (e8 = (a20 = (0, import_react56.useContext)(c4)) == null ? void 0 : a20.value) != null ? e8 : void 0;
  return ((o17 = r18 == null ? void 0 : r18.length) != null ? o17 : 0) > 0 ? [l14, ...r18].filter(Boolean).join(" ") : l14;
}
function K2({ inherit: r18 = false } = {}) {
  let l14 = I(), [a20, e8] = (0, import_react56.useState)([]), o17 = r18 ? [l14, ...a20].filter(Boolean) : a20;
  return [o17.length > 0 ? o17.join(" ") : void 0, (0, import_react56.useMemo)(() => function(t11) {
    let s13 = o4((i15) => (e8((p6) => [...p6, i15]), () => e8((p6) => {
      let u17 = p6.slice(), d13 = u17.indexOf(i15);
      return d13 !== -1 && u17.splice(d13, 1), u17;
    }))), m10 = (0, import_react56.useMemo)(() => ({ register: s13, slot: t11.slot, name: t11.name, props: t11.props, value: t11.value }), [s13, t11.slot, t11.name, t11.props, t11.value]);
    return import_react56.default.createElement(c4.Provider, { value: m10 }, t11.children);
  }, [e8])];
}
var N = "label";
function G(r18, l14) {
  var y9;
  let a20 = (0, import_react51.useId)(), e8 = P5(), o17 = u5(), g6 = a3(), { id: t11 = `headlessui-label-${a20}`, htmlFor: s13 = o17 != null ? o17 : (y9 = e8.props) == null ? void 0 : y9.htmlFor, passive: m10 = false, ...i15 } = r18, p6 = y(l14);
  n(() => e8.register(t11), [t11, e8.register]);
  let u17 = o4((L6) => {
    let b9 = L6.currentTarget;
    if (b9 instanceof HTMLLabelElement && L6.preventDefault(), e8.props && "onClick" in e8.props && typeof e8.props.onClick == "function" && e8.props.onClick(L6), b9 instanceof HTMLLabelElement) {
      let n13 = document.getElementById(b9.htmlFor);
      if (n13) {
        let E12 = n13.getAttribute("disabled");
        if (E12 === "true" || E12 === "")
          return;
        let x10 = n13.getAttribute("aria-disabled");
        if (x10 === "true" || x10 === "")
          return;
        (n13 instanceof HTMLInputElement && (n13.type === "radio" || n13.type === "checkbox") || n13.role === "radio" || n13.role === "checkbox" || n13.role === "switch") && n13.click(), n13.focus({ preventScroll: true });
      }
    }
  }), d13 = g6 || false, C9 = (0, import_react56.useMemo)(() => ({ ...e8.slot, disabled: d13 }), [e8.slot, d13]), f22 = { ref: p6, ...e8.props, id: t11, htmlFor: s13, onClick: u17 };
  return m10 && ("onClick" in f22 && (delete f22.htmlFor, delete f22.onClick), "onClick" in i15 && delete i15.onClick), L()({ ourProps: f22, theirProps: i15, slot: C9, defaultTag: s13 ? N : "div", name: e8.name || "Label" });
}
var U3 = K(G);
var Q = Object.assign(U3, {});

// ../../node_modules/@headlessui/react/dist/components/checkbox/checkbox.js
var ie = "span";
function de(T10, h7) {
  let C9 = (0, import_react51.useId)(), k5 = u5(), x10 = a3(), { id: g6 = k5 || `headlessui-checkbox-${C9}`, disabled: e8 = x10 || false, autoFocus: s13 = false, checked: E12, defaultChecked: v4, onChange: P7, name: d13, value: D7, form: R9, indeterminate: n13 = false, ...A7 } = T10, r18 = l2(v4), [a20, t11] = T(E12, P7, r18 != null ? r18 : false), F6 = I(), K4 = U2(), _9 = p(), [p6, c15] = (0, import_react57.useState)(false), u17 = o4(() => {
    c15(true), t11 == null || t11(!a20), _9.nextFrame(() => {
      c15(false);
    });
  }), H13 = o4((o17) => {
    if (r5(o17.currentTarget))
      return o17.preventDefault();
    o17.preventDefault(), u17();
  }), B3 = o4((o17) => {
    o17.key === o8.Space ? (o17.preventDefault(), u17()) : o17.key === o8.Enter && p2(o17.currentTarget);
  }), L6 = o4((o17) => o17.preventDefault()), { isFocusVisible: m10, focusProps: I6 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: s13 }), { isHovered: f22, hoverProps: M9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), { pressed: b9, pressProps: U8 } = w({ disabled: e8 }), O7 = _2({ ref: h7, id: g6, role: "checkbox", "aria-checked": n13 ? "mixed" : a20 ? "true" : "false", "aria-labelledby": F6, "aria-describedby": K4, "aria-disabled": e8 ? true : void 0, indeterminate: n13 ? "true" : void 0, tabIndex: e8 ? void 0 : 0, onKeyUp: e8 ? void 0 : B3, onKeyPress: e8 ? void 0 : L6, onClick: e8 ? void 0 : H13 }, I6, M9, U8), X4 = (0, import_react57.useMemo)(() => ({ checked: a20, disabled: e8, hover: f22, focus: m10, active: b9, indeterminate: n13, changing: p6, autofocus: s13 }), [a20, n13, e8, f22, m10, b9, p6, s13]), G7 = (0, import_react57.useCallback)(() => {
    if (r18 !== void 0)
      return t11 == null ? void 0 : t11(r18);
  }, [t11, r18]), S7 = L();
  return import_react57.default.createElement(import_react57.default.Fragment, null, d13 != null && import_react57.default.createElement(j2, { disabled: e8, data: { [d13]: D7 || "on" }, overrides: { type: "checkbox", checked: a20 }, form: R9, onReset: G7 }), S7({ ourProps: O7, theirProps: A7, slot: X4, defaultTag: ie, name: "Checkbox" }));
}
var Ae = K(de);

// ../../node_modules/@headlessui/react/dist/components/close-button/close-button.js
var import_react59 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/internal/close-provider.js
var import_react58 = __toESM(require_react(), 1);
var e4 = (0, import_react58.createContext)(() => {
});
function u8() {
  return (0, import_react58.useContext)(e4);
}
function C4({ value: t11, children: o17 }) {
  return import_react58.default.createElement(e4.Provider, { value: t11 }, o17);
}

// ../../node_modules/@headlessui/react/dist/components/close-button/close-button.js
function l5(t11, e8) {
  let o17 = u8();
  return import_react59.default.createElement(H2, { ref: e8, ..._2({ onClick: o17 }, t11) });
}
var y2 = K(l5);

// ../../node_modules/@tanstack/react-virtual/dist/esm/index.js
var React = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());

// ../../node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a4, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a4 = opts.debug) == null ? void 0 : _a4.call(opts)))
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index3) => deps[index3] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))
      resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a20, b9) => Math.abs(a20 - b9) < 1;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId2;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId2);
    timeoutId2 = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// ../../node_modules/@tanstack/virtual-core/dist/esm/index.js
var defaultKeyExtractor = (index3) => index3;
var defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i15 = start; i15 <= end; i15++) {
    arr.push(i15);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(element.getBoundingClientRect());
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(element.getBoundingClientRect());
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset4 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset4, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset4 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset4, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size4 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size4;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
var elementScroll = (offset4, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a4, _b;
  const toOffset = offset4 + adjustments;
  (_b = (_a4 = instance.scrollElement) == null ? void 0 : _a4.scrollTo) == null ? void 0 : _b.call(_a4, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a4;
          (_a4 = get()) == null ? void 0 : _a4.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a4;
          return (_a4 = get()) == null ? void 0 : _a4.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a4;
          return (_a4 = get()) == null ? void 0 : _a4.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a4, _b;
      (_b = (_a4 = this.options).onChange) == null ? void 0 : _b.call(_a4, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d13) => d13());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a4;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a4 = this.scrollElement) == null ? void 0 : _a4.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset4, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset4 ? "forward" : "backward" : null;
            this.scrollOffset = offset4;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index3) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m10 = index3 - 1; m10 >= 0; m10--) {
        const measurement = measurements[m10];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a20, b9) => {
        if (a20.end === b9.end) {
          return a20.index - b9.index;
        }
        return a20.end - b9.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count4, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count4,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count4, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i15 = min2; i15 < count4; i15++) {
          const key = getItemKey(i15);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i15 - 1] : this.getFurthestMeasurement(measurements, i15);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size4 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i15);
          const end = start + size4;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i15 % this.options.lanes;
          measurements[i15] = {
            index: i15,
            start,
            size: size4,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count4, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count4
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index3 = this.indexFromElement(node);
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index3, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index3, size4) => {
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size4 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size4));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k5 = 0, len = indexes.length; k5 < len; k5++) {
          const i15 = indexes[k5];
          const measurement = measurements[i15];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset4) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index3) => notUndefined(measurements[index3]).start,
          offset4
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size4 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size4) / 2;
      } else if (align === "end") {
        toOffset -= size4;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - size4;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index3, align = "auto") => {
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      const item = this.measurementsCache[index3];
      if (!item) {
        return void 0;
      }
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size4 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {
        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index3, { align: initialAlign = "auto", behavior } = {}) => {
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const offsetAndAlign = this.getOffsetForIndex(index3, initialAlign);
      if (!offsetAndAlign)
        return;
      const [offset4, align] = offsetAndAlign;
      this._scrollToOffset(offset4, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode() && this.targetWindow) {
        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.elementsCache.has(
            this.options.getItemKey(index3)
          );
          if (elementInDOM) {
            const [latestOffset] = notUndefined(
              this.getOffsetForIndex(index3, align)
            );
            if (!approxEqual(latestOffset, this.getScrollOffset())) {
              this.scrollToIndex(index3, { align, behavior });
            }
          } else {
            this.scrollToIndex(index3, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a4;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a4 = measurements[measurements.length - 1]) == null ? void 0 : _a4.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex > 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset4, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset4, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset2 = (index3) => measurements[index3].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset2,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex > 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// ../../node_modules/@tanstack/react-virtual/dist/esm/index.js
var useIsomorphicLayoutEffect2 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useVirtualizerBase(options) {
  const rerender = React.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a4;
      if (sync) {
        (0, import_react_dom4.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a4 = options.onChange) == null ? void 0 : _a4.call(options, instance2, sync);
    }
  };
  const [instance] = React.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect2(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect2(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}

// ../../node_modules/@headlessui/react/dist/components/combobox/combobox.js
var import_react86 = __toESM(require_react(), 1);
var import_react_dom8 = __toESM(require_react_dom(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js
var import_react60 = __toESM(require_react(), 1);
function l6(e8, r18) {
  return e8 !== null && r18 !== null && typeof e8 == "object" && typeof r18 == "object" && "id" in e8 && "id" in r18 ? e8.id === r18.id : e8 === r18;
}
function u9(e8 = l6) {
  return (0, import_react60.useCallback)((r18, t11) => {
    if (typeof e8 == "string") {
      let o17 = e8;
      return (r18 == null ? void 0 : r18[o17]) === (t11 == null ? void 0 : t11[o17]);
    }
    return e8(r18, t11);
  }, [e8]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-element-size.js
var import_react61 = __toESM(require_react(), 1);
function f8(e8) {
  if (e8 === null)
    return { width: 0, height: 0 };
  let { width: t11, height: r18 } = e8.getBoundingClientRect();
  return { width: t11, height: r18 };
}
function d3(e8, t11 = false) {
  let [r18, u17] = (0, import_react61.useReducer)(() => ({}), {}), i15 = (0, import_react61.useMemo)(() => f8(e8), [e8, r18]);
  return n(() => {
    if (!e8)
      return;
    let n13 = new ResizeObserver(u17);
    return n13.observe(e8), () => {
      n13.disconnect();
    };
  }, [e8]), t11 ? { width: `${i15.width}px`, height: `${i15.height}px` } : i15;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
var import_react63 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/default-map.js
var a6 = class extends Map {
  constructor(t11) {
    super();
    this.factory = t11;
  }
  get(t11) {
    let e8 = super.get(t11);
    return e8 === void 0 && (e8 = this.factory(t11), this.set(t11, e8)), e8;
  }
};

// ../../node_modules/@headlessui/react/dist/utils/store.js
function a7(o17, r18) {
  let t11 = o17(), n13 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t11;
  }, subscribe(e8) {
    return n13.add(e8), () => n13.delete(e8);
  }, dispatch(e8, ...s13) {
    let i15 = r18[e8].call(t11, ...s13);
    i15 && (t11 = i15, n13.forEach((c15) => c15()));
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-store.js
var import_react62 = __toESM(require_react(), 1);
function o10(t11) {
  return (0, import_react62.useSyncExternalStore)(t11.subscribe, t11.getSnapshot, t11.getSnapshot);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
var p3 = new a6(() => a7(() => [], { ADD(r18) {
  return this.includes(r18) ? this : [...this, r18];
}, REMOVE(r18) {
  let e8 = this.indexOf(r18);
  if (e8 === -1)
    return this;
  let t11 = this.slice();
  return t11.splice(e8, 1), t11;
} }));
function x2(r18, e8) {
  let t11 = p3.get(e8), i15 = (0, import_react63.useId)(), h7 = o10(t11);
  if (n(() => {
    if (r18)
      return t11.dispatch("ADD", i15), () => t11.dispatch("REMOVE", i15);
  }, [t11, r18]), !r18)
    return false;
  let s13 = h7.indexOf(i15), o17 = h7.length;
  return s13 === -1 && (s13 = o17, o17 += 1), s13 === o17 - 1;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var f9 = /* @__PURE__ */ new Map();
var u10 = /* @__PURE__ */ new Map();
function h4(t11) {
  var e8;
  let r18 = (e8 = u10.get(t11)) != null ? e8 : 0;
  return u10.set(t11, r18 + 1), r18 !== 0 ? () => m5(t11) : (f9.set(t11, { "aria-hidden": t11.getAttribute("aria-hidden"), inert: t11.inert }), t11.setAttribute("aria-hidden", "true"), t11.inert = true, () => m5(t11));
}
function m5(t11) {
  var i15;
  let r18 = (i15 = u10.get(t11)) != null ? i15 : 1;
  if (r18 === 1 ? u10.delete(t11) : u10.set(t11, r18 - 1), r18 !== 1)
    return;
  let e8 = f9.get(t11);
  e8 && (e8["aria-hidden"] === null ? t11.removeAttribute("aria-hidden") : t11.setAttribute("aria-hidden", e8["aria-hidden"]), t11.inert = e8.inert, f9.delete(t11));
}
function y3(t11, { allowed: r18, disallowed: e8 } = {}) {
  let i15 = x2(t11, "inert-others");
  n(() => {
    var d13, c15;
    if (!i15)
      return;
    let a20 = o2();
    for (let n13 of (d13 = e8 == null ? void 0 : e8()) != null ? d13 : [])
      n13 && a20.add(h4(n13));
    let s13 = (c15 = r18 == null ? void 0 : r18()) != null ? c15 : [];
    for (let n13 of s13) {
      if (!n13)
        continue;
      let l14 = u(n13);
      if (!l14)
        continue;
      let o17 = n13.parentElement;
      for (; o17 && o17 !== l14.body; ) {
        for (let p6 of o17.children)
          s13.some((E12) => p6.contains(E12)) || a20.add(h4(p6));
        o17 = o17.parentElement;
      }
    }
    return a20.dispose;
  }, [i15, r18, e8]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
var import_react64 = __toESM(require_react(), 1);
function m6(s13, n13, l14) {
  let i15 = s3((t11) => {
    let e8 = t11.getBoundingClientRect();
    e8.x === 0 && e8.y === 0 && e8.width === 0 && e8.height === 0 && l14();
  });
  (0, import_react64.useEffect)(() => {
    if (!s13)
      return;
    let t11 = n13 === null ? null : n13 instanceof HTMLElement ? n13 : n13.current;
    if (!t11)
      return;
    let e8 = o2();
    if (typeof ResizeObserver != "undefined") {
      let r18 = new ResizeObserver(() => i15.current(t11));
      r18.observe(t11), e8.add(() => r18.disconnect());
    }
    if (typeof IntersectionObserver != "undefined") {
      let r18 = new IntersectionObserver(() => i15.current(t11));
      r18.observe(t11), e8.add(() => r18.disconnect());
    }
    return () => e8.dispose();
  }, [n13, i15, s13]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react67 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var f10 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e8) => `${e8}:not([tabindex='-1'])`).join(",");
var p4 = ["[data-autofocus]"].map((e8) => `${e8}:not([tabindex='-1'])`).join(",");
var F2 = ((n13) => (n13[n13.First = 1] = "First", n13[n13.Previous = 2] = "Previous", n13[n13.Next = 4] = "Next", n13[n13.Last = 8] = "Last", n13[n13.WrapAround = 16] = "WrapAround", n13[n13.NoScroll = 32] = "NoScroll", n13[n13.AutoFocus = 64] = "AutoFocus", n13))(F2 || {});
var T5 = ((o17) => (o17[o17.Error = 0] = "Error", o17[o17.Overflow = 1] = "Overflow", o17[o17.Success = 2] = "Success", o17[o17.Underflow = 3] = "Underflow", o17))(T5 || {});
var y4 = ((t11) => (t11[t11.Previous = -1] = "Previous", t11[t11.Next = 1] = "Next", t11))(y4 || {});
function b2(e8 = document.body) {
  return e8 == null ? [] : Array.from(e8.querySelectorAll(f10)).sort((r18, t11) => Math.sign((r18.tabIndex || Number.MAX_SAFE_INTEGER) - (t11.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S3(e8 = document.body) {
  return e8 == null ? [] : Array.from(e8.querySelectorAll(p4)).sort((r18, t11) => Math.sign((r18.tabIndex || Number.MAX_SAFE_INTEGER) - (t11.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h5 = ((t11) => (t11[t11.Strict = 0] = "Strict", t11[t11.Loose = 1] = "Loose", t11))(h5 || {});
function A2(e8, r18 = 0) {
  var t11;
  return e8 === ((t11 = u(e8)) == null ? void 0 : t11.body) ? false : u2(r18, { [0]() {
    return e8.matches(f10);
  }, [1]() {
    let u17 = e8;
    for (; u17 !== null; ) {
      if (u17.matches(f10))
        return true;
      u17 = u17.parentElement;
    }
    return false;
  } });
}
function G2(e8) {
  let r18 = u(e8);
  o2().nextFrame(() => {
    r18 && !A2(r18.activeElement, 0) && I2(e8);
  });
}
var H5 = ((t11) => (t11[t11.Keyboard = 0] = "Keyboard", t11[t11.Mouse = 1] = "Mouse", t11))(H5 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e8) => {
  e8.metaKey || e8.altKey || e8.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e8) => {
  e8.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e8.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function I2(e8) {
  e8 == null || e8.focus({ preventScroll: true });
}
var w5 = ["textarea", "input"].join(",");
function O2(e8) {
  var r18, t11;
  return (t11 = (r18 = e8 == null ? void 0 : e8.matches) == null ? void 0 : r18.call(e8, w5)) != null ? t11 : false;
}
function _4(e8, r18 = (t11) => t11) {
  return e8.slice().sort((t11, u17) => {
    let o17 = r18(t11), c15 = r18(u17);
    if (o17 === null || c15 === null)
      return 0;
    let l14 = o17.compareDocumentPosition(c15);
    return l14 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l14 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j3(e8, r18) {
  return P6(b2(), r18, { relativeTo: e8 });
}
function P6(e8, r18, { sorted: t11 = true, relativeTo: u17 = null, skipElements: o17 = [] } = {}) {
  let c15 = Array.isArray(e8) ? e8.length > 0 ? e8[0].ownerDocument : document : e8.ownerDocument, l14 = Array.isArray(e8) ? t11 ? _4(e8) : e8 : r18 & 64 ? S3(e8) : b2(e8);
  o17.length > 0 && l14.length > 1 && (l14 = l14.filter((s13) => !o17.some((a20) => a20 != null && "current" in a20 ? (a20 == null ? void 0 : a20.current) === s13 : a20 === s13))), u17 = u17 != null ? u17 : c15.activeElement;
  let n13 = (() => {
    if (r18 & 5)
      return 1;
    if (r18 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x10 = (() => {
    if (r18 & 1)
      return 0;
    if (r18 & 2)
      return Math.max(0, l14.indexOf(u17)) - 1;
    if (r18 & 4)
      return Math.max(0, l14.indexOf(u17)) + 1;
    if (r18 & 8)
      return l14.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), M9 = r18 & 32 ? { preventScroll: true } : {}, m10 = 0, d13 = l14.length, i15;
  do {
    if (m10 >= d13 || m10 + d13 <= 0)
      return 0;
    let s13 = x10 + m10;
    if (r18 & 16)
      s13 = (s13 + d13) % d13;
    else {
      if (s13 < 0)
        return 3;
      if (s13 >= d13)
        return 1;
    }
    i15 = l14[s13], i15 == null || i15.focus(M9), m10 += n13;
  } while (i15 !== c15.activeElement);
  return r18 & 6 && O2(i15) && i15.select(), 2;
}

// ../../node_modules/@headlessui/react/dist/utils/platform.js
function t4() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i8() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n8() {
  return t4() || i8();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react65 = __toESM(require_react(), 1);
function i9(t11, e8, o17, n13) {
  let u17 = s3(o17);
  (0, import_react65.useEffect)(() => {
    if (!t11)
      return;
    function r18(m10) {
      u17.current(m10);
    }
    return document.addEventListener(e8, r18, n13), () => document.removeEventListener(e8, r18, n13);
  }, [t11, e8, n13]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react66 = __toESM(require_react(), 1);
function s5(t11, e8, o17, n13) {
  let i15 = s3(o17);
  (0, import_react66.useEffect)(() => {
    if (!t11)
      return;
    function r18(d13) {
      i15.current(d13);
    }
    return window.addEventListener(e8, r18, n13), () => window.removeEventListener(e8, r18, n13);
  }, [t11, e8, n13]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var E4 = 30;
function R3(p6, f22, C9) {
  let u17 = x2(p6, "outside-click"), m10 = s3(C9), s13 = (0, import_react67.useCallback)(function(e8, n13) {
    if (e8.defaultPrevented)
      return;
    let r18 = n13(e8);
    if (r18 === null || !r18.getRootNode().contains(r18) || !r18.isConnected)
      return;
    let h7 = function l14(o17) {
      return typeof o17 == "function" ? l14(o17()) : Array.isArray(o17) || o17 instanceof Set ? o17 : [o17];
    }(f22);
    for (let l14 of h7)
      if (l14 !== null && (l14.contains(r18) || e8.composed && e8.composedPath().includes(l14)))
        return;
    return !A2(r18, h5.Loose) && r18.tabIndex !== -1 && e8.preventDefault(), m10.current(e8, r18);
  }, [m10, f22]), i15 = (0, import_react67.useRef)(null);
  i9(u17, "pointerdown", (t11) => {
    var e8, n13;
    i15.current = ((n13 = (e8 = t11.composedPath) == null ? void 0 : e8.call(t11)) == null ? void 0 : n13[0]) || t11.target;
  }, true), i9(u17, "mousedown", (t11) => {
    var e8, n13;
    i15.current = ((n13 = (e8 = t11.composedPath) == null ? void 0 : e8.call(t11)) == null ? void 0 : n13[0]) || t11.target;
  }, true), i9(u17, "click", (t11) => {
    n8() || i15.current && (s13(t11, () => i15.current), i15.current = null);
  }, true);
  let a20 = (0, import_react67.useRef)({ x: 0, y: 0 });
  i9(u17, "touchstart", (t11) => {
    a20.current.x = t11.touches[0].clientX, a20.current.y = t11.touches[0].clientY;
  }, true), i9(u17, "touchend", (t11) => {
    let e8 = { x: t11.changedTouches[0].clientX, y: t11.changedTouches[0].clientY };
    if (!(Math.abs(e8.x - a20.current.x) >= E4 || Math.abs(e8.y - a20.current.y) >= E4))
      return s13(t11, () => t11.target instanceof HTMLElement ? t11.target : null);
  }, true), s5(u17, "blur", (t11) => s13(t11, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react68 = __toESM(require_react(), 1);
function n9(...e8) {
  return (0, import_react68.useMemo)(() => u(...e8), [...e8]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js
var import_react70 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-event-listener.js
var import_react69 = __toESM(require_react(), 1);
function E5(n13, e8, a20, t11) {
  let i15 = s3(a20);
  (0, import_react69.useEffect)(() => {
    n13 = n13 != null ? n13 : window;
    function r18(o17) {
      i15.current(o17);
    }
    return n13.addEventListener(e8, r18, t11), () => n13.removeEventListener(e8, r18, t11);
  }, [n13, e8, t11]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js
function i10(e8) {
  let n13 = (0, import_react70.useRef)({ value: "", selectionStart: null, selectionEnd: null });
  return E5(e8, "blur", (l14) => {
    let t11 = l14.target;
    t11 instanceof HTMLInputElement && (n13.current = { value: t11.value, selectionStart: t11.selectionStart, selectionEnd: t11.selectionEnd });
  }), o4(() => {
    if (document.activeElement !== e8 && e8 instanceof HTMLInputElement && e8.isConnected) {
      if (e8.focus({ preventScroll: true }), e8.value !== n13.current.value)
        e8.setSelectionRange(e8.value.length, e8.value.length);
      else {
        let { selectionStart: l14, selectionEnd: t11 } = n13.current;
        l14 !== null && t11 !== null && e8.setSelectionRange(l14, t11);
      }
      n13.current = { value: "", selectionStart: null, selectionEnd: null };
    }
  });
}

// ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react71 = __toESM(require_react(), 1);
function e6(t11, u17) {
  return (0, import_react71.useMemo)(() => {
    var n13;
    if (t11.type)
      return t11.type;
    let r18 = (n13 = t11.as) != null ? n13 : "button";
    if (typeof r18 == "string" && r18.toLowerCase() === "button" || (u17 == null ? void 0 : u17.tagName) === "BUTTON" && !u17.hasAttribute("type"))
      return "button";
  }, [t11.type, t11.as, u17]);
}

// ../../node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function d6() {
  let r18;
  return { before({ doc: e8 }) {
    var l14;
    let o17 = e8.documentElement, t11 = (l14 = e8.defaultView) != null ? l14 : window;
    r18 = Math.max(0, t11.innerWidth - o17.clientWidth);
  }, after({ doc: e8, d: o17 }) {
    let t11 = e8.documentElement, l14 = Math.max(0, t11.clientWidth - t11.offsetWidth), n13 = Math.max(0, r18 - l14);
    o17.style(t11, "paddingRight", `${n13}px`);
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js
function d7() {
  return t4() ? { before({ doc: r18, d: n13, meta: c15 }) {
    function o17(a20) {
      return c15.containers.flatMap((l14) => l14()).some((l14) => l14.contains(a20));
    }
    n13.microTask(() => {
      var s13;
      if (window.getComputedStyle(r18.documentElement).scrollBehavior !== "auto") {
        let t11 = o2();
        t11.style(r18.documentElement, "scrollBehavior", "auto"), n13.add(() => n13.microTask(() => t11.dispose()));
      }
      let a20 = (s13 = window.scrollY) != null ? s13 : window.pageYOffset, l14 = null;
      n13.addEventListener(r18, "click", (t11) => {
        if (t11.target instanceof HTMLElement)
          try {
            let e8 = t11.target.closest("a");
            if (!e8)
              return;
            let { hash: f22 } = new URL(e8.href), i15 = r18.querySelector(f22);
            i15 && !o17(i15) && (l14 = i15);
          } catch {
          }
      }, true), n13.addEventListener(r18, "touchstart", (t11) => {
        if (t11.target instanceof HTMLElement)
          if (o17(t11.target)) {
            let e8 = t11.target;
            for (; e8.parentElement && o17(e8.parentElement); )
              e8 = e8.parentElement;
            n13.style(e8, "overscrollBehavior", "contain");
          } else
            n13.style(t11.target, "touchAction", "none");
      }), n13.addEventListener(r18, "touchmove", (t11) => {
        if (t11.target instanceof HTMLElement) {
          if (t11.target.tagName === "INPUT")
            return;
          if (o17(t11.target)) {
            let e8 = t11.target;
            for (; e8.parentElement && e8.dataset.headlessuiPortal !== "" && !(e8.scrollHeight > e8.clientHeight || e8.scrollWidth > e8.clientWidth); )
              e8 = e8.parentElement;
            e8.dataset.headlessuiPortal === "" && t11.preventDefault();
          } else
            t11.preventDefault();
        }
      }, { passive: false }), n13.add(() => {
        var e8;
        let t11 = (e8 = window.scrollY) != null ? e8 : window.pageYOffset;
        a20 !== t11 && window.scrollTo(0, a20), l14 && l14.isConnected && (l14.scrollIntoView({ block: "nearest" }), l14 = null);
      });
    });
  } } : {};
}

// ../../node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function r8() {
  return { before({ doc: e8, d: o17 }) {
    o17.style(e8.documentElement, "overflow", "hidden");
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js
function m7(e8) {
  let n13 = {};
  for (let t11 of e8)
    Object.assign(n13, t11(n13));
  return n13;
}
var a10 = a7(() => /* @__PURE__ */ new Map(), { PUSH(e8, n13) {
  var o17;
  let t11 = (o17 = this.get(e8)) != null ? o17 : { doc: e8, count: 0, d: o2(), meta: /* @__PURE__ */ new Set() };
  return t11.count++, t11.meta.add(n13), this.set(e8, t11), this;
}, POP(e8, n13) {
  let t11 = this.get(e8);
  return t11 && (t11.count--, t11.meta.delete(n13)), this;
}, SCROLL_PREVENT({ doc: e8, d: n13, meta: t11 }) {
  let o17 = { doc: e8, d: n13, meta: m7(t11) }, c15 = [d7(), d6(), r8()];
  c15.forEach(({ before: r18 }) => r18 == null ? void 0 : r18(o17)), c15.forEach(({ after: r18 }) => r18 == null ? void 0 : r18(o17));
}, SCROLL_ALLOW({ d: e8 }) {
  e8.dispose();
}, TEARDOWN({ doc: e8 }) {
  this.delete(e8);
} });
a10.subscribe(() => {
  let e8 = a10.getSnapshot(), n13 = /* @__PURE__ */ new Map();
  for (let [t11] of e8)
    n13.set(t11, t11.documentElement.style.overflow);
  for (let t11 of e8.values()) {
    let o17 = n13.get(t11.doc) === "hidden", c15 = t11.count !== 0;
    (c15 && !o17 || !c15 && o17) && a10.dispatch(t11.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t11), t11.count === 0 && a10.dispatch("TEARDOWN", t11);
  }
});

// ../../node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js
function a11(r18, e8, n13 = () => ({ containers: [] })) {
  let f22 = o10(a10), o17 = e8 ? f22.get(e8) : void 0, i15 = o17 ? o17.count > 0 : false;
  return n(() => {
    if (!(!e8 || !r18))
      return a10.dispatch("PUSH", e8, n13), () => a10.dispatch("POP", e8, n13);
  }, [r18, e8]), i15;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js
function f11(e8, c15, n13 = () => [document.body]) {
  let r18 = x2(e8, "scroll-lock");
  a11(r18, c15, (t11) => {
    var o17;
    return { containers: [...(o17 = t11.containers) != null ? o17 : [], n13] };
  });
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react72 = __toESM(require_react(), 1);
function t6(e8) {
  return [e8.screenX, e8.screenY];
}
function u11() {
  let e8 = (0, import_react72.useRef)([-1, -1]);
  return { wasMoved(r18) {
    let n13 = t6(r18);
    return e8.current[0] === n13[0] && e8.current[1] === n13[1] ? false : (e8.current = n13, true);
  }, update(r18) {
    e8.current = t6(r18);
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
var import_react74 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react73 = __toESM(require_react(), 1);
function c6(u17 = 0) {
  let [t11, l14] = (0, import_react73.useState)(u17), g6 = (0, import_react73.useCallback)((e8) => l14(e8), [t11]), s13 = (0, import_react73.useCallback)((e8) => l14((a20) => a20 | e8), [t11]), m10 = (0, import_react73.useCallback)((e8) => (t11 & e8) === e8, [t11]), n13 = (0, import_react73.useCallback)((e8) => l14((a20) => a20 & ~e8), [l14]), F6 = (0, import_react73.useCallback)((e8) => l14((a20) => a20 ^ e8), [l14]);
  return { flags: t11, setFlag: g6, addFlag: s13, hasFlag: m10, removeFlag: n13, toggleFlag: F6 };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
var T7;
var b4;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T7 = process == null ? void 0 : process.env) == null ? void 0 : T7["NODE_ENV"]) === "test" && typeof ((b4 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b4.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L2 = ((r18) => (r18[r18.None = 0] = "None", r18[r18.Closed = 1] = "Closed", r18[r18.Enter = 2] = "Enter", r18[r18.Leave = 4] = "Leave", r18))(L2 || {});
function R4(t11) {
  let n13 = {};
  for (let e8 in t11)
    t11[e8] === true && (n13[`data-${e8}`] = "");
  return n13;
}
function x3(t11, n13, e8, i15) {
  let [r18, o17] = (0, import_react74.useState)(e8), { hasFlag: s13, addFlag: a20, removeFlag: l14 } = c6(t11 && r18 ? 3 : 0), u17 = (0, import_react74.useRef)(false), f22 = (0, import_react74.useRef)(false), E12 = p();
  return n(() => {
    var d13;
    if (t11) {
      if (e8 && o17(true), !n13) {
        e8 && a20(3);
        return;
      }
      return (d13 = i15 == null ? void 0 : i15.start) == null || d13.call(i15, e8), C5(n13, { inFlight: u17, prepare() {
        f22.current ? f22.current = false : f22.current = u17.current, u17.current = true, !f22.current && (e8 ? (a20(3), l14(4)) : (a20(4), l14(2)));
      }, run() {
        f22.current ? e8 ? (l14(3), a20(4)) : (l14(4), a20(3)) : e8 ? l14(1) : a20(1);
      }, done() {
        var p6;
        f22.current && typeof n13.getAnimations == "function" && n13.getAnimations().length > 0 || (u17.current = false, l14(7), e8 || o17(false), (p6 = i15 == null ? void 0 : i15.end) == null || p6.call(i15, e8));
      } });
    }
  }, [t11, e8, n13, E12]), t11 ? [r18, { closed: s13(1), enter: s13(2), leave: s13(4), transition: s13(2) || s13(4) }] : [e8, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C5(t11, { prepare: n13, run: e8, done: i15, inFlight: r18 }) {
  let o17 = o2();
  return j4(t11, { prepare: n13, inFlight: r18 }), o17.nextFrame(() => {
    e8(), o17.requestAnimationFrame(() => {
      o17.add(M(t11, i15));
    });
  }), o17.dispose;
}
function M(t11, n13) {
  var o17, s13;
  let e8 = o2();
  if (!t11)
    return e8.dispose;
  let i15 = false;
  e8.add(() => {
    i15 = true;
  });
  let r18 = (s13 = (o17 = t11.getAnimations) == null ? void 0 : o17.call(t11).filter((a20) => a20 instanceof CSSTransition)) != null ? s13 : [];
  return r18.length === 0 ? (n13(), e8.dispose) : (Promise.allSettled(r18.map((a20) => a20.finished)).then(() => {
    i15 || n13();
  }), e8.dispose);
}
function j4(t11, { inFlight: n13, prepare: e8 }) {
  if (n13 != null && n13.current) {
    e8();
    return;
  }
  let i15 = t11.style.transition;
  t11.style.transition = "none", e8(), t11.offsetHeight, t11.style.transition = i15;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react75 = __toESM(require_react(), 1);
function F3(c15, { container: e8, accept: t11, walk: r18 }) {
  let o17 = (0, import_react75.useRef)(t11), l14 = (0, import_react75.useRef)(r18);
  (0, import_react75.useEffect)(() => {
    o17.current = t11, l14.current = r18;
  }, [t11, r18]), n(() => {
    if (!e8 || !c15)
      return;
    let n13 = u(e8);
    if (!n13)
      return;
    let f22 = o17.current, p6 = l14.current, i15 = Object.assign((m10) => f22(m10), { acceptNode: f22 }), u17 = n13.createTreeWalker(e8, NodeFilter.SHOW_ELEMENT, i15, false);
    for (; u17.nextNode(); )
      p6(u17.currentNode);
  }, [e8, c15, o17, l14]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-watch.js
var import_react76 = __toESM(require_react(), 1);
function m8(u17, t11) {
  let e8 = (0, import_react76.useRef)([]), r18 = o4(u17);
  (0, import_react76.useEffect)(() => {
    let o17 = [...e8.current];
    for (let [a20, l14] of t11.entries())
      if (e8.current[a20] !== l14) {
        let n13 = r18(t11, o17);
        return e8.current = t11, n13;
      }
  }, [r18, ...t11]);
}

// ../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React3 = __toESM(require_react(), 1);
var import_react78 = __toESM(require_react(), 1);

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e8) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v4) => ({
  x: v4,
  y: v4
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x10,
    y: y9,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y9,
    left: x10,
    right: x10 + width,
    bottom: y9 + height,
    x: x10,
    y: y9
  };
}

// ../../node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// ../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM2 = __toESM(require_react_dom(), 1);

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x10,
    y: y9
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i15 = 0; i15 < validMiddleware.length; i15++) {
    const {
      name,
      fn
    } = validMiddleware[i15];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x10,
      y: y9,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x10 = nextX != null ? nextX : x10;
    y9 = nextY != null ? nextY : y9;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x10,
          y: y9
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i15 = -1;
    }
  }
  return {
    x: x10,
    y: y9,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x10,
    y: y9,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x10,
    y: y9,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x10,
      y: y9,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x10,
      y: y9
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d13) => d13.overflows[0] <= 0).sort((a20, b9) => a20.overflows[1] - b9.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d13) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d13.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d13) => [d13.placement, d13.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a20, b9) => a20[1] - b9[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x10,
        y: y9,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x10 + diffCoords.x,
        y: y9 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x10,
        y: y9,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x11,
              y: y10
            } = _ref;
            return {
              x: x11,
              y: y10
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y9
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x10,
          y: limitedCoords.y - y9,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x10,
        y: y9,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y9
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x10 = ($3 ? round(rect.width) : rect.width) / width;
  let y9 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x10 || !Number.isFinite(x10)) {
    x10 = 1;
  }
  if (!y9 || !Number.isFinite(y9)) {
    y9 = 1;
  }
  return {
    x: x10,
    y: y9
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x10 = (clientRect.left + visualOffsets.x) / scale.x;
  let y9 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x10 *= iframeScale.x;
      y9 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x10 += left;
      y9 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x10,
    y: y9
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x10 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y9 = htmlRect.top + scroll.scrollTop;
  return {
    x: x10,
    y: y9
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x10 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y9 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x10 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x10,
    y: y9
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x10 = 0;
  let y9 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x10 = visualViewport.offsetLeft;
      y9 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x10,
    y: y9
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x10 = left * scale.x;
  const y9 = top * scale.y;
  return {
    width,
    height,
    x: x10,
    y: y9
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x10 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y9 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x10,
    y: y9,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a20, b9) {
  return a20.x === b9.x && a20.y === b9.y && a20.width === b9.width && a20.height === b9.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e8) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var detectOverflow2 = detectOverflow;
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React2 = __toESM(require_react(), 1);
var import_react77 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react77.useLayoutEffect : import_react77.useEffect;
function deepEqual(a20, b9) {
  if (a20 === b9) {
    return true;
  }
  if (typeof a20 !== typeof b9) {
    return false;
  }
  if (typeof a20 === "function" && a20.toString() === b9.toString()) {
    return true;
  }
  let length;
  let i15;
  let keys;
  if (a20 && b9 && typeof a20 === "object") {
    if (Array.isArray(a20)) {
      length = a20.length;
      if (length !== b9.length)
        return false;
      for (i15 = length; i15-- !== 0; ) {
        if (!deepEqual(a20[i15], b9[i15])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a20);
    length = keys.length;
    if (length !== Object.keys(b9).length) {
      return false;
    }
    for (i15 = length; i15-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b9, keys[i15])) {
        return false;
      }
    }
    for (i15 = length; i15-- !== 0; ) {
      const key = keys[i15];
      if (key === "_owner" && a20.$$typeof) {
        continue;
      }
      if (!deepEqual(a20[key], b9[key])) {
        return false;
      }
    }
    return true;
  }
  return a20 !== a20 && b9 !== b9;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React2.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React2.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x10 = roundByDPR(elements.floating, data.x);
    const y9 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x10 + "px, " + y9 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x10,
      top: y9
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React2.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  return React3.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React3
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React3.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React3.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= list.length - 1 && isDisabled(list, index3, disabledIndices));
  return index3;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i15 = 0; i15 < width; i15++) {
        for (let j9 = 0; j9 < height; j9++) {
          targetCells.push(startIndex + i15 + j9 * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index3, sizes, cellMap, cols, corner) {
  if (index3 === -1)
    return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  const sizeItem = sizes[index3];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function isDisabled(list, index3, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index3);
  }
  const element = list[index3];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var index2 = typeof document !== "undefined" ? import_react78.useLayoutEffect : import_react78.useEffect;
function sortByDocumentPosition(a20, b9) {
  const position = a20.compareDocumentPosition(b9);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
var FloatingListContext = React3.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map, setMap] = React3.useState(() => /* @__PURE__ */ new Map());
  const register = React3.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = React3.useCallback((node) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node);
      return map2;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node, index3) => {
      newMap.set(node, index3);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return React3.createElement(FloatingListContext.Provider, {
    value: React3.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React3.useContext(FloatingListContext);
  const [index$1, setIndex] = React3.useState(null);
  const componentRef = React3.useRef(null);
  const ref = React3.useCallback((node) => {
    componentRef.current = node;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index2(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index3 = componentRef.current ? map.get(componentRef.current) : null;
    if (index3 != null) {
      setIndex(index3);
    }
  }, [map]);
  return React3.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React3.cloneElement(render, computedProps);
  }
  return React3.createElement("div", computedProps);
}
var CompositeContext = React3.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React3.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React3.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React3.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React3.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key))
      return;
    let nextIndex = activeIndex;
    const minIndex = getMinIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;
    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_9, index3) => isDisabled(elementsRef.current, index3) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN],
      both: [horizontalEndKey, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP],
      both: [horizontalStartKey, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e8) {
      domProps.onKeyDown == null || domProps.onKeyDown(e8);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e8);
      handleKeyDown(e8);
    }
  };
  return React3.createElement(CompositeContext.Provider, {
    value: contextValue
  }, React3.createElement(FloatingList, {
    elementsRef
  }, renderJsx(render, computedProps)));
});
var CompositeItem = React3.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React3.useContext(CompositeContext);
  const {
    ref,
    index: index3
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index3;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e8) {
      domProps.onFocus == null || domProps.onFocus(e8);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e8);
      onNavigate(index3);
    }
  };
  return renderJsx(render, computedProps);
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React3.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId = SafeReact.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React3.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d: d13,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React3.useState(false);
  index2(() => {
    if (!floating)
      return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d13;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d13 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React3.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t11) => !!t11).join(" "),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && React3.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d13 ? 0 : 1),
    d: dValue
  }), React3.createElement("path", {
    stroke: computedStrokeWidth && !d13 ? rest.fill : "none",
    d: dValue
  }), React3.createElement("clipPath", {
    id: clipPathId
  }, React3.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l14) => l14 !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React3.createContext(null);
var FloatingTreeContext = React3.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React3.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React3.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
var NOOP = () => {
};
var FloatingDelayGroupContext = React3.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React3.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React3.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React3.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React3.createContext(null);
var attr = createAttribute("portal");
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var VisuallyHiddenDismiss = React3.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React3.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
var lockCount = 0;
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React3.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index2(() => {
    if (!lockScroll)
      return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return React3.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React3.useRef({});
  const [events3] = React3.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React3.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events3.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React3.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React3.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React3.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events: events3,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events3, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React3.useState(null);
  const [positionReference, _setPositionReference] = React3.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React3.useRef(null);
  const tree = useFloatingTree();
  index2(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React3.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React3.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React3.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React3.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React3.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index2(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React3.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _9,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React3.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
var inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index3 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state);
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index3];
    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const clientTop = floating.clientTop || scrollEl.clientTop;
    const floatingIsBordered = floating.clientTop !== 0;
    const scrollElIsBordered = scrollEl.clientTop !== 0;
    const floatingIsScrollEl = floating === scrollEl;
    if (true) {
      if (!state.placement.startsWith("bottom")) {
        warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
      }
    }
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset3(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const overflow = await detectOverflow2(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
    const refOverflow = await detectOverflow2(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
    const rounder = isScrollable ? (v4) => v4 : round;
    const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    scrollEl.style.maxHeight = maxHeight + "px";
    scrollEl.scrollTop = diffY;
    if (onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      ReactDOM2.flushSync(() => onFallbackChange(shouldFallback));
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow2(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = React3.useRef(false);
  const prevScrollTopRef = React3.useRef(null);
  const initialOverflowRef = React3.useRef(null);
  React3.useEffect(() => {
    if (!enabled)
      return;
    function onWheel(e8) {
      if (e8.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e8.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e8.preventDefault();
        ReactDOM2.flushSync(() => {
          onChange((d13) => d13 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = React3.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          ReactDOM2.flushSync(() => onChange((d13) => d13 + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return React3.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}

// ../../node_modules/@headlessui/react/dist/internal/floating.js
var j5 = __toESM(require_react(), 1);
var import_react80 = __toESM(require_react(), 1);
var y5 = (0, import_react80.createContext)({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y5.displayName = "FloatingContext";
var H6 = (0, import_react80.createContext)(null);
H6.displayName = "PlacementContext";
function xe(e8) {
  return (0, import_react80.useMemo)(() => e8 ? typeof e8 == "string" ? { to: e8 } : e8 : null, [e8]);
}
function ye() {
  return (0, import_react80.useContext)(y5).setReference;
}
function Fe() {
  return (0, import_react80.useContext)(y5).getReferenceProps;
}
function be() {
  let { getFloatingProps: e8, slot: t11 } = (0, import_react80.useContext)(y5);
  return (0, import_react80.useCallback)((...n13) => Object.assign({}, e8(...n13), { "data-anchor": t11.anchor }), [e8, t11]);
}
function Re(e8 = null) {
  e8 === false && (e8 = null), typeof e8 == "string" && (e8 = { to: e8 });
  let t11 = (0, import_react80.useContext)(H6), n13 = (0, import_react80.useMemo)(() => e8, [JSON.stringify(e8, (r18, o17) => {
    var u17;
    return (u17 = o17 == null ? void 0 : o17.outerHTML) != null ? u17 : o17;
  })]);
  n(() => {
    t11 == null || t11(n13 != null ? n13 : null);
  }, [t11, n13]);
  let l14 = (0, import_react80.useContext)(y5);
  return (0, import_react80.useMemo)(() => [l14.setFloating, e8 ? l14.styles : {}], [l14.setFloating, e8, l14.styles]);
}
var q = 4;
function Me({ children: e8, enabled: t11 = true }) {
  let [n13, l14] = (0, import_react80.useState)(null), [r18, o17] = (0, import_react80.useState)(0), u17 = (0, import_react80.useRef)(null), [f22, s13] = (0, import_react80.useState)(null);
  pe(f22);
  let i15 = t11 && n13 !== null && f22 !== null, { to: F6 = "bottom", gap: E12 = 0, offset: v4 = 0, padding: c15 = 0, inner: P7 } = ce(n13, f22), [a20, p6 = "center"] = F6.split(" ");
  n(() => {
    i15 && o17(0);
  }, [i15]);
  let { refs: b9, floatingStyles: w11, context: g6 } = useFloating2({ open: i15, placement: a20 === "selection" ? p6 === "center" ? "bottom" : `bottom-${p6}` : p6 === "center" ? `${a20}` : `${a20}-${p6}`, strategy: "absolute", transform: false, middleware: [offset3({ mainAxis: a20 === "selection" ? 0 : E12, crossAxis: v4 }), shift3({ padding: c15 }), a20 !== "selection" && flip3({ padding: c15 }), a20 === "selection" && P7 ? inner({ ...P7, padding: c15, overflowRef: u17, offset: r18, minItemsVisible: q, referenceOverflowThreshold: c15, onFallbackChange(h7) {
    var O7, W5;
    if (!h7)
      return;
    let d13 = g6.elements.floating;
    if (!d13)
      return;
    let T10 = parseFloat(getComputedStyle(d13).scrollPaddingBottom) || 0, $3 = Math.min(q, d13.childElementCount), L6 = 0, N4 = 0;
    for (let m10 of (W5 = (O7 = g6.elements.floating) == null ? void 0 : O7.childNodes) != null ? W5 : [])
      if (m10 instanceof HTMLElement) {
        let x10 = m10.offsetTop, k5 = x10 + m10.clientHeight + T10, S7 = d13.scrollTop, U8 = S7 + d13.clientHeight;
        if (x10 >= S7 && k5 <= U8)
          $3--;
        else {
          N4 = Math.max(0, Math.min(k5, U8) - Math.max(x10, S7)), L6 = m10.clientHeight;
          break;
        }
      }
    $3 >= 1 && o17((m10) => {
      let x10 = L6 * $3 - N4 + T10;
      return m10 >= x10 ? m10 : x10;
    });
  } }) : null, size3({ padding: c15, apply({ availableWidth: h7, availableHeight: d13, elements: T10 }) {
    Object.assign(T10.floating.style, { overflow: "auto", maxWidth: `${h7}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d13}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I6 = a20, B3 = p6] = g6.placement.split("-");
  a20 === "selection" && (I6 = "selection");
  let G7 = (0, import_react80.useMemo)(() => ({ anchor: [I6, B3].filter(Boolean).join(" ") }), [I6, B3]), K4 = useInnerOffset(g6, { overflowRef: u17, onChange: o17 }), { getReferenceProps: Q6, getFloatingProps: X4 } = useInteractions([K4]), Y4 = o4((h7) => {
    s13(h7), b9.setFloating(h7);
  });
  return j5.createElement(H6.Provider, { value: l14 }, j5.createElement(y5.Provider, { value: { setFloating: Y4, setReference: b9.setReference, styles: w11, getReferenceProps: Q6, getFloatingProps: X4, slot: G7 } }, e8));
}
function pe(e8) {
  n(() => {
    if (!e8)
      return;
    let t11 = new MutationObserver(() => {
      let n13 = window.getComputedStyle(e8).maxHeight, l14 = parseFloat(n13);
      if (isNaN(l14))
        return;
      let r18 = parseInt(n13);
      isNaN(r18) || l14 !== r18 && (e8.style.maxHeight = `${Math.ceil(l14)}px`);
    });
    return t11.observe(e8, { attributes: true, attributeFilter: ["style"] }), () => {
      t11.disconnect();
    };
  }, [e8]);
}
function ce(e8, t11) {
  var o17, u17, f22;
  let n13 = V2((o17 = e8 == null ? void 0 : e8.gap) != null ? o17 : "var(--anchor-gap, 0)", t11), l14 = V2((u17 = e8 == null ? void 0 : e8.offset) != null ? u17 : "var(--anchor-offset, 0)", t11), r18 = V2((f22 = e8 == null ? void 0 : e8.padding) != null ? f22 : "var(--anchor-padding, 0)", t11);
  return { ...e8, gap: n13, offset: l14, padding: r18 };
}
function V2(e8, t11, n13 = void 0) {
  let l14 = p(), r18 = o4((s13, i15) => {
    if (s13 == null)
      return [n13, null];
    if (typeof s13 == "number")
      return [s13, null];
    if (typeof s13 == "string") {
      if (!i15)
        return [n13, null];
      let F6 = J2(s13, i15);
      return [F6, (E12) => {
        let v4 = D3(s13);
        {
          let c15 = v4.map((P7) => window.getComputedStyle(i15).getPropertyValue(P7));
          l14.requestAnimationFrame(function P7() {
            l14.nextFrame(P7);
            let a20 = false;
            for (let [b9, w11] of v4.entries()) {
              let g6 = window.getComputedStyle(i15).getPropertyValue(w11);
              if (c15[b9] !== g6) {
                c15[b9] = g6, a20 = true;
                break;
              }
            }
            if (!a20)
              return;
            let p6 = J2(s13, i15);
            F6 !== p6 && (E12(p6), F6 = p6);
          });
        }
        return l14.dispose;
      }];
    }
    return [n13, null];
  }), o17 = (0, import_react80.useMemo)(() => r18(e8, t11)[0], [e8, t11]), [u17 = o17, f22] = (0, import_react80.useState)();
  return n(() => {
    let [s13, i15] = r18(e8, t11);
    if (f22(s13), !!i15)
      return i15(f22);
  }, [e8, t11]), u17;
}
function D3(e8) {
  let t11 = /var\((.*)\)/.exec(e8);
  if (t11) {
    let n13 = t11[1].indexOf(",");
    if (n13 === -1)
      return [t11[1]];
    let l14 = t11[1].slice(0, n13).trim(), r18 = t11[1].slice(n13 + 1).trim();
    return r18 ? [l14, ...D3(r18)] : [l14];
  }
  return [];
}
function J2(e8, t11) {
  let n13 = document.createElement("div");
  t11.appendChild(n13), n13.style.setProperty("margin-top", "0px", "important"), n13.style.setProperty("margin-top", e8, "important");
  let l14 = parseFloat(window.getComputedStyle(n13).marginTop) || 0;
  return t11.removeChild(n13), l14;
}

// ../../node_modules/@headlessui/react/dist/internal/frozen.js
var import_react81 = __toESM(require_react(), 1);
function f13({ children: o17, freeze: e8 }) {
  let n13 = l7(e8, o17);
  return import_react81.default.createElement(import_react81.default.Fragment, null, n13);
}
function l7(o17, e8) {
  let [n13, t11] = (0, import_react81.useState)(e8);
  return !o17 && n13 !== e8 && t11(e8), o17 ? n13 : e8;
}

// ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react82 = __toESM(require_react(), 1);
var n10 = (0, import_react82.createContext)(null);
n10.displayName = "OpenClosedContext";
var i11 = ((e8) => (e8[e8.Open = 1] = "Open", e8[e8.Closed = 2] = "Closed", e8[e8.Closing = 4] = "Closing", e8[e8.Opening = 8] = "Opening", e8))(i11 || {});
function u13() {
  return (0, import_react82.useContext)(n10);
}
function c8({ value: o17, children: t11 }) {
  return import_react82.default.createElement(n10.Provider, { value: o17 }, t11);
}
function s7({ children: o17 }) {
  return import_react82.default.createElement(n10.Provider, { value: null }, o17);
}

// ../../node_modules/@headlessui/react/dist/utils/document-ready.js
function t7(n13) {
  function e8() {
    document.readyState !== "loading" && (n13(), document.removeEventListener("DOMContentLoaded", e8));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e8), e8());
}

// ../../node_modules/@headlessui/react/dist/utils/active-element-history.js
var r12 = [];
t7(() => {
  function e8(t11) {
    if (!(t11.target instanceof HTMLElement) || t11.target === document.body || r12[0] === t11.target)
      return;
    let n13 = t11.target;
    n13 = n13.closest(f10), r12.unshift(n13 != null ? n13 : t11.target), r12 = r12.filter((o17) => o17 != null && o17.isConnected), r12.splice(10);
  }
  window.addEventListener("click", e8, { capture: true }), window.addEventListener("mousedown", e8, { capture: true }), window.addEventListener("focus", e8, { capture: true }), document.body.addEventListener("click", e8, { capture: true }), document.body.addEventListener("mousedown", e8, { capture: true }), document.body.addEventListener("focus", e8, { capture: true });
});

// ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function u14(l14) {
  throw new Error("Unexpected object: " + l14);
}
var c9 = ((i15) => (i15[i15.First = 0] = "First", i15[i15.Previous = 1] = "Previous", i15[i15.Next = 2] = "Next", i15[i15.Last = 3] = "Last", i15[i15.Specific = 4] = "Specific", i15[i15.Nothing = 5] = "Nothing", i15))(c9 || {});
function f14(l14, n13) {
  let t11 = n13.resolveItems();
  if (t11.length <= 0)
    return null;
  let r18 = n13.resolveActiveIndex(), s13 = r18 != null ? r18 : -1;
  switch (l14.focus) {
    case 0: {
      for (let e8 = 0; e8 < t11.length; ++e8)
        if (!n13.resolveDisabled(t11[e8], e8, t11))
          return e8;
      return r18;
    }
    case 1: {
      s13 === -1 && (s13 = t11.length);
      for (let e8 = s13 - 1; e8 >= 0; --e8)
        if (!n13.resolveDisabled(t11[e8], e8, t11))
          return e8;
      return r18;
    }
    case 2: {
      for (let e8 = s13 + 1; e8 < t11.length; ++e8)
        if (!n13.resolveDisabled(t11[e8], e8, t11))
          return e8;
      return r18;
    }
    case 3: {
      for (let e8 = t11.length - 1; e8 >= 0; --e8)
        if (!n13.resolveDisabled(t11[e8], e8, t11))
          return e8;
      return r18;
    }
    case 4: {
      for (let e8 = 0; e8 < t11.length; ++e8)
        if (n13.resolveId(t11[e8], e8, t11) === l14.id)
          return e8;
      return r18;
    }
    case 5:
      return null;
    default:
      u14(l14);
  }
}

// ../../node_modules/@headlessui/react/dist/components/mouse.js
var g2 = ((f22) => (f22[f22.Left = 0] = "Left", f22[f22.Right = 2] = "Right", f22))(g2 || {});

// ../../node_modules/@headlessui/react/dist/components/portal/portal.js
var import_react85 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var import_react83 = __toESM(require_react(), 1);
function c10(t11) {
  let r18 = o4(t11), e8 = (0, import_react83.useRef)(false);
  (0, import_react83.useEffect)(() => (e8.current = false, () => {
    e8.current = true, t(() => {
      e8.current && r18();
    });
  }), [r18]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t8 = __toESM(require_react(), 1);
function s8() {
  let r18 = typeof document == "undefined";
  return "useSyncExternalStore" in t8 ? ((o17) => o17.useSyncExternalStore)(t8)(() => () => {
  }, () => false, () => !r18) : false;
}
function l9() {
  let r18 = s8(), [e8, n13] = t8.useState(s.isHandoffComplete);
  return e8 && s.isHandoffComplete === false && n13(false), t8.useEffect(() => {
    e8 !== true && n13(true);
  }, [e8]), t8.useEffect(() => s.handoff(), []), r18 ? false : e8;
}

// ../../node_modules/@headlessui/react/dist/internal/portal-force-root.js
var import_react84 = __toESM(require_react(), 1);
var e7 = (0, import_react84.createContext)(false);
function a12() {
  return (0, import_react84.useContext)(e7);
}
function l10(o17) {
  return import_react84.default.createElement(e7.Provider, { value: o17.force }, o17.children);
}

// ../../node_modules/@headlessui/react/dist/components/portal/portal.js
function N2(u17) {
  let r18 = a12(), n13 = (0, import_react85.useContext)(v3), e8 = n9(u17), [o17, l14] = (0, import_react85.useState)(() => {
    var t11;
    if (!r18 && n13 !== null)
      return (t11 = n13.current) != null ? t11 : null;
    if (s.isServer)
      return null;
    let p6 = e8 == null ? void 0 : e8.getElementById("headlessui-portal-root");
    if (p6)
      return p6;
    if (e8 === null)
      return null;
    let a20 = e8.createElement("div");
    return a20.setAttribute("id", "headlessui-portal-root"), e8.body.appendChild(a20);
  });
  return (0, import_react85.useEffect)(() => {
    o17 !== null && (e8 != null && e8.body.contains(o17) || e8 == null || e8.body.appendChild(o17));
  }, [o17, e8]), (0, import_react85.useEffect)(() => {
    r18 || n13 !== null && l14(n13.current);
  }, [n13, l14, r18]), o17;
}
var M3 = import_react85.Fragment;
var S5 = K(function(r18, n13) {
  let e8 = r18, o17 = (0, import_react85.useRef)(null), l14 = y(T2((i15) => {
    o17.current = i15;
  }), n13), p6 = n9(o17), a20 = N2(o17), [t11] = (0, import_react85.useState)(() => {
    var i15;
    return s.isServer ? null : (i15 = p6 == null ? void 0 : p6.createElement("div")) != null ? i15 : null;
  }), s13 = (0, import_react85.useContext)(y6), b9 = l9();
  n(() => {
    !a20 || !t11 || a20.contains(t11) || (t11.setAttribute("data-headlessui-portal", ""), a20.appendChild(t11));
  }, [a20, t11]), n(() => {
    if (t11 && s13)
      return s13.register(t11);
  }, [s13, t11]), c10(() => {
    var i15;
    !a20 || !t11 || (t11 instanceof Node && a20.contains(t11) && a20.removeChild(t11), a20.childNodes.length <= 0 && ((i15 = a20.parentElement) == null || i15.removeChild(a20)));
  });
  let H13 = L();
  return b9 ? !a20 || !t11 ? null : (0, import_react_dom7.createPortal)(H13({ ourProps: { ref: l14 }, theirProps: e8, slot: {}, defaultTag: M3, name: "Portal" }), t11) : null;
});
function j6(u17, r18) {
  let n13 = y(r18), { enabled: e8 = true, ...o17 } = u17, l14 = L();
  return e8 ? import_react85.default.createElement(S5, { ...o17, ref: n13 }) : l14({ ourProps: { ref: n13 }, theirProps: o17, slot: {}, defaultTag: M3, name: "Portal" });
}
var W2 = import_react85.Fragment;
var v3 = (0, import_react85.createContext)(null);
function I3(u17, r18) {
  let { target: n13, ...e8 } = u17, l14 = { ref: y(r18) }, p6 = L();
  return import_react85.default.createElement(v3.Provider, { value: n13 }, p6({ ourProps: l14, theirProps: e8, defaultTag: W2, name: "Popover.Group" }));
}
var y6 = (0, import_react85.createContext)(null);
function te() {
  let u17 = (0, import_react85.useContext)(y6), r18 = (0, import_react85.useRef)([]), n13 = o4((l14) => (r18.current.push(l14), u17 && u17.register(l14), () => e8(l14))), e8 = o4((l14) => {
    let p6 = r18.current.indexOf(l14);
    p6 !== -1 && r18.current.splice(p6, 1), u17 && u17.unregister(l14);
  }), o17 = (0, import_react85.useMemo)(() => ({ register: n13, unregister: e8, portals: r18 }), [n13, e8, r18]);
  return [r18, (0, import_react85.useMemo)(() => function({ children: p6 }) {
    return import_react85.default.createElement(y6.Provider, { value: o17 }, p6);
  }, [o17])];
}
var J3 = K(j6);
var X = K(I3);
var re = Object.assign(J3, { Group: X });

// ../../node_modules/@headlessui/react/dist/components/combobox/combobox.js
var Ct = ((e8) => (e8[e8.Open = 0] = "Open", e8[e8.Closed = 1] = "Closed", e8))(Ct || {});
var Et = ((e8) => (e8[e8.Single = 0] = "Single", e8[e8.Multi = 1] = "Multi", e8))(Et || {});
var St = ((o17) => (o17[o17.Pointer = 0] = "Pointer", o17[o17.Focus = 1] = "Focus", o17[o17.Other = 2] = "Other", o17))(St || {});
var It = ((l14) => (l14[l14.OpenCombobox = 0] = "OpenCombobox", l14[l14.CloseCombobox = 1] = "CloseCombobox", l14[l14.GoToOption = 2] = "GoToOption", l14[l14.SetTyping = 3] = "SetTyping", l14[l14.RegisterOption = 4] = "RegisterOption", l14[l14.UnregisterOption = 5] = "UnregisterOption", l14[l14.SetActivationTrigger = 6] = "SetActivationTrigger", l14[l14.UpdateVirtualConfiguration = 7] = "UpdateVirtualConfiguration", l14[l14.SetInputElement = 8] = "SetInputElement", l14[l14.SetButtonElement = 9] = "SetButtonElement", l14[l14.SetOptionsElement = 10] = "SetOptionsElement", l14))(It || {});
function ve(t11, n13 = (e8) => e8) {
  let e8 = t11.activeOptionIndex !== null ? t11.options[t11.activeOptionIndex] : null, o17 = n13(t11.options.slice()), f22 = o17.length > 0 && o17[0].dataRef.current.order !== null ? o17.sort((m10, d13) => m10.dataRef.current.order - d13.dataRef.current.order) : _4(o17, (m10) => m10.dataRef.current.domRef.current), b9 = e8 ? f22.indexOf(e8) : null;
  return b9 === -1 && (b9 = null), { options: f22, activeOptionIndex: b9 };
}
var Pt = { [1](t11) {
  var n13;
  return (n13 = t11.dataRef.current) != null && n13.disabled || t11.comboboxState === 1 ? t11 : { ...t11, activeOptionIndex: null, comboboxState: 1, isTyping: false, activationTrigger: 2, __demoMode: false };
}, [0](t11) {
  var n13, e8;
  if ((n13 = t11.dataRef.current) != null && n13.disabled || t11.comboboxState === 0)
    return t11;
  if ((e8 = t11.dataRef.current) != null && e8.value) {
    let o17 = t11.dataRef.current.calculateIndex(t11.dataRef.current.value);
    if (o17 !== -1)
      return { ...t11, activeOptionIndex: o17, comboboxState: 0, __demoMode: false };
  }
  return { ...t11, comboboxState: 0, __demoMode: false };
}, [3](t11, n13) {
  return t11.isTyping === n13.isTyping ? t11 : { ...t11, isTyping: n13.isTyping };
}, [2](t11, n13) {
  var b9, m10, d13, x10;
  if ((b9 = t11.dataRef.current) != null && b9.disabled || t11.optionsElement && !((m10 = t11.dataRef.current) != null && m10.optionsPropsRef.current.static) && t11.comboboxState === 1)
    return t11;
  if (t11.virtual) {
    let { options: i15, disabled: r18 } = t11.virtual, l14 = n13.focus === c9.Specific ? n13.idx : f14(n13, { resolveItems: () => i15, resolveActiveIndex: () => {
      var R9, s13;
      return (s13 = (R9 = t11.activeOptionIndex) != null ? R9 : i15.findIndex((D7) => !r18(D7))) != null ? s13 : null;
    }, resolveDisabled: r18, resolveId() {
      throw new Error("Function not implemented.");
    } }), S7 = (d13 = n13.trigger) != null ? d13 : 2;
    return t11.activeOptionIndex === l14 && t11.activationTrigger === S7 ? t11 : { ...t11, activeOptionIndex: l14, activationTrigger: S7, isTyping: false, __demoMode: false };
  }
  let e8 = ve(t11);
  if (e8.activeOptionIndex === null) {
    let i15 = e8.options.findIndex((r18) => !r18.dataRef.current.disabled);
    i15 !== -1 && (e8.activeOptionIndex = i15);
  }
  let o17 = n13.focus === c9.Specific ? n13.idx : f14(n13, { resolveItems: () => e8.options, resolveActiveIndex: () => e8.activeOptionIndex, resolveId: (i15) => i15.id, resolveDisabled: (i15) => i15.dataRef.current.disabled }), f22 = (x10 = n13.trigger) != null ? x10 : 2;
  return t11.activeOptionIndex === o17 && t11.activationTrigger === f22 ? t11 : { ...t11, ...e8, isTyping: false, activeOptionIndex: o17, activationTrigger: f22, __demoMode: false };
}, [4]: (t11, n13) => {
  var b9, m10, d13;
  if ((b9 = t11.dataRef.current) != null && b9.virtual)
    return { ...t11, options: [...t11.options, n13.payload] };
  let e8 = n13.payload, o17 = ve(t11, (x10) => (x10.push(e8), x10));
  t11.activeOptionIndex === null && (m10 = t11.dataRef.current) != null && m10.isSelected(n13.payload.dataRef.current.value) && (o17.activeOptionIndex = o17.options.indexOf(e8));
  let f22 = { ...t11, ...o17, activationTrigger: 2 };
  return (d13 = t11.dataRef.current) != null && d13.__demoMode && t11.dataRef.current.value === void 0 && (f22.activeOptionIndex = 0), f22;
}, [5]: (t11, n13) => {
  var o17;
  if ((o17 = t11.dataRef.current) != null && o17.virtual)
    return { ...t11, options: t11.options.filter((f22) => f22.id !== n13.id) };
  let e8 = ve(t11, (f22) => {
    let b9 = f22.findIndex((m10) => m10.id === n13.id);
    return b9 !== -1 && f22.splice(b9, 1), f22;
  });
  return { ...t11, ...e8, activationTrigger: 2 };
}, [6]: (t11, n13) => t11.activationTrigger === n13.trigger ? t11 : { ...t11, activationTrigger: n13.trigger }, [7]: (t11, n13) => {
  var o17, f22;
  if (t11.virtual === null)
    return { ...t11, virtual: { options: n13.options, disabled: (o17 = n13.disabled) != null ? o17 : () => false } };
  if (t11.virtual.options === n13.options && t11.virtual.disabled === n13.disabled)
    return t11;
  let e8 = t11.activeOptionIndex;
  if (t11.activeOptionIndex !== null) {
    let b9 = n13.options.indexOf(t11.virtual.options[t11.activeOptionIndex]);
    b9 !== -1 ? e8 = b9 : e8 = null;
  }
  return { ...t11, activeOptionIndex: e8, virtual: { options: n13.options, disabled: (f22 = n13.disabled) != null ? f22 : () => false } };
}, [8]: (t11, n13) => t11.inputElement === n13.element ? t11 : { ...t11, inputElement: n13.element }, [9]: (t11, n13) => t11.buttonElement === n13.element ? t11 : { ...t11, buttonElement: n13.element }, [10]: (t11, n13) => t11.optionsElement === n13.element ? t11 : { ...t11, optionsElement: n13.element } };
var ye2 = (0, import_react86.createContext)(null);
ye2.displayName = "ComboboxActionsContext";
function le(t11) {
  let n13 = (0, import_react86.useContext)(ye2);
  if (n13 === null) {
    let e8 = new Error(`<${t11} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e8, le), e8;
  }
  return n13;
}
var Ne = (0, import_react86.createContext)(null);
function At(t11) {
  let n13 = ne("VirtualProvider"), { options: e8 } = n13.virtual, [o17, f22] = (0, import_react86.useMemo)(() => {
    let i15 = n13.optionsElement;
    if (!i15)
      return [0, 0];
    let r18 = window.getComputedStyle(i15);
    return [parseFloat(r18.paddingBlockStart || r18.paddingTop), parseFloat(r18.paddingBlockEnd || r18.paddingBottom)];
  }, [n13.optionsElement]), b9 = useVirtualizer({ enabled: e8.length !== 0, scrollPaddingStart: o17, scrollPaddingEnd: f22, count: e8.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    return n13.optionsElement;
  }, overscan: 12 }), [m10, d13] = (0, import_react86.useState)(0);
  n(() => {
    d13((i15) => i15 + 1);
  }, [e8]);
  let x10 = b9.getVirtualItems();
  return x10.length === 0 ? null : import_react86.default.createElement(Ne.Provider, { value: b9 }, import_react86.default.createElement("div", { style: { position: "relative", width: "100%", height: `${b9.getTotalSize()}px` }, ref: (i15) => {
    i15 && n13.activationTrigger !== 0 && n13.activeOptionIndex !== null && e8.length > n13.activeOptionIndex && b9.scrollToIndex(n13.activeOptionIndex);
  } }, x10.map((i15) => {
    var r18;
    return import_react86.default.createElement(import_react86.Fragment, { key: i15.key }, import_react86.default.cloneElement((r18 = t11.children) == null ? void 0 : r18.call(t11, { ...t11.slot, option: e8[i15.index] }), { key: `${m10}-${i15.key}`, "data-index": i15.index, "aria-setsize": e8.length, "aria-posinset": i15.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${i15.start}px)`, overflowAnchor: "none" } }));
  })));
}
var ae2 = (0, import_react86.createContext)(null);
ae2.displayName = "ComboboxDataContext";
function ne(t11) {
  let n13 = (0, import_react86.useContext)(ae2);
  if (n13 === null) {
    let e8 = new Error(`<${t11} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e8, ne), e8;
  }
  return n13;
}
function Rt(t11, n13) {
  return u2(n13.type, Pt, t11, n13);
}
var _t = import_react86.Fragment;
function ht(t11, n13) {
  var Oe4, Ce5;
  let e8 = a3(), { value: o17, defaultValue: f22, onChange: b9, form: m10, name: d13, by: x10, disabled: i15 = e8 || false, onClose: r18, __demoMode: l14 = false, multiple: S7 = false, immediate: R9 = false, virtual: s13 = null, nullable: D7, ...B3 } = t11, _9 = l2(f22), [I6 = S7 ? [] : void 0, O7] = T(o17, b9, _9), [P7, g6] = (0, import_react86.useReducer)(Rt, { dataRef: (0, import_react86.createRef)(), comboboxState: l14 ? 0 : 1, isTyping: false, options: [], virtual: s13 ? { options: s13.options, disabled: (Oe4 = s13.disabled) != null ? Oe4 : () => false } : null, activeOptionIndex: null, activationTrigger: 2, inputElement: null, buttonElement: null, optionsElement: null, __demoMode: l14 }), V6 = (0, import_react86.useRef)(false), w11 = (0, import_react86.useRef)({ static: false, hold: false }), T10 = u9(x10), $3 = o4((p6) => s13 ? x10 === null ? s13.options.indexOf(p6) : s13.options.findIndex((v4) => T10(v4, p6)) : P7.options.findIndex((v4) => T10(v4.dataRef.current.value, p6))), K4 = (0, import_react86.useCallback)((p6) => u2(u17.mode, { [1]: () => I6.some((v4) => T10(v4, p6)), [0]: () => T10(I6, p6) }), [I6]), Z4 = o4((p6) => P7.activeOptionIndex === $3(p6)), u17 = (0, import_react86.useMemo)(() => ({ ...P7, immediate: R9, optionsPropsRef: w11, value: I6, defaultValue: _9, disabled: i15, mode: S7 ? 1 : 0, virtual: s13 ? P7.virtual : null, get activeOptionIndex() {
    if (V6.current && P7.activeOptionIndex === null && (s13 ? s13.options.length > 0 : P7.options.length > 0)) {
      if (s13) {
        let v4 = s13.options.findIndex((z4) => {
          var se4, Ee3;
          return !((Ee3 = (se4 = s13.disabled) == null ? void 0 : se4.call(s13, z4)) != null && Ee3);
        });
        if (v4 !== -1)
          return v4;
      }
      let p6 = P7.options.findIndex((v4) => !v4.dataRef.current.disabled);
      if (p6 !== -1)
        return p6;
    }
    return P7.activeOptionIndex;
  }, calculateIndex: $3, compare: T10, isSelected: K4, isActive: Z4 }), [I6, _9, i15, S7, l14, P7, s13]);
  n(() => {
    var p6;
    s13 && g6({ type: 7, options: s13.options, disabled: (p6 = s13.disabled) != null ? p6 : null });
  }, [s13, s13 == null ? void 0 : s13.options, s13 == null ? void 0 : s13.disabled]), n(() => {
    P7.dataRef.current = u17;
  }, [u17]);
  let X4 = u17.comboboxState === 0;
  R3(X4, [u17.buttonElement, u17.inputElement, u17.optionsElement], () => C9.closeCombobox());
  let N4 = (0, import_react86.useMemo)(() => {
    var p6, v4, z4;
    return { open: u17.comboboxState === 0, disabled: i15, activeIndex: u17.activeOptionIndex, activeOption: u17.activeOptionIndex === null ? null : u17.virtual ? u17.virtual.options[(p6 = u17.activeOptionIndex) != null ? p6 : 0] : (z4 = (v4 = u17.options[u17.activeOptionIndex]) == null ? void 0 : v4.dataRef.current.value) != null ? z4 : null, value: I6 };
  }, [u17, i15, I6]), U8 = o4(() => {
    if (u17.activeOptionIndex !== null) {
      if (C9.setIsTyping(false), u17.virtual)
        j9(u17.virtual.options[u17.activeOptionIndex]);
      else {
        let { dataRef: p6 } = u17.options[u17.activeOptionIndex];
        j9(p6.current.value);
      }
      C9.goToOption(c9.Specific, u17.activeOptionIndex);
    }
  }), y9 = o4(() => {
    g6({ type: 0 }), V6.current = true;
  }), G7 = o4(() => {
    g6({ type: 1 }), V6.current = false, r18 == null || r18();
  }), ue5 = o4((p6) => {
    g6({ type: 3, isTyping: p6 });
  }), Y4 = o4((p6, v4, z4) => (V6.current = false, p6 === c9.Specific ? g6({ type: 2, focus: c9.Specific, idx: v4, trigger: z4 }) : g6({ type: 2, focus: p6, trigger: z4 }))), Q6 = o4((p6, v4) => (g6({ type: 4, payload: { id: p6, dataRef: v4 } }), () => {
    u17.isActive(v4.current.value) && (V6.current = true), g6({ type: 5, id: p6 });
  })), j9 = o4((p6) => u2(u17.mode, { [0]() {
    return O7 == null ? void 0 : O7(p6);
  }, [1]() {
    let v4 = u17.value.slice(), z4 = v4.findIndex((se4) => T10(se4, p6));
    return z4 === -1 ? v4.push(p6) : v4.splice(z4, 1), O7 == null ? void 0 : O7(v4);
  } })), h7 = o4((p6) => {
    g6({ type: 6, trigger: p6 });
  }), pe4 = o4((p6) => {
    g6({ type: 8, element: p6 });
  }), a20 = o4((p6) => {
    g6({ type: 9, element: p6 });
  }), k5 = o4((p6) => {
    g6({ type: 10, element: p6 });
  }), C9 = (0, import_react86.useMemo)(() => ({ onChange: j9, registerOption: Q6, goToOption: Y4, setIsTyping: ue5, closeCombobox: G7, openCombobox: y9, setActivationTrigger: h7, selectActiveOption: U8, setInputElement: pe4, setButtonElement: a20, setOptionsElement: k5 }), []), [H13, E12] = K2(), L6 = n13 === null ? {} : { ref: n13 }, J7 = (0, import_react86.useCallback)(() => {
    if (_9 !== void 0)
      return O7 == null ? void 0 : O7(_9);
  }, [O7, _9]), ke4 = L();
  return import_react86.default.createElement(E12, { value: H13, props: { htmlFor: (Ce5 = u17.inputElement) == null ? void 0 : Ce5.id }, slot: { open: u17.comboboxState === 0, disabled: i15 } }, import_react86.default.createElement(Me, null, import_react86.default.createElement(ye2.Provider, { value: C9 }, import_react86.default.createElement(ae2.Provider, { value: u17 }, import_react86.default.createElement(c8, { value: u2(u17.comboboxState, { [0]: i11.Open, [1]: i11.Closed }) }, d13 != null && import_react86.default.createElement(j2, { disabled: i15, data: I6 != null ? { [d13]: I6 } : {}, form: m10, onReset: J7 }), ke4({ ourProps: L6, theirProps: B3, slot: N4, defaultTag: _t, name: "Combobox" }))))));
}
var Mt = "input";
function Dt(t11, n13) {
  var Y4, Q6, j9, h7, pe4;
  let e8 = ne("Combobox.Input"), o17 = le("Combobox.Input"), f22 = (0, import_react51.useId)(), b9 = u5(), { id: m10 = b9 || `headlessui-combobox-input-${f22}`, onChange: d13, displayValue: x10, disabled: i15 = e8.disabled || false, autoFocus: r18 = false, type: l14 = "text", ...S7 } = t11, R9 = (0, import_react86.useRef)(null), s13 = y(R9, n13, ye(), o17.setInputElement), D7 = n9(e8.inputElement), B3 = p(), _9 = o4(() => {
    o17.onChange(null), e8.optionsElement && (e8.optionsElement.scrollTop = 0), o17.goToOption(c9.Nothing);
  }), I6 = (0, import_react86.useMemo)(() => {
    var a20;
    return typeof x10 == "function" && e8.value !== void 0 ? (a20 = x10(e8.value)) != null ? a20 : "" : typeof e8.value == "string" ? e8.value : "";
  }, [e8.value, x10]);
  m8(([a20, k5], [C9, H13]) => {
    if (e8.isTyping)
      return;
    let E12 = R9.current;
    E12 && ((H13 === 0 && k5 === 1 || a20 !== C9) && (E12.value = a20), requestAnimationFrame(() => {
      if (e8.isTyping || !E12 || (D7 == null ? void 0 : D7.activeElement) !== E12)
        return;
      let { selectionStart: L6, selectionEnd: J7 } = E12;
      Math.abs((J7 != null ? J7 : 0) - (L6 != null ? L6 : 0)) === 0 && L6 === 0 && E12.setSelectionRange(E12.value.length, E12.value.length);
    }));
  }, [I6, e8.comboboxState, D7, e8.isTyping]), m8(([a20], [k5]) => {
    if (a20 === 0 && k5 === 1) {
      if (e8.isTyping)
        return;
      let C9 = R9.current;
      if (!C9)
        return;
      let H13 = C9.value, { selectionStart: E12, selectionEnd: L6, selectionDirection: J7 } = C9;
      C9.value = "", C9.value = H13, J7 !== null ? C9.setSelectionRange(E12, L6, J7) : C9.setSelectionRange(E12, L6);
    }
  }, [e8.comboboxState]);
  let O7 = (0, import_react86.useRef)(false), P7 = o4(() => {
    O7.current = true;
  }), g6 = o4(() => {
    B3.nextFrame(() => {
      O7.current = false;
    });
  }), V6 = o4((a20) => {
    switch (o17.setIsTyping(true), a20.key) {
      case o8.Enter:
        if (e8.comboboxState !== 0 || O7.current)
          return;
        if (a20.preventDefault(), a20.stopPropagation(), e8.activeOptionIndex === null) {
          o17.closeCombobox();
          return;
        }
        o17.selectActiveOption(), e8.mode === 0 && o17.closeCombobox();
        break;
      case o8.ArrowDown:
        return a20.preventDefault(), a20.stopPropagation(), u2(e8.comboboxState, { [0]: () => o17.goToOption(c9.Next), [1]: () => o17.openCombobox() });
      case o8.ArrowUp:
        return a20.preventDefault(), a20.stopPropagation(), u2(e8.comboboxState, { [0]: () => o17.goToOption(c9.Previous), [1]: () => {
          (0, import_react_dom8.flushSync)(() => o17.openCombobox()), e8.value || o17.goToOption(c9.Last);
        } });
      case o8.Home:
        if (a20.shiftKey)
          break;
        return a20.preventDefault(), a20.stopPropagation(), o17.goToOption(c9.First);
      case o8.PageUp:
        return a20.preventDefault(), a20.stopPropagation(), o17.goToOption(c9.First);
      case o8.End:
        if (a20.shiftKey)
          break;
        return a20.preventDefault(), a20.stopPropagation(), o17.goToOption(c9.Last);
      case o8.PageDown:
        return a20.preventDefault(), a20.stopPropagation(), o17.goToOption(c9.Last);
      case o8.Escape:
        return e8.comboboxState !== 0 ? void 0 : (a20.preventDefault(), e8.optionsElement && !e8.optionsPropsRef.current.static && a20.stopPropagation(), e8.mode === 0 && e8.value === null && _9(), o17.closeCombobox());
      case o8.Tab:
        if (e8.comboboxState !== 0)
          return;
        e8.mode === 0 && e8.activationTrigger !== 1 && o17.selectActiveOption(), o17.closeCombobox();
        break;
    }
  }), w11 = o4((a20) => {
    d13 == null || d13(a20), e8.mode === 0 && a20.target.value === "" && _9(), o17.openCombobox();
  }), T10 = o4((a20) => {
    var C9, H13, E12;
    let k5 = (C9 = a20.relatedTarget) != null ? C9 : r12.find((L6) => L6 !== a20.currentTarget);
    if (!((H13 = e8.optionsElement) != null && H13.contains(k5)) && !((E12 = e8.buttonElement) != null && E12.contains(k5)) && e8.comboboxState === 0)
      return a20.preventDefault(), e8.mode === 0 && e8.value === null && _9(), o17.closeCombobox();
  }), $3 = o4((a20) => {
    var C9, H13, E12;
    let k5 = (C9 = a20.relatedTarget) != null ? C9 : r12.find((L6) => L6 !== a20.currentTarget);
    (H13 = e8.buttonElement) != null && H13.contains(k5) || (E12 = e8.optionsElement) != null && E12.contains(k5) || e8.disabled || e8.immediate && e8.comboboxState !== 0 && B3.microTask(() => {
      (0, import_react_dom8.flushSync)(() => o17.openCombobox()), o17.setActivationTrigger(1);
    });
  }), K4 = I(), Z4 = U2(), { isFocused: u17, focusProps: X4 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r18 }), { isHovered: N4, hoverProps: U8 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i15 }), y9 = (0, import_react86.useMemo)(() => ({ open: e8.comboboxState === 0, disabled: i15, hover: N4, focus: u17, autofocus: r18 }), [e8, N4, u17, r18, i15]), G7 = _2({ ref: s13, id: m10, role: "combobox", type: l14, "aria-controls": (Y4 = e8.optionsElement) == null ? void 0 : Y4.id, "aria-expanded": e8.comboboxState === 0, "aria-activedescendant": e8.activeOptionIndex === null ? void 0 : e8.virtual ? (Q6 = e8.options.find((a20) => !a20.dataRef.current.disabled && e8.compare(a20.dataRef.current.value, e8.virtual.options[e8.activeOptionIndex]))) == null ? void 0 : Q6.id : (j9 = e8.options[e8.activeOptionIndex]) == null ? void 0 : j9.id, "aria-labelledby": K4, "aria-describedby": Z4, "aria-autocomplete": "list", defaultValue: (pe4 = (h7 = t11.defaultValue) != null ? h7 : e8.defaultValue !== void 0 ? x10 == null ? void 0 : x10(e8.defaultValue) : null) != null ? pe4 : e8.defaultValue, disabled: i15 || void 0, autoFocus: r18, onCompositionStart: P7, onCompositionEnd: g6, onKeyDown: V6, onChange: w11, onFocus: $3, onBlur: T10 }, X4, U8);
  return L()({ ourProps: G7, theirProps: S7, slot: y9, defaultTag: Mt, name: "Combobox.Input" });
}
var Ft = "button";
function Vt(t11, n13) {
  var w11;
  let e8 = ne("Combobox.Button"), o17 = le("Combobox.Button"), f22 = y(n13, o17.setButtonElement), b9 = (0, import_react51.useId)(), { id: m10 = `headlessui-combobox-button-${b9}`, disabled: d13 = e8.disabled || false, autoFocus: x10 = false, ...i15 } = t11, r18 = i10(e8.inputElement), l14 = o4((T10) => {
    switch (T10.key) {
      case o8.Space:
      case o8.Enter:
        T10.preventDefault(), T10.stopPropagation(), e8.comboboxState === 1 && (0, import_react_dom8.flushSync)(() => o17.openCombobox()), r18();
        return;
      case o8.ArrowDown:
        T10.preventDefault(), T10.stopPropagation(), e8.comboboxState === 1 && ((0, import_react_dom8.flushSync)(() => o17.openCombobox()), e8.value || o17.goToOption(c9.First)), r18();
        return;
      case o8.ArrowUp:
        T10.preventDefault(), T10.stopPropagation(), e8.comboboxState === 1 && ((0, import_react_dom8.flushSync)(() => o17.openCombobox()), e8.value || o17.goToOption(c9.Last)), r18();
        return;
      case o8.Escape:
        if (e8.comboboxState !== 0)
          return;
        T10.preventDefault(), e8.optionsElement && !e8.optionsPropsRef.current.static && T10.stopPropagation(), (0, import_react_dom8.flushSync)(() => o17.closeCombobox()), r18();
        return;
      default:
        return;
    }
  }), S7 = o4((T10) => {
    T10.preventDefault(), !r5(T10.currentTarget) && (T10.button === g2.Left && (e8.comboboxState === 0 ? o17.closeCombobox() : o17.openCombobox()), r18());
  }), R9 = I([m10]), { isFocusVisible: s13, focusProps: D7 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: x10 }), { isHovered: B3, hoverProps: _9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: d13 }), { pressed: I6, pressProps: O7 } = w({ disabled: d13 }), P7 = (0, import_react86.useMemo)(() => ({ open: e8.comboboxState === 0, active: I6 || e8.comboboxState === 0, disabled: d13, value: e8.value, hover: B3, focus: s13 }), [e8, B3, s13, I6, d13]), g6 = _2({ ref: f22, id: m10, type: e6(t11, e8.buttonElement), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (w11 = e8.optionsElement) == null ? void 0 : w11.id, "aria-expanded": e8.comboboxState === 0, "aria-labelledby": R9, disabled: d13 || void 0, autoFocus: x10, onMouseDown: S7, onKeyDown: l14 }, D7, _9, O7);
  return L()({ ourProps: g6, theirProps: i15, slot: P7, defaultTag: Ft, name: "Combobox.Button" });
}
var Lt = "div";
var Bt = O.RenderStrategy | O.Static;
function wt(t11, n13) {
  var Y4, Q6, j9;
  let e8 = (0, import_react51.useId)(), { id: o17 = `headlessui-combobox-options-${e8}`, hold: f22 = false, anchor: b9, portal: m10 = false, modal: d13 = true, transition: x10 = false, ...i15 } = t11, r18 = ne("Combobox.Options"), l14 = le("Combobox.Options"), S7 = xe(b9);
  S7 && (m10 = true);
  let [R9, s13] = Re(S7), [D7, B3] = (0, import_react86.useState)(null), _9 = be(), I6 = y(n13, S7 ? R9 : null, l14.setOptionsElement, B3), O7 = n9(r18.optionsElement), P7 = u13(), [g6, V6] = x3(x10, D7, P7 !== null ? (P7 & i11.Open) === i11.Open : r18.comboboxState === 0);
  m6(g6, r18.inputElement, l14.closeCombobox);
  let w11 = r18.__demoMode ? false : d13 && r18.comboboxState === 0;
  f11(w11, O7);
  let T10 = r18.__demoMode ? false : d13 && r18.comboboxState === 0;
  y3(T10, { allowed: (0, import_react86.useCallback)(() => [r18.inputElement, r18.buttonElement, r18.optionsElement], [r18.inputElement, r18.buttonElement, r18.optionsElement]) }), n(() => {
    var h7;
    r18.optionsPropsRef.current.static = (h7 = t11.static) != null ? h7 : false;
  }, [r18.optionsPropsRef, t11.static]), n(() => {
    r18.optionsPropsRef.current.hold = f22;
  }, [r18.optionsPropsRef, f22]), F3(r18.comboboxState === 0, { container: r18.optionsElement, accept(h7) {
    return h7.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : h7.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(h7) {
    h7.setAttribute("role", "none");
  } });
  let $3 = I([(Y4 = r18.buttonElement) == null ? void 0 : Y4.id]), K4 = (0, import_react86.useMemo)(() => ({ open: r18.comboboxState === 0, option: void 0 }), [r18.comboboxState]), Z4 = o4(() => {
    l14.setActivationTrigger(0);
  }), u17 = o4((h7) => {
    h7.preventDefault(), l14.setActivationTrigger(0);
  }), X4 = _2(S7 ? _9() : {}, { "aria-labelledby": $3, role: "listbox", "aria-multiselectable": r18.mode === 1 ? true : void 0, id: o17, ref: I6, style: { ...i15.style, ...s13, "--input-width": d3(r18.inputElement, true).width, "--button-width": d3(r18.buttonElement, true).width }, onWheel: r18.activationTrigger === 0 ? void 0 : Z4, onMouseDown: u17, ...R4(V6) }), N4 = g6 && r18.comboboxState === 1, U8 = l7(N4, (Q6 = r18.virtual) == null ? void 0 : Q6.options), y9 = l7(N4, r18.value), G7 = o4((h7) => r18.compare(y9, h7));
  if (r18.virtual) {
    if (U8 === void 0)
      throw new Error("Missing `options` in virtual mode");
    Object.assign(i15, { children: import_react86.default.createElement(ae2.Provider, { value: U8 !== r18.virtual.options ? { ...r18, virtual: { ...r18.virtual, options: U8 } } : r18 }, import_react86.default.createElement(At, { slot: K4 }, i15.children)) });
  }
  let ue5 = L();
  return import_react86.default.createElement(re, { enabled: m10 ? t11.static || g6 : false }, import_react86.default.createElement(ae2.Provider, { value: r18.mode === 1 ? r18 : { ...r18, isSelected: G7 } }, ue5({ ourProps: X4, theirProps: { ...i15, children: import_react86.default.createElement(f13, { freeze: N4 }, typeof i15.children == "function" ? (j9 = i15.children) == null ? void 0 : j9.call(i15, K4) : i15.children) }, slot: K4, defaultTag: Lt, features: Bt, visible: g6, name: "Combobox.Options" })));
}
var Nt = "div";
function kt(t11, n13) {
  var u17, X4, N4, U8;
  let e8 = ne("Combobox.Option"), o17 = le("Combobox.Option"), f22 = (0, import_react51.useId)(), { id: b9 = `headlessui-combobox-option-${f22}`, value: m10, disabled: d13 = (N4 = (X4 = (u17 = e8.virtual) == null ? void 0 : u17.disabled) == null ? void 0 : X4.call(u17, m10)) != null ? N4 : false, order: x10 = null, ...i15 } = t11, r18 = i10(e8.inputElement), l14 = e8.virtual ? e8.activeOptionIndex === e8.calculateIndex(m10) : e8.activeOptionIndex === null ? false : ((U8 = e8.options[e8.activeOptionIndex]) == null ? void 0 : U8.id) === b9, S7 = e8.isSelected(m10), R9 = (0, import_react86.useRef)(null), s13 = s3({ disabled: d13, value: m10, domRef: R9, order: x10 }), D7 = (0, import_react86.useContext)(Ne), B3 = y(n13, R9, D7 ? D7.measureElement : null), _9 = o4(() => {
    o17.setIsTyping(false), o17.onChange(m10);
  });
  n(() => o17.registerOption(b9, s13), [s13, b9]);
  let I6 = (0, import_react86.useRef)(!(e8.virtual || e8.__demoMode));
  n(() => {
    if (!e8.virtual && !e8.__demoMode)
      return o2().requestAnimationFrame(() => {
        I6.current = true;
      });
  }, [e8.virtual, e8.__demoMode]), n(() => {
    if (I6.current && e8.comboboxState === 0 && l14 && e8.activationTrigger !== 0)
      return o2().requestAnimationFrame(() => {
        var y9, G7;
        (G7 = (y9 = R9.current) == null ? void 0 : y9.scrollIntoView) == null || G7.call(y9, { block: "nearest" });
      });
  }, [R9, l14, e8.comboboxState, e8.activationTrigger, e8.activeOptionIndex]);
  let O7 = o4((y9) => {
    y9.preventDefault(), y9.button === g2.Left && (d13 || (_9(), n8() || requestAnimationFrame(() => r18()), e8.mode === 0 && o17.closeCombobox()));
  }), P7 = o4(() => {
    if (d13)
      return o17.goToOption(c9.Nothing);
    let y9 = e8.calculateIndex(m10);
    o17.goToOption(c9.Specific, y9);
  }), g6 = u11(), V6 = o4((y9) => g6.update(y9)), w11 = o4((y9) => {
    if (!g6.wasMoved(y9) || d13 || l14)
      return;
    let G7 = e8.calculateIndex(m10);
    o17.goToOption(c9.Specific, G7, 0);
  }), T10 = o4((y9) => {
    g6.wasMoved(y9) && (d13 || l14 && (e8.optionsPropsRef.current.hold || o17.goToOption(c9.Nothing)));
  }), $3 = (0, import_react86.useMemo)(() => ({ active: l14, focus: l14, selected: S7, disabled: d13 }), [l14, S7, d13]), K4 = { id: b9, ref: B3, role: "option", tabIndex: d13 === true ? void 0 : -1, "aria-disabled": d13 === true ? true : void 0, "aria-selected": S7, disabled: void 0, onMouseDown: O7, onFocus: P7, onPointerEnter: V6, onMouseEnter: V6, onPointerMove: w11, onMouseMove: w11, onPointerLeave: T10, onMouseLeave: T10 };
  return L()({ ourProps: K4, theirProps: i15, slot: $3, defaultTag: Nt, name: "Combobox.Option" });
}
var Ht = K(ht);
var Ut = K(Vt);
var Gt = K(Dt);
var zt = Q;
var Kt = K(wt);
var jt = K(kt);
var Ho = Object.assign(Ht, { Input: Gt, Button: Ut, Label: zt, Options: Kt, Option: jt });

// ../../node_modules/@headlessui/react/dist/components/data-interactive/data-interactive.js
var import_react87 = __toESM(require_react(), 1);
var E8 = import_react87.Fragment;
function d9(o17, n13) {
  let { ...s13 } = o17, e8 = false, { isFocusVisible: t11, focusProps: p6 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), { isHovered: r18, hoverProps: i15 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), { pressed: a20, pressProps: T10 } = w({ disabled: e8 }), l14 = _2({ ref: n13 }, p6, i15, T10), c15 = (0, import_react87.useMemo)(() => ({ hover: r18, focus: t11, active: a20 }), [r18, t11, a20]);
  return L()({ ourProps: l14, theirProps: s13, slot: c15, defaultTag: E8, name: "DataInteractive" });
}
var x4 = K(d9);

// ../../node_modules/@headlessui/react/dist/components/dialog/dialog.js
var import_react94 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-escape.js
function a13(o17, r18 = typeof document != "undefined" ? document.defaultView : null, t11) {
  let n13 = x2(o17, "escape");
  E5(r18, "keydown", (e8) => {
    n13 && (e8.defaultPrevented || e8.key === o8.Escape && t11(e8));
  });
}

// ../../node_modules/@headlessui/react/dist/hooks/use-is-touch-device.js
var import_react88 = __toESM(require_react(), 1);
function f17() {
  var t11;
  let [e8] = (0, import_react88.useState)(() => typeof window != "undefined" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [o17, c15] = (0, import_react88.useState)((t11 = e8 == null ? void 0 : e8.matches) != null ? t11 : false);
  return n(() => {
    if (!e8)
      return;
    function n13(r18) {
      c15(r18.matches);
    }
    return e8.addEventListener("change", n13), () => e8.removeEventListener("change", n13);
  }, [e8]), o17;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-root-containers.js
var import_react89 = __toESM(require_react(), 1);
function R7({ defaultContainers: l14 = [], portals: n13, mainTreeNode: o17 } = {}) {
  let r18 = n9(o17), u17 = o4(() => {
    var i15, c15;
    let t11 = [];
    for (let e8 of l14)
      e8 !== null && (e8 instanceof HTMLElement ? t11.push(e8) : "current" in e8 && e8.current instanceof HTMLElement && t11.push(e8.current));
    if (n13 != null && n13.current)
      for (let e8 of n13.current)
        t11.push(e8);
    for (let e8 of (i15 = r18 == null ? void 0 : r18.querySelectorAll("html > *, body > *")) != null ? i15 : [])
      e8 !== document.body && e8 !== document.head && e8 instanceof HTMLElement && e8.id !== "headlessui-portal-root" && (o17 && (e8.contains(o17) || e8.contains((c15 = o17 == null ? void 0 : o17.getRootNode()) == null ? void 0 : c15.host)) || t11.some((m10) => e8.contains(m10)) || t11.push(e8));
    return t11;
  });
  return { resolveContainers: u17, contains: o4((t11) => u17().some((i15) => i15.contains(t11))) };
}
var a14 = (0, import_react89.createContext)(null);
function O4({ children: l14, node: n13 }) {
  let [o17, r18] = (0, import_react89.useState)(null), u17 = b5(n13 != null ? n13 : o17);
  return import_react89.default.createElement(a14.Provider, { value: u17 }, l14, u17 === null && import_react89.default.createElement(f4, { features: s4.Hidden, ref: (t11) => {
    var i15, c15;
    if (t11) {
      for (let e8 of (c15 = (i15 = u(t11)) == null ? void 0 : i15.querySelectorAll("html > *, body > *")) != null ? c15 : [])
        if (e8 !== document.body && e8 !== document.head && e8 instanceof HTMLElement && e8 != null && e8.contains(t11)) {
          r18(e8);
          break;
        }
    }
  } }));
}
function b5(l14 = null) {
  var n13;
  return (n13 = (0, import_react89.useContext)(a14)) != null ? n13 : l14;
}

// ../../node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
var import_react92 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react90 = __toESM(require_react(), 1);
function f19() {
  let e8 = (0, import_react90.useRef)(false);
  return n(() => (e8.current = true, () => {
    e8.current = false;
  }), []), e8;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var import_react91 = __toESM(require_react(), 1);
var a15 = ((r18) => (r18[r18.Forwards = 0] = "Forwards", r18[r18.Backwards = 1] = "Backwards", r18))(a15 || {});
function u16() {
  let e8 = (0, import_react91.useRef)(0);
  return s5(true, "keydown", (r18) => {
    r18.key === "Tab" && (e8.current = r18.shiftKey ? 1 : 0);
  }, true), e8;
}

// ../../node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
function U4(o17) {
  if (!o17)
    return /* @__PURE__ */ new Set();
  if (typeof o17 == "function")
    return new Set(o17());
  let e8 = /* @__PURE__ */ new Set();
  for (let t11 of o17.current)
    t11.current instanceof HTMLElement && e8.add(t11.current);
  return e8;
}
var Z = "div";
var x5 = ((n13) => (n13[n13.None = 0] = "None", n13[n13.InitialFocus = 1] = "InitialFocus", n13[n13.TabLock = 2] = "TabLock", n13[n13.FocusLock = 4] = "FocusLock", n13[n13.RestoreFocus = 8] = "RestoreFocus", n13[n13.AutoFocus = 16] = "AutoFocus", n13))(x5 || {});
function $2(o17, e8) {
  let t11 = (0, import_react92.useRef)(null), r18 = y(t11, e8), { initialFocus: s13, initialFocusFallback: a20, containers: n13, features: u17 = 15, ...f22 } = o17;
  l9() || (u17 = 0);
  let l14 = n9(t11);
  ee2(u17, { ownerDocument: l14 });
  let i15 = te3(u17, { ownerDocument: l14, container: t11, initialFocus: s13, initialFocusFallback: a20 });
  re2(u17, { ownerDocument: l14, container: t11, containers: n13, previousActiveElement: i15 });
  let R9 = u16(), g6 = o4((c15) => {
    let m10 = t11.current;
    if (!m10)
      return;
    ((G7) => G7())(() => {
      u2(R9.current, { [a15.Forwards]: () => {
        P6(m10, F2.First, { skipElements: [c15.relatedTarget, a20] });
      }, [a15.Backwards]: () => {
        P6(m10, F2.Last, { skipElements: [c15.relatedTarget, a20] });
      } });
    });
  }), v4 = x2(!!(u17 & 2), "focus-trap#tab-lock"), N4 = p(), F6 = (0, import_react92.useRef)(false), k5 = { ref: r18, onKeyDown(c15) {
    c15.key == "Tab" && (F6.current = true, N4.requestAnimationFrame(() => {
      F6.current = false;
    }));
  }, onBlur(c15) {
    if (!(u17 & 4))
      return;
    let m10 = U4(n13);
    t11.current instanceof HTMLElement && m10.add(t11.current);
    let d13 = c15.relatedTarget;
    d13 instanceof HTMLElement && d13.dataset.headlessuiFocusGuard !== "true" && (I4(m10, d13) || (F6.current ? P6(t11.current, u2(R9.current, { [a15.Forwards]: () => F2.Next, [a15.Backwards]: () => F2.Previous }) | F2.WrapAround, { relativeTo: c15.target }) : c15.target instanceof HTMLElement && I2(c15.target)));
  } }, B3 = L();
  return import_react92.default.createElement(import_react92.default.Fragment, null, v4 && import_react92.default.createElement(f4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: g6, features: s4.Focusable }), B3({ ourProps: k5, theirProps: f22, defaultTag: Z, name: "FocusTrap" }), v4 && import_react92.default.createElement(f4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: g6, features: s4.Focusable }));
}
var D5 = K($2);
var ye3 = Object.assign(D5, { features: x5 });
function w6(o17 = true) {
  let e8 = (0, import_react92.useRef)(r12.slice());
  return m8(([t11], [r18]) => {
    r18 === true && t11 === false && t(() => {
      e8.current.splice(0);
    }), r18 === false && t11 === true && (e8.current = r12.slice());
  }, [o17, r12, e8]), o4(() => {
    var t11;
    return (t11 = e8.current.find((r18) => r18 != null && r18.isConnected)) != null ? t11 : null;
  });
}
function ee2(o17, { ownerDocument: e8 }) {
  let t11 = !!(o17 & 8), r18 = w6(t11);
  m8(() => {
    t11 || (e8 == null ? void 0 : e8.activeElement) === (e8 == null ? void 0 : e8.body) && I2(r18());
  }, [t11]), c10(() => {
    t11 && I2(r18());
  });
}
function te3(o17, { ownerDocument: e8, container: t11, initialFocus: r18, initialFocusFallback: s13 }) {
  let a20 = (0, import_react92.useRef)(null), n13 = x2(!!(o17 & 1), "focus-trap#initial-focus"), u17 = f19();
  return m8(() => {
    if (o17 === 0)
      return;
    if (!n13) {
      s13 != null && s13.current && I2(s13.current);
      return;
    }
    let f22 = t11.current;
    f22 && t(() => {
      if (!u17.current)
        return;
      let l14 = e8 == null ? void 0 : e8.activeElement;
      if (r18 != null && r18.current) {
        if ((r18 == null ? void 0 : r18.current) === l14) {
          a20.current = l14;
          return;
        }
      } else if (f22.contains(l14)) {
        a20.current = l14;
        return;
      }
      if (r18 != null && r18.current)
        I2(r18.current);
      else {
        if (o17 & 16) {
          if (P6(f22, F2.First | F2.AutoFocus) !== T5.Error)
            return;
        } else if (P6(f22, F2.First) !== T5.Error)
          return;
        if (s13 != null && s13.current && (I2(s13.current), (e8 == null ? void 0 : e8.activeElement) === s13.current))
          return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      a20.current = e8 == null ? void 0 : e8.activeElement;
    });
  }, [s13, n13, o17]), a20;
}
function re2(o17, { ownerDocument: e8, container: t11, containers: r18, previousActiveElement: s13 }) {
  let a20 = f19(), n13 = !!(o17 & 4);
  E5(e8 == null ? void 0 : e8.defaultView, "focus", (u17) => {
    if (!n13 || !a20.current)
      return;
    let f22 = U4(r18);
    t11.current instanceof HTMLElement && f22.add(t11.current);
    let l14 = s13.current;
    if (!l14)
      return;
    let i15 = u17.target;
    i15 && i15 instanceof HTMLElement ? I4(f22, i15) ? (s13.current = i15, I2(i15)) : (u17.preventDefault(), u17.stopPropagation(), I2(l14)) : I2(s13.current);
  }, true);
}
function I4(o17, e8) {
  for (let t11 of o17)
    if (t11.contains(e8))
      return true;
  return false;
}

// ../../node_modules/@headlessui/react/dist/components/transition/transition.js
var import_react93 = __toESM(require_react(), 1);
function ue2(e8) {
  var t11;
  return !!(e8.enter || e8.enterFrom || e8.enterTo || e8.leave || e8.leaveFrom || e8.leaveTo) || ((t11 = e8.as) != null ? t11 : de2) !== import_react93.Fragment || import_react93.default.Children.count(e8.children) === 1;
}
var w7 = (0, import_react93.createContext)(null);
w7.displayName = "TransitionContext";
var _e = ((n13) => (n13.Visible = "visible", n13.Hidden = "hidden", n13))(_e || {});
function De() {
  let e8 = (0, import_react93.useContext)(w7);
  if (e8 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e8;
}
function He() {
  let e8 = (0, import_react93.useContext)(M7);
  if (e8 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e8;
}
var M7 = (0, import_react93.createContext)(null);
M7.displayName = "NestingContext";
function U5(e8) {
  return "children" in e8 ? U5(e8.children) : e8.current.filter(({ el: t11 }) => t11.current !== null).filter(({ state: t11 }) => t11 === "visible").length > 0;
}
function Te2(e8, t11) {
  let n13 = s3(e8), l14 = (0, import_react93.useRef)([]), S7 = f19(), R9 = p(), d13 = o4((o17, i15 = A.Hidden) => {
    let a20 = l14.current.findIndex(({ el: s13 }) => s13 === o17);
    a20 !== -1 && (u2(i15, { [A.Unmount]() {
      l14.current.splice(a20, 1);
    }, [A.Hidden]() {
      l14.current[a20].state = "hidden";
    } }), R9.microTask(() => {
      var s13;
      !U5(l14) && S7.current && ((s13 = n13.current) == null || s13.call(n13));
    }));
  }), y9 = o4((o17) => {
    let i15 = l14.current.find(({ el: a20 }) => a20 === o17);
    return i15 ? i15.state !== "visible" && (i15.state = "visible") : l14.current.push({ el: o17, state: "visible" }), () => d13(o17, A.Unmount);
  }), p6 = (0, import_react93.useRef)([]), c15 = (0, import_react93.useRef)(Promise.resolve()), C9 = (0, import_react93.useRef)({ enter: [], leave: [] }), h7 = o4((o17, i15, a20) => {
    p6.current.splice(0), t11 && (t11.chains.current[i15] = t11.chains.current[i15].filter(([s13]) => s13 !== o17)), t11 == null || t11.chains.current[i15].push([o17, new Promise((s13) => {
      p6.current.push(s13);
    })]), t11 == null || t11.chains.current[i15].push([o17, new Promise((s13) => {
      Promise.all(C9.current[i15].map(([r18, f22]) => f22)).then(() => s13());
    })]), i15 === "enter" ? c15.current = c15.current.then(() => t11 == null ? void 0 : t11.wait.current).then(() => a20(i15)) : a20(i15);
  }), g6 = o4((o17, i15, a20) => {
    Promise.all(C9.current[i15].splice(0).map(([s13, r18]) => r18)).then(() => {
      var s13;
      (s13 = p6.current.shift()) == null || s13();
    }).then(() => a20(i15));
  });
  return (0, import_react93.useMemo)(() => ({ children: l14, register: y9, unregister: d13, onStart: h7, onStop: g6, wait: c15, chains: C9 }), [y9, d13, l14, h7, g6, C9, c15]);
}
var de2 = import_react93.Fragment;
var fe2 = O.RenderStrategy;
function Ae3(e8, t11) {
  var ee7, te6;
  let { transition: n13 = true, beforeEnter: l14, afterEnter: S7, beforeLeave: R9, afterLeave: d13, enter: y9, enterFrom: p6, enterTo: c15, entered: C9, leave: h7, leaveFrom: g6, leaveTo: o17, ...i15 } = e8, [a20, s13] = (0, import_react93.useState)(null), r18 = (0, import_react93.useRef)(null), f22 = ue2(e8), j9 = y(...f22 ? [r18, t11, s13] : t11 === null ? [] : [t11]), H13 = (ee7 = i15.unmount) == null || ee7 ? A.Unmount : A.Hidden, { show: u17, appear: z4, initial: K4 } = De(), [v4, G7] = (0, import_react93.useState)(u17 ? "visible" : "hidden"), Q6 = He(), { register: A7, unregister: I6 } = Q6;
  n(() => A7(r18), [A7, r18]), n(() => {
    if (H13 === A.Hidden && r18.current) {
      if (u17 && v4 !== "visible") {
        G7("visible");
        return;
      }
      return u2(v4, { ["hidden"]: () => I6(r18), ["visible"]: () => A7(r18) });
    }
  }, [v4, r18, A7, I6, u17, H13]);
  let B3 = l9();
  n(() => {
    if (f22 && B3 && v4 === "visible" && r18.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [r18, v4, B3, f22]);
  let ce5 = K4 && !z4, Y4 = z4 && u17 && K4, W5 = (0, import_react93.useRef)(false), L6 = Te2(() => {
    W5.current || (G7("hidden"), I6(r18));
  }, Q6), Z4 = o4((k5) => {
    W5.current = true;
    let F6 = k5 ? "enter" : "leave";
    L6.onStart(r18, F6, (_9) => {
      _9 === "enter" ? l14 == null || l14() : _9 === "leave" && (R9 == null || R9());
    });
  }), $3 = o4((k5) => {
    let F6 = k5 ? "enter" : "leave";
    W5.current = false, L6.onStop(r18, F6, (_9) => {
      _9 === "enter" ? S7 == null || S7() : _9 === "leave" && (d13 == null || d13());
    }), F6 === "leave" && !U5(L6) && (G7("hidden"), I6(r18));
  });
  (0, import_react93.useEffect)(() => {
    f22 && n13 || (Z4(u17), $3(u17));
  }, [u17, f22, n13]);
  let pe4 = (() => !(!n13 || !f22 || !B3 || ce5))(), [, T10] = x3(pe4, a20, u17, { start: Z4, end: $3 }), Ce5 = m2({ ref: j9, className: ((te6 = t3(i15.className, Y4 && y9, Y4 && p6, T10.enter && y9, T10.enter && T10.closed && p6, T10.enter && !T10.closed && c15, T10.leave && h7, T10.leave && !T10.closed && g6, T10.leave && T10.closed && o17, !T10.transition && u17 && C9)) == null ? void 0 : te6.trim()) || void 0, ...R4(T10) }), N4 = 0;
  v4 === "visible" && (N4 |= i11.Open), v4 === "hidden" && (N4 |= i11.Closed), T10.enter && (N4 |= i11.Opening), T10.leave && (N4 |= i11.Closing);
  let he3 = L();
  return import_react93.default.createElement(M7.Provider, { value: L6 }, import_react93.default.createElement(c8, { value: N4 }, he3({ ourProps: Ce5, theirProps: i15, defaultTag: de2, features: fe2, visible: v4 === "visible", name: "Transition.Child" })));
}
function Ie(e8, t11) {
  let { show: n13, appear: l14 = false, unmount: S7 = true, ...R9 } = e8, d13 = (0, import_react93.useRef)(null), y9 = ue2(e8), p6 = y(...y9 ? [d13, t11] : t11 === null ? [] : [t11]);
  l9();
  let c15 = u13();
  if (n13 === void 0 && c15 !== null && (n13 = (c15 & i11.Open) === i11.Open), n13 === void 0)
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [C9, h7] = (0, import_react93.useState)(n13 ? "visible" : "hidden"), g6 = Te2(() => {
    n13 || h7("hidden");
  }), [o17, i15] = (0, import_react93.useState)(true), a20 = (0, import_react93.useRef)([n13]);
  n(() => {
    o17 !== false && a20.current[a20.current.length - 1] !== n13 && (a20.current.push(n13), i15(false));
  }, [a20, n13]);
  let s13 = (0, import_react93.useMemo)(() => ({ show: n13, appear: l14, initial: o17 }), [n13, l14, o17]);
  n(() => {
    n13 ? h7("visible") : !U5(g6) && d13.current !== null && h7("hidden");
  }, [n13, g6]);
  let r18 = { unmount: S7 }, f22 = o4(() => {
    var u17;
    o17 && i15(false), (u17 = e8.beforeEnter) == null || u17.call(e8);
  }), j9 = o4(() => {
    var u17;
    o17 && i15(false), (u17 = e8.beforeLeave) == null || u17.call(e8);
  }), H13 = L();
  return import_react93.default.createElement(M7.Provider, { value: g6 }, import_react93.default.createElement(w7.Provider, { value: s13 }, H13({ ourProps: { ...r18, as: import_react93.Fragment, children: import_react93.default.createElement(me, { ref: p6, ...r18, ...R9, beforeEnter: f22, beforeLeave: j9 }) }, theirProps: {}, defaultTag: import_react93.Fragment, features: fe2, visible: C9 === "visible", name: "Transition" })));
}
function Le(e8, t11) {
  let n13 = (0, import_react93.useContext)(w7) !== null, l14 = u13() !== null;
  return import_react93.default.createElement(import_react93.default.Fragment, null, !n13 && l14 ? import_react93.default.createElement(X2, { ref: t11, ...e8 }) : import_react93.default.createElement(me, { ref: t11, ...e8 }));
}
var X2 = K(Ie);
var me = K(Ae3);
var Fe2 = K(Le);
var ze2 = Object.assign(X2, { Child: Fe2, Root: X2 });

// ../../node_modules/@headlessui/react/dist/components/dialog/dialog.js
var Oe = ((o17) => (o17[o17.Open = 0] = "Open", o17[o17.Closed = 1] = "Closed", o17))(Oe || {});
var he = ((t11) => (t11[t11.SetTitleId = 0] = "SetTitleId", t11))(he || {});
var Se = { [0](e8, t11) {
  return e8.titleId === t11.id ? e8 : { ...e8, titleId: t11.id };
} };
var k3 = (0, import_react94.createContext)(null);
k3.displayName = "DialogContext";
function O6(e8) {
  let t11 = (0, import_react94.useContext)(k3);
  if (t11 === null) {
    let o17 = new Error(`<${e8} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o17, O6), o17;
  }
  return t11;
}
function Ie2(e8, t11) {
  return u2(t11.type, Se, e8, t11);
}
var V4 = K(function(t11, o17) {
  let a20 = (0, import_react51.useId)(), { id: l14 = `headlessui-dialog-${a20}`, open: i15, onClose: p6, initialFocus: d13, role: s13 = "dialog", autoFocus: f22 = true, __demoMode: u17 = false, unmount: P7 = false, ...h7 } = t11, R9 = (0, import_react94.useRef)(false);
  s13 = function() {
    return s13 === "dialog" || s13 === "alertdialog" ? s13 : (R9.current || (R9.current = true, console.warn(`Invalid role [${s13}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let c15 = u13();
  i15 === void 0 && c15 !== null && (i15 = (c15 & i11.Open) === i11.Open);
  let T10 = (0, import_react94.useRef)(null), S7 = y(T10, o17), F6 = n9(T10), g6 = i15 ? 0 : 1, [b9, q4] = (0, import_react94.useReducer)(Ie2, { titleId: null, descriptionId: null, panelRef: (0, import_react94.createRef)() }), m10 = o4(() => p6(false)), w11 = o4((r18) => q4({ type: 0, id: r18 })), D7 = l9() ? g6 === 0 : false, [z4, Q6] = te(), Z4 = { get current() {
    var r18;
    return (r18 = b9.panelRef.current) != null ? r18 : T10.current;
  } }, v4 = b5(), { resolveContainers: I6 } = R7({ mainTreeNode: v4, portals: z4, defaultContainers: [Z4] }), B3 = c15 !== null ? (c15 & i11.Closing) === i11.Closing : false;
  y3(u17 || B3 ? false : D7, { allowed: o4(() => {
    var r18, H13;
    return [(H13 = (r18 = T10.current) == null ? void 0 : r18.closest("[data-headlessui-portal]")) != null ? H13 : null];
  }), disallowed: o4(() => {
    var r18;
    return [(r18 = v4 == null ? void 0 : v4.closest("body > *:not(#headlessui-portal-root)")) != null ? r18 : null];
  }) }), R3(D7, I6, (r18) => {
    r18.preventDefault(), m10();
  }), a13(D7, F6 == null ? void 0 : F6.defaultView, (r18) => {
    r18.preventDefault(), r18.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), m10();
  }), f11(u17 || B3 ? false : D7, F6, I6), m6(D7, T10, m10);
  let [ee7, te6] = w3(), oe3 = (0, import_react94.useMemo)(() => [{ dialogState: g6, close: m10, setTitleId: w11, unmount: P7 }, b9], [g6, b9, m10, w11, P7]), U8 = (0, import_react94.useMemo)(() => ({ open: g6 === 0 }), [g6]), ne4 = { ref: S7, id: l14, role: s13, tabIndex: -1, "aria-modal": u17 ? void 0 : g6 === 0 ? true : void 0, "aria-labelledby": b9.titleId, "aria-describedby": ee7, unmount: P7 }, re5 = !f17(), y9 = x5.None;
  D7 && !u17 && (y9 |= x5.RestoreFocus, y9 |= x5.TabLock, f22 && (y9 |= x5.AutoFocus), re5 && (y9 |= x5.InitialFocus));
  let le4 = L();
  return import_react94.default.createElement(s7, null, import_react94.default.createElement(l10, { force: true }, import_react94.default.createElement(re, null, import_react94.default.createElement(k3.Provider, { value: oe3 }, import_react94.default.createElement(X, { target: T10 }, import_react94.default.createElement(l10, { force: false }, import_react94.default.createElement(te6, { slot: U8 }, import_react94.default.createElement(Q6, null, import_react94.default.createElement(ye3, { initialFocus: d13, initialFocusFallback: T10, containers: I6, features: y9 }, import_react94.default.createElement(C4, { value: m10 }, le4({ ourProps: ne4, theirProps: h7, slot: U8, defaultTag: Me2, features: Ge2, visible: g6 === 0, name: "Dialog" })))))))))));
});
var Me2 = "div";
var Ge2 = O.RenderStrategy | O.Static;
function ke(e8, t11) {
  let { transition: o17 = false, open: a20, ...l14 } = e8, i15 = u13(), p6 = e8.hasOwnProperty("open") || i15 !== null, d13 = e8.hasOwnProperty("onClose");
  if (!p6 && !d13)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!p6)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!d13)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!i15 && typeof e8.open != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${e8.open}`);
  if (typeof e8.onClose != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${e8.onClose}`);
  return (a20 !== void 0 || o17) && !l14.static ? import_react94.default.createElement(O4, null, import_react94.default.createElement(ze2, { show: a20, transition: o17, unmount: l14.unmount }, import_react94.default.createElement(V4, { ref: t11, ...l14 }))) : import_react94.default.createElement(O4, null, import_react94.default.createElement(V4, { ref: t11, open: a20, ...l14 }));
}
var we = "div";
function Be(e8, t11) {
  let o17 = (0, import_react51.useId)(), { id: a20 = `headlessui-dialog-panel-${o17}`, transition: l14 = false, ...i15 } = e8, [{ dialogState: p6, unmount: d13 }, s13] = O6("Dialog.Panel"), f22 = y(t11, s13.panelRef), u17 = (0, import_react94.useMemo)(() => ({ open: p6 === 0 }), [p6]), P7 = o4((S7) => {
    S7.stopPropagation();
  }), h7 = { ref: f22, id: a20, onClick: P7 }, R9 = l14 ? Fe2 : import_react94.Fragment, c15 = l14 ? { unmount: d13 } : {}, T10 = L();
  return import_react94.default.createElement(R9, { ...c15 }, T10({ ourProps: h7, theirProps: i15, slot: u17, defaultTag: we, name: "Dialog.Panel" }));
}
var Ue2 = "div";
function He2(e8, t11) {
  let { transition: o17 = false, ...a20 } = e8, [{ dialogState: l14, unmount: i15 }] = O6("Dialog.Backdrop"), p6 = (0, import_react94.useMemo)(() => ({ open: l14 === 0 }), [l14]), d13 = { ref: t11, "aria-hidden": true }, s13 = o17 ? Fe2 : import_react94.Fragment, f22 = o17 ? { unmount: i15 } : {}, u17 = L();
  return import_react94.default.createElement(s13, { ...f22 }, u17({ ourProps: d13, theirProps: a20, slot: p6, defaultTag: Ue2, name: "Dialog.Backdrop" }));
}
var Ne2 = "h2";
function We(e8, t11) {
  let o17 = (0, import_react51.useId)(), { id: a20 = `headlessui-dialog-title-${o17}`, ...l14 } = e8, [{ dialogState: i15, setTitleId: p6 }] = O6("Dialog.Title"), d13 = y(t11);
  (0, import_react94.useEffect)(() => (p6(a20), () => p6(null)), [a20, p6]);
  let s13 = (0, import_react94.useMemo)(() => ({ open: i15 === 0 }), [i15]), f22 = { ref: d13, id: a20 };
  return L()({ ourProps: f22, theirProps: l14, slot: s13, defaultTag: Ne2, name: "Dialog.Title" });
}
var $e = K(ke);
var je = K(Be);
var Dt2 = K(He2);
var Ye = K(We);
var yt = Object.assign($e, { Panel: je, Title: Ye, Description: H4 });

// ../../node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var import_react96 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/start-transition.js
var import_react95 = __toESM(require_react(), 1);
var t10;
var a16 = (t10 = import_react95.default.startTransition) != null ? t10 : function(i15) {
  i15();
};

// ../../node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var ce3 = ((l14) => (l14[l14.Open = 0] = "Open", l14[l14.Closed = 1] = "Closed", l14))(ce3 || {});
var de4 = ((n13) => (n13[n13.ToggleDisclosure = 0] = "ToggleDisclosure", n13[n13.CloseDisclosure = 1] = "CloseDisclosure", n13[n13.SetButtonId = 2] = "SetButtonId", n13[n13.SetPanelId = 3] = "SetPanelId", n13[n13.SetButtonElement = 4] = "SetButtonElement", n13[n13.SetPanelElement = 5] = "SetPanelElement", n13))(de4 || {});
var Te3 = { [0]: (e8) => ({ ...e8, disclosureState: u2(e8.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e8) => e8.disclosureState === 1 ? e8 : { ...e8, disclosureState: 1 }, [2](e8, t11) {
  return e8.buttonId === t11.buttonId ? e8 : { ...e8, buttonId: t11.buttonId };
}, [3](e8, t11) {
  return e8.panelId === t11.panelId ? e8 : { ...e8, panelId: t11.panelId };
}, [4](e8, t11) {
  return e8.buttonElement === t11.element ? e8 : { ...e8, buttonElement: t11.element };
}, [5](e8, t11) {
  return e8.panelElement === t11.element ? e8 : { ...e8, panelElement: t11.element };
} };
var _6 = (0, import_react96.createContext)(null);
_6.displayName = "DisclosureContext";
function M8(e8) {
  let t11 = (0, import_react96.useContext)(_6);
  if (t11 === null) {
    let l14 = new Error(`<${e8} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l14, M8), l14;
  }
  return t11;
}
var F4 = (0, import_react96.createContext)(null);
F4.displayName = "DisclosureAPIContext";
function J4(e8) {
  let t11 = (0, import_react96.useContext)(F4);
  if (t11 === null) {
    let l14 = new Error(`<${e8} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l14, J4), l14;
  }
  return t11;
}
var H8 = (0, import_react96.createContext)(null);
H8.displayName = "DisclosurePanelContext";
function fe3() {
  return (0, import_react96.useContext)(H8);
}
function me2(e8, t11) {
  return u2(t11.type, Te3, e8, t11);
}
var De2 = import_react96.Fragment;
function ye4(e8, t11) {
  let { defaultOpen: l14 = false, ...p6 } = e8, i15 = (0, import_react96.useRef)(null), c15 = y(t11, T2((a20) => {
    i15.current = a20;
  }, e8.as === void 0 || e8.as === import_react96.Fragment)), n13 = (0, import_react96.useReducer)(me2, { disclosureState: l14 ? 0 : 1, buttonElement: null, panelElement: null, buttonId: null, panelId: null }), [{ disclosureState: o17, buttonId: r18 }, m10] = n13, s13 = o4((a20) => {
    m10({ type: 1 });
    let d13 = u(i15);
    if (!d13 || !r18)
      return;
    let T10 = (() => a20 ? a20 instanceof HTMLElement ? a20 : a20.current instanceof HTMLElement ? a20.current : d13.getElementById(r18) : d13.getElementById(r18))();
    T10 == null || T10.focus();
  }), E12 = (0, import_react96.useMemo)(() => ({ close: s13 }), [s13]), f22 = (0, import_react96.useMemo)(() => ({ open: o17 === 0, close: s13 }), [o17, s13]), D7 = { ref: c15 }, S7 = L();
  return import_react96.default.createElement(_6.Provider, { value: n13 }, import_react96.default.createElement(F4.Provider, { value: E12 }, import_react96.default.createElement(C4, { value: s13 }, import_react96.default.createElement(c8, { value: u2(o17, { [0]: i11.Open, [1]: i11.Closed }) }, S7({ ourProps: D7, theirProps: p6, slot: f22, defaultTag: De2, name: "Disclosure" })))));
}
var Pe2 = "button";
function Ee(e8, t11) {
  let l14 = (0, import_react51.useId)(), { id: p6 = `headlessui-disclosure-button-${l14}`, disabled: i15 = false, autoFocus: c15 = false, ...n13 } = e8, [o17, r18] = M8("Disclosure.Button"), m10 = fe3(), s13 = m10 === null ? false : m10 === o17.panelId, E12 = (0, import_react96.useRef)(null), f22 = y(E12, t11, o4((u17) => {
    if (!s13)
      return r18({ type: 4, element: u17 });
  }));
  (0, import_react96.useEffect)(() => {
    if (!s13)
      return r18({ type: 2, buttonId: p6 }), () => {
        r18({ type: 2, buttonId: null });
      };
  }, [p6, r18, s13]);
  let D7 = o4((u17) => {
    var g6;
    if (s13) {
      if (o17.disclosureState === 1)
        return;
      switch (u17.key) {
        case o8.Space:
        case o8.Enter:
          u17.preventDefault(), u17.stopPropagation(), r18({ type: 0 }), (g6 = o17.buttonElement) == null || g6.focus();
          break;
      }
    } else
      switch (u17.key) {
        case o8.Space:
        case o8.Enter:
          u17.preventDefault(), u17.stopPropagation(), r18({ type: 0 });
          break;
      }
  }), S7 = o4((u17) => {
    switch (u17.key) {
      case o8.Space:
        u17.preventDefault();
        break;
    }
  }), a20 = o4((u17) => {
    var g6;
    r5(u17.currentTarget) || i15 || (s13 ? (r18({ type: 0 }), (g6 = o17.buttonElement) == null || g6.focus()) : r18({ type: 0 }));
  }), { isFocusVisible: d13, focusProps: T10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c15 }), { isHovered: b9, hoverProps: h7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i15 }), { pressed: U8, pressProps: N4 } = w({ disabled: i15 }), X4 = (0, import_react96.useMemo)(() => ({ open: o17.disclosureState === 0, hover: b9, active: U8, disabled: i15, focus: d13, autofocus: c15 }), [o17, b9, U8, d13, i15, c15]), k5 = e6(e8, o17.buttonElement), V6 = s13 ? _2({ ref: f22, type: k5, disabled: i15 || void 0, autoFocus: c15, onKeyDown: D7, onClick: a20 }, T10, h7, N4) : _2({ ref: f22, id: p6, type: k5, "aria-expanded": o17.disclosureState === 0, "aria-controls": o17.panelElement ? o17.panelId : void 0, disabled: i15 || void 0, autoFocus: c15, onKeyDown: D7, onKeyUp: S7, onClick: a20 }, T10, h7, N4);
  return L()({ ourProps: V6, theirProps: n13, slot: X4, defaultTag: Pe2, name: "Disclosure.Button" });
}
var Se2 = "div";
var ge2 = O.RenderStrategy | O.Static;
function Ae4(e8, t11) {
  let l14 = (0, import_react51.useId)(), { id: p6 = `headlessui-disclosure-panel-${l14}`, transition: i15 = false, ...c15 } = e8, [n13, o17] = M8("Disclosure.Panel"), { close: r18 } = J4("Disclosure.Panel"), [m10, s13] = (0, import_react96.useState)(null), E12 = y(t11, o4((b9) => {
    a16(() => o17({ type: 5, element: b9 }));
  }), s13);
  (0, import_react96.useEffect)(() => (o17({ type: 3, panelId: p6 }), () => {
    o17({ type: 3, panelId: null });
  }), [p6, o17]);
  let f22 = u13(), [D7, S7] = x3(i15, m10, f22 !== null ? (f22 & i11.Open) === i11.Open : n13.disclosureState === 0), a20 = (0, import_react96.useMemo)(() => ({ open: n13.disclosureState === 0, close: r18 }), [n13.disclosureState, r18]), d13 = { ref: E12, id: p6, ...R4(S7) }, T10 = L();
  return import_react96.default.createElement(s7, null, import_react96.default.createElement(H8.Provider, { value: n13.panelId }, T10({ ourProps: d13, theirProps: c15, slot: a20, defaultTag: Se2, features: ge2, visible: D7, name: "Disclosure.Panel" })));
}
var be2 = K(ye4);
var Ce = K(Ee);
var Re2 = K(Ae4);
var je2 = Object.assign(be2, { Button: Ce, Panel: Re2 });

// ../../node_modules/@headlessui/react/dist/components/field/field.js
var import_react97 = __toESM(require_react(), 1);
var _7 = "div";
function c13(d13, l14) {
  let t11 = `headlessui-control-${(0, import_react51.useId)()}`, [s13, p6] = K2(), [n13, a20] = w3(), m10 = a3(), { disabled: e8 = m10 || false, ...i15 } = d13, o17 = (0, import_react97.useMemo)(() => ({ disabled: e8 }), [e8]), F6 = { ref: l14, disabled: e8 || void 0, "aria-disabled": e8 || void 0 }, T10 = L();
  return import_react97.default.createElement(l, { value: e8 }, import_react97.default.createElement(p6, { value: s13 }, import_react97.default.createElement(a20, { value: n13 }, import_react97.default.createElement(f6, { id: t11 }, T10({ ourProps: F6, theirProps: { ...i15, children: import_react97.default.createElement(W, null, typeof i15.children == "function" ? i15.children(o17) : i15.children) }, slot: o17, defaultTag: _7, name: "Field" })))));
}
var H9 = K(c13);

// ../../node_modules/@headlessui/react/dist/components/fieldset/fieldset.js
var import_react99 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-resolved-tag.js
var import_react98 = __toESM(require_react(), 1);
function l11(t11) {
  let e8 = typeof t11 == "string" ? t11 : void 0, [s13, o17] = (0, import_react98.useState)(e8);
  return [e8 != null ? e8 : s13, (0, import_react98.useCallback)((n13) => {
    e8 || n13 instanceof HTMLElement && o17(n13.tagName.toLowerCase());
  }, [e8])];
}

// ../../node_modules/@headlessui/react/dist/components/fieldset/fieldset.js
var d11 = "fieldset";
function _8(t11, a20) {
  var s13;
  let i15 = a3(), { disabled: e8 = i15 || false, ...p6 } = t11, [n13, T10] = l11((s13 = t11.as) != null ? s13 : d11), l14 = y(a20, T10), [r18, f22] = K2(), m10 = (0, import_react99.useMemo)(() => ({ disabled: e8 }), [e8]), y9 = n13 === "fieldset" ? { ref: l14, "aria-labelledby": r18, disabled: e8 || void 0 } : { ref: l14, role: "group", "aria-labelledby": r18, "aria-disabled": e8 || void 0 }, F6 = L();
  return import_react99.default.createElement(l, { value: e8 }, import_react99.default.createElement(f22, null, F6({ ourProps: y9, theirProps: p6, slot: m10, defaultTag: d11, name: "Fieldset" })));
}
var G5 = K(_8);

// ../../node_modules/@headlessui/react/dist/components/input/input.js
var import_react100 = __toESM(require_react(), 1);
var x7 = "input";
function h6(p6, s13) {
  let a20 = (0, import_react51.useId)(), l14 = u5(), i15 = a3(), { id: d13 = l14 || `headlessui-input-${a20}`, disabled: e8 = i15 || false, autoFocus: o17 = false, invalid: t11 = false, ...u17 } = p6, f22 = I(), m10 = U2(), { isFocused: r18, focusProps: T10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o17 }), { isHovered: n13, hoverProps: b9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), y9 = _2({ ref: s13, id: d13, "aria-labelledby": f22, "aria-describedby": m10, "aria-invalid": t11 ? "" : void 0, disabled: e8 || void 0, autoFocus: o17 }, T10, b9), I6 = (0, import_react100.useMemo)(() => ({ disabled: e8, invalid: t11, hover: n13, focus: r18, autofocus: o17 }), [e8, t11, n13, r18, o17]);
  return L()({ ourProps: y9, theirProps: u17, slot: I6, defaultTag: x7, name: "Input" });
}
var S6 = K(h6);

// ../../node_modules/@headlessui/react/dist/components/legend/legend.js
var import_react101 = __toESM(require_react(), 1);
function o15(t11, n13) {
  return import_react101.default.createElement(Q, { as: "div", ref: n13, ...t11 });
}
var d12 = K(o15);

// ../../node_modules/@headlessui/react/dist/components/listbox/listbox.js
var import_react104 = __toESM(require_react(), 1);
var import_react_dom9 = __toESM(require_react_dom(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-did-element-move.js
var import_react102 = __toESM(require_react(), 1);
function s9(n13, t11) {
  let e8 = (0, import_react102.useRef)({ left: 0, top: 0 });
  if (n(() => {
    if (!t11)
      return;
    let r18 = t11.getBoundingClientRect();
    r18 && (e8.current = r18);
  }, [n13, t11]), t11 == null || !n13 || t11 === document.activeElement)
    return false;
  let o17 = t11.getBoundingClientRect();
  return o17.top !== e8.current.top || o17.left !== e8.current.left;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react103 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/get-text-value.js
var a18 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o16(e8) {
  var r18, i15;
  let n13 = (r18 = e8.innerText) != null ? r18 : "", t11 = e8.cloneNode(true);
  if (!(t11 instanceof HTMLElement))
    return n13;
  let u17 = false;
  for (let f22 of t11.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    f22.remove(), u17 = true;
  let l14 = u17 ? (i15 = t11.innerText) != null ? i15 : "" : n13;
  return a18.test(l14) && (l14 = l14.replace(a18, "")), l14;
}
function g5(e8) {
  let n13 = e8.getAttribute("aria-label");
  if (typeof n13 == "string")
    return n13.trim();
  let t11 = e8.getAttribute("aria-labelledby");
  if (t11) {
    let u17 = t11.split(" ").map((l14) => {
      let r18 = document.getElementById(l14);
      if (r18) {
        let i15 = r18.getAttribute("aria-label");
        return typeof i15 == "string" ? i15.trim() : o16(r18).trim();
      }
      return null;
    }).filter(Boolean);
    if (u17.length > 0)
      return u17.join(", ");
  }
  return o16(e8).trim();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
function s10(c15) {
  let t11 = (0, import_react103.useRef)(""), r18 = (0, import_react103.useRef)("");
  return o4(() => {
    let e8 = c15.current;
    if (!e8)
      return "";
    let u17 = e8.innerText;
    if (t11.current === u17)
      return r18.current;
    let n13 = g5(e8).trim().toLowerCase();
    return t11.current = u17, r18.current = n13, n13;
  });
}

// ../../node_modules/@headlessui/react/dist/components/listbox/listbox.js
var gt = ((o17) => (o17[o17.Open = 0] = "Open", o17[o17.Closed = 1] = "Closed", o17))(gt || {});
var Lt2 = ((o17) => (o17[o17.Single = 0] = "Single", o17[o17.Multi = 1] = "Multi", o17))(Lt2 || {});
var St2 = ((o17) => (o17[o17.Pointer = 0] = "Pointer", o17[o17.Other = 1] = "Other", o17))(St2 || {});
var Et2 = ((n13) => (n13[n13.OpenListbox = 0] = "OpenListbox", n13[n13.CloseListbox = 1] = "CloseListbox", n13[n13.GoToOption = 2] = "GoToOption", n13[n13.Search = 3] = "Search", n13[n13.ClearSearch = 4] = "ClearSearch", n13[n13.RegisterOption = 5] = "RegisterOption", n13[n13.UnregisterOption = 6] = "UnregisterOption", n13[n13.SetButtonElement = 7] = "SetButtonElement", n13[n13.SetOptionsElement = 8] = "SetOptionsElement", n13))(Et2 || {});
function be3(e8, i15 = (o17) => o17) {
  let o17 = e8.activeOptionIndex !== null ? e8.options[e8.activeOptionIndex] : null, r18 = _4(i15(e8.options.slice()), (m10) => m10.dataRef.current.domRef.current), a20 = o17 ? r18.indexOf(o17) : null;
  return a20 === -1 && (a20 = null), { options: r18, activeOptionIndex: a20 };
}
var Pt2 = { [1](e8) {
  return e8.dataRef.current.disabled || e8.listboxState === 1 ? e8 : { ...e8, activeOptionIndex: null, listboxState: 1, __demoMode: false };
}, [0](e8) {
  if (e8.dataRef.current.disabled || e8.listboxState === 0)
    return e8;
  let i15 = e8.activeOptionIndex, { isSelected: o17 } = e8.dataRef.current, r18 = e8.options.findIndex((a20) => o17(a20.dataRef.current.value));
  return r18 !== -1 && (i15 = r18), { ...e8, listboxState: 0, activeOptionIndex: i15, __demoMode: false };
}, [2](e8, i15) {
  var m10, x10, d13, p6, n13;
  if (e8.dataRef.current.disabled || e8.listboxState === 1)
    return e8;
  let o17 = { ...e8, searchQuery: "", activationTrigger: (m10 = i15.trigger) != null ? m10 : 1, __demoMode: false };
  if (i15.focus === c9.Nothing)
    return { ...o17, activeOptionIndex: null };
  if (i15.focus === c9.Specific)
    return { ...o17, activeOptionIndex: e8.options.findIndex((u17) => u17.id === i15.id) };
  if (i15.focus === c9.Previous) {
    let u17 = e8.activeOptionIndex;
    if (u17 !== null) {
      let P7 = e8.options[u17].dataRef.current.domRef, t11 = f14(i15, { resolveItems: () => e8.options, resolveActiveIndex: () => e8.activeOptionIndex, resolveId: (s13) => s13.id, resolveDisabled: (s13) => s13.dataRef.current.disabled });
      if (t11 !== null) {
        let s13 = e8.options[t11].dataRef.current.domRef;
        if (((x10 = P7.current) == null ? void 0 : x10.previousElementSibling) === s13.current || ((d13 = s13.current) == null ? void 0 : d13.previousElementSibling) === null)
          return { ...o17, activeOptionIndex: t11 };
      }
    }
  } else if (i15.focus === c9.Next) {
    let u17 = e8.activeOptionIndex;
    if (u17 !== null) {
      let P7 = e8.options[u17].dataRef.current.domRef, t11 = f14(i15, { resolveItems: () => e8.options, resolveActiveIndex: () => e8.activeOptionIndex, resolveId: (s13) => s13.id, resolveDisabled: (s13) => s13.dataRef.current.disabled });
      if (t11 !== null) {
        let s13 = e8.options[t11].dataRef.current.domRef;
        if (((p6 = P7.current) == null ? void 0 : p6.nextElementSibling) === s13.current || ((n13 = s13.current) == null ? void 0 : n13.nextElementSibling) === null)
          return { ...o17, activeOptionIndex: t11 };
      }
    }
  }
  let r18 = be3(e8), a20 = f14(i15, { resolveItems: () => r18.options, resolveActiveIndex: () => r18.activeOptionIndex, resolveId: (u17) => u17.id, resolveDisabled: (u17) => u17.dataRef.current.disabled });
  return { ...o17, ...r18, activeOptionIndex: a20 };
}, [3]: (e8, i15) => {
  if (e8.dataRef.current.disabled || e8.listboxState === 1)
    return e8;
  let r18 = e8.searchQuery !== "" ? 0 : 1, a20 = e8.searchQuery + i15.value.toLowerCase(), x10 = (e8.activeOptionIndex !== null ? e8.options.slice(e8.activeOptionIndex + r18).concat(e8.options.slice(0, e8.activeOptionIndex + r18)) : e8.options).find((p6) => {
    var n13;
    return !p6.dataRef.current.disabled && ((n13 = p6.dataRef.current.textValue) == null ? void 0 : n13.startsWith(a20));
  }), d13 = x10 ? e8.options.indexOf(x10) : -1;
  return d13 === -1 || d13 === e8.activeOptionIndex ? { ...e8, searchQuery: a20 } : { ...e8, searchQuery: a20, activeOptionIndex: d13, activationTrigger: 1 };
}, [4](e8) {
  return e8.dataRef.current.disabled || e8.listboxState === 1 || e8.searchQuery === "" ? e8 : { ...e8, searchQuery: "" };
}, [5]: (e8, i15) => {
  let o17 = { id: i15.id, dataRef: i15.dataRef }, r18 = be3(e8, (a20) => [...a20, o17]);
  return e8.activeOptionIndex === null && e8.dataRef.current.isSelected(i15.dataRef.current.value) && (r18.activeOptionIndex = r18.options.indexOf(o17)), { ...e8, ...r18 };
}, [6]: (e8, i15) => {
  let o17 = be3(e8, (r18) => {
    let a20 = r18.findIndex((m10) => m10.id === i15.id);
    return a20 !== -1 && r18.splice(a20, 1), r18;
  });
  return { ...e8, ...o17, activationTrigger: 1 };
}, [7]: (e8, i15) => e8.buttonElement === i15.element ? e8 : { ...e8, buttonElement: i15.element }, [8]: (e8, i15) => e8.optionsElement === i15.element ? e8 : { ...e8, optionsElement: i15.element } };
var Te4 = (0, import_react104.createContext)(null);
Te4.displayName = "ListboxActionsContext";
function Z2(e8) {
  let i15 = (0, import_react104.useContext)(Te4);
  if (i15 === null) {
    let o17 = new Error(`<${e8} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o17, Z2), o17;
  }
  return i15;
}
var ee3 = (0, import_react104.createContext)(null);
ee3.displayName = "ListboxDataContext";
function Q3(e8) {
  let i15 = (0, import_react104.useContext)(ee3);
  if (i15 === null) {
    let o17 = new Error(`<${e8} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o17, Q3), o17;
  }
  return i15;
}
function Rt2(e8, i15) {
  return u2(i15.type, Pt2, e8, i15);
}
var At2 = import_react104.Fragment;
function ht2(e8, i15) {
  var me4;
  let o17 = a3(), { value: r18, defaultValue: a20, form: m10, name: x10, onChange: d13, by: p6, invalid: n13 = false, disabled: u17 = o17 || false, horizontal: P7 = false, multiple: t11 = false, __demoMode: s13 = false, ...F6 } = e8;
  const M9 = P7 ? "horizontal" : "vertical";
  let h7 = y(i15), D7 = l2(a20), [O7 = t11 ? [] : void 0, g6] = T(r18, d13, D7), [R9, y9] = (0, import_react104.useReducer)(Rt2, { dataRef: (0, import_react104.createRef)(), listboxState: s13 ? 0 : 1, options: [], searchQuery: "", activeOptionIndex: null, activationTrigger: 1, optionsVisible: false, buttonElement: null, optionsElement: null, __demoMode: s13 }), B3 = (0, import_react104.useRef)({ static: false, hold: false }), w11 = (0, import_react104.useRef)(/* @__PURE__ */ new Map()), _9 = u9(p6), b9 = (0, import_react104.useCallback)((f22) => u2(c15.mode, { [1]: () => O7.some((S7) => _9(S7, f22)), [0]: () => _9(O7, f22) }), [O7]), c15 = (0, import_react104.useMemo)(() => ({ ...R9, value: O7, disabled: u17, invalid: n13, mode: t11 ? 1 : 0, orientation: M9, compare: _9, isSelected: b9, optionsPropsRef: B3, listRef: w11 }), [O7, u17, n13, t11, R9, w11]);
  n(() => {
    R9.dataRef.current = c15;
  }, [c15]);
  let N4 = c15.listboxState === 0;
  R3(N4, [c15.buttonElement, c15.optionsElement], (f22, S7) => {
    var C9;
    y9({ type: 1 }), A2(S7, h5.Loose) || (f22.preventDefault(), (C9 = c15.buttonElement) == null || C9.focus());
  });
  let L6 = (0, import_react104.useMemo)(() => ({ open: c15.listboxState === 0, disabled: u17, invalid: n13, value: O7 }), [c15, u17, O7, n13]), H13 = o4((f22) => {
    let S7 = c15.options.find((C9) => C9.id === f22);
    S7 && K4(S7.dataRef.current.value);
  }), te6 = o4(() => {
    if (c15.activeOptionIndex !== null) {
      let { dataRef: f22, id: S7 } = c15.options[c15.activeOptionIndex];
      K4(f22.current.value), y9({ type: 2, focus: c9.Specific, id: S7 });
    }
  }), oe3 = o4(() => y9({ type: 0 })), X4 = o4(() => y9({ type: 1 })), J7 = p(), ne4 = o4((f22, S7, C9) => {
    J7.dispose(), J7.microTask(() => f22 === c9.Specific ? y9({ type: 2, focus: c9.Specific, id: S7, trigger: C9 }) : y9({ type: 2, focus: f22, trigger: C9 }));
  }), ie5 = o4((f22, S7) => (y9({ type: 5, id: f22, dataRef: S7 }), () => y9({ type: 6, id: f22 }))), K4 = o4((f22) => u2(c15.mode, { [0]() {
    return g6 == null ? void 0 : g6(f22);
  }, [1]() {
    let S7 = c15.value.slice(), C9 = S7.findIndex((Re4) => _9(Re4, f22));
    return C9 === -1 ? S7.push(f22) : S7.splice(C9, 1), g6 == null ? void 0 : g6(S7);
  } })), re5 = o4((f22) => y9({ type: 3, value: f22 })), $3 = o4(() => y9({ type: 4 })), q4 = o4((f22) => {
    y9({ type: 7, element: f22 });
  }), l14 = o4((f22) => {
    y9({ type: 8, element: f22 });
  }), I6 = (0, import_react104.useMemo)(() => ({ onChange: K4, registerOption: ie5, goToOption: ne4, closeListbox: X4, openListbox: oe3, selectActiveOption: te6, selectOption: H13, search: re5, clearSearch: $3, setButtonElement: q4, setOptionsElement: l14 }), []), [G7, le4] = K2({ inherit: true }), Se5 = { ref: h7 }, Ee3 = (0, import_react104.useCallback)(() => {
    if (D7 !== void 0)
      return g6 == null ? void 0 : g6(D7);
  }, [g6, D7]), Pe4 = L();
  return import_react104.default.createElement(le4, { value: G7, props: { htmlFor: (me4 = c15.buttonElement) == null ? void 0 : me4.id }, slot: { open: c15.listboxState === 0, disabled: u17 } }, import_react104.default.createElement(Me, null, import_react104.default.createElement(Te4.Provider, { value: I6 }, import_react104.default.createElement(ee3.Provider, { value: c15 }, import_react104.default.createElement(c8, { value: u2(c15.listboxState, { [0]: i11.Open, [1]: i11.Closed }) }, x10 != null && O7 != null && import_react104.default.createElement(j2, { disabled: u17, data: { [x10]: O7 }, form: m10, onReset: Ee3 }), Pe4({ ourProps: Se5, theirProps: F6, slot: L6, defaultTag: At2, name: "Listbox" }))))));
}
var Dt3 = "button";
function _t2(e8, i15) {
  var N4;
  let o17 = Q3("Listbox.Button"), r18 = Z2("Listbox.Button"), a20 = (0, import_react51.useId)(), m10 = u5(), { id: x10 = m10 || `headlessui-listbox-button-${a20}`, disabled: d13 = o17.disabled || false, autoFocus: p6 = false, ...n13 } = e8, u17 = y(i15, ye(), r18.setButtonElement), P7 = Fe(), t11 = o4((L6) => {
    switch (L6.key) {
      case o8.Enter:
        p2(L6.currentTarget);
        break;
      case o8.Space:
      case o8.ArrowDown:
        L6.preventDefault(), (0, import_react_dom9.flushSync)(() => r18.openListbox()), o17.value || r18.goToOption(c9.First);
        break;
      case o8.ArrowUp:
        L6.preventDefault(), (0, import_react_dom9.flushSync)(() => r18.openListbox()), o17.value || r18.goToOption(c9.Last);
        break;
    }
  }), s13 = o4((L6) => {
    switch (L6.key) {
      case o8.Space:
        L6.preventDefault();
        break;
    }
  }), F6 = o4((L6) => {
    var H13;
    if (r5(L6.currentTarget))
      return L6.preventDefault();
    o17.listboxState === 0 ? ((0, import_react_dom9.flushSync)(() => r18.closeListbox()), (H13 = o17.buttonElement) == null || H13.focus({ preventScroll: true })) : (L6.preventDefault(), r18.openListbox());
  }), M9 = o4((L6) => L6.preventDefault()), h7 = I([x10]), D7 = U2(), { isFocusVisible: O7, focusProps: g6 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: p6 }), { isHovered: R9, hoverProps: y9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: d13 }), { pressed: B3, pressProps: w11 } = w({ disabled: d13 }), _9 = (0, import_react104.useMemo)(() => ({ open: o17.listboxState === 0, active: B3 || o17.listboxState === 0, disabled: d13, invalid: o17.invalid, value: o17.value, hover: R9, focus: O7, autofocus: p6 }), [o17.listboxState, o17.value, d13, R9, O7, B3, o17.invalid, p6]), b9 = _2(P7(), { ref: u17, id: x10, type: e6(e8, o17.buttonElement), "aria-haspopup": "listbox", "aria-controls": (N4 = o17.optionsElement) == null ? void 0 : N4.id, "aria-expanded": o17.listboxState === 0, "aria-labelledby": h7, "aria-describedby": D7, disabled: d13 || void 0, autoFocus: p6, onKeyDown: t11, onKeyUp: s13, onKeyPress: M9, onClick: F6 }, g6, y9, w11);
  return L()({ ourProps: b9, theirProps: n13, slot: _9, defaultTag: Dt3, name: "Listbox.Button" });
}
var Le2 = (0, import_react104.createContext)(false);
var It2 = "div";
var Ct2 = O.RenderStrategy | O.Static;
function Ft2(e8, i15) {
  var $3, q4;
  let o17 = (0, import_react51.useId)(), { id: r18 = `headlessui-listbox-options-${o17}`, anchor: a20, portal: m10 = false, modal: x10 = true, transition: d13 = false, ...p6 } = e8, n13 = xe(a20), [u17, P7] = (0, import_react104.useState)(null);
  n13 && (m10 = true);
  let t11 = Q3("Listbox.Options"), s13 = Z2("Listbox.Options"), F6 = n9(t11.optionsElement), M9 = u13(), [h7, D7] = x3(d13, u17, M9 !== null ? (M9 & i11.Open) === i11.Open : t11.listboxState === 0);
  m6(h7, t11.buttonElement, s13.closeListbox);
  let O7 = t11.__demoMode ? false : x10 && t11.listboxState === 0;
  f11(O7, F6);
  let g6 = t11.__demoMode ? false : x10 && t11.listboxState === 0;
  y3(g6, { allowed: (0, import_react104.useCallback)(() => [t11.buttonElement, t11.optionsElement], [t11.buttonElement, t11.optionsElement]) });
  let R9 = t11.listboxState !== 0, B3 = s9(R9, t11.buttonElement) ? false : h7, w11 = h7 && t11.listboxState === 1, _9 = l7(w11, t11.value), b9 = o4((l14) => t11.compare(_9, l14)), c15 = (0, import_react104.useMemo)(() => {
    var I6;
    if (n13 == null || !((I6 = n13 == null ? void 0 : n13.to) != null && I6.includes("selection")))
      return null;
    let l14 = t11.options.findIndex((G7) => b9(G7.dataRef.current.value));
    return l14 === -1 && (l14 = 0), l14;
  }, [n13, t11.options]), N4 = (() => {
    if (n13 == null)
      return;
    if (c15 === null)
      return { ...n13, inner: void 0 };
    let l14 = Array.from(t11.listRef.current.values());
    return { ...n13, inner: { listRef: { current: l14 }, index: c15 } };
  })(), [L6, H13] = Re(N4), te6 = be(), oe3 = y(i15, n13 ? L6 : null, s13.setOptionsElement, P7), X4 = p();
  (0, import_react104.useEffect)(() => {
    var I6;
    let l14 = t11.optionsElement;
    l14 && t11.listboxState === 0 && l14 !== ((I6 = u(l14)) == null ? void 0 : I6.activeElement) && (l14 == null || l14.focus({ preventScroll: true }));
  }, [t11.listboxState, t11.optionsElement]);
  let J7 = o4((l14) => {
    var I6, G7;
    switch (X4.dispose(), l14.key) {
      case o8.Space:
        if (t11.searchQuery !== "")
          return l14.preventDefault(), l14.stopPropagation(), s13.search(l14.key);
      case o8.Enter:
        if (l14.preventDefault(), l14.stopPropagation(), t11.activeOptionIndex !== null) {
          let { dataRef: le4 } = t11.options[t11.activeOptionIndex];
          s13.onChange(le4.current.value);
        }
        t11.mode === 0 && ((0, import_react_dom9.flushSync)(() => s13.closeListbox()), (I6 = t11.buttonElement) == null || I6.focus({ preventScroll: true }));
        break;
      case u2(t11.orientation, { vertical: o8.ArrowDown, horizontal: o8.ArrowRight }):
        return l14.preventDefault(), l14.stopPropagation(), s13.goToOption(c9.Next);
      case u2(t11.orientation, { vertical: o8.ArrowUp, horizontal: o8.ArrowLeft }):
        return l14.preventDefault(), l14.stopPropagation(), s13.goToOption(c9.Previous);
      case o8.Home:
      case o8.PageUp:
        return l14.preventDefault(), l14.stopPropagation(), s13.goToOption(c9.First);
      case o8.End:
      case o8.PageDown:
        return l14.preventDefault(), l14.stopPropagation(), s13.goToOption(c9.Last);
      case o8.Escape:
        l14.preventDefault(), l14.stopPropagation(), (0, import_react_dom9.flushSync)(() => s13.closeListbox()), (G7 = t11.buttonElement) == null || G7.focus({ preventScroll: true });
        return;
      case o8.Tab:
        l14.preventDefault(), l14.stopPropagation(), (0, import_react_dom9.flushSync)(() => s13.closeListbox()), j3(t11.buttonElement, l14.shiftKey ? F2.Previous : F2.Next);
        break;
      default:
        l14.key.length === 1 && (s13.search(l14.key), X4.setTimeout(() => s13.clearSearch(), 350));
        break;
    }
  }), ne4 = ($3 = t11.buttonElement) == null ? void 0 : $3.id, ie5 = (0, import_react104.useMemo)(() => ({ open: t11.listboxState === 0 }), [t11.listboxState]), K4 = _2(n13 ? te6() : {}, { id: r18, ref: oe3, "aria-activedescendant": t11.activeOptionIndex === null || (q4 = t11.options[t11.activeOptionIndex]) == null ? void 0 : q4.id, "aria-multiselectable": t11.mode === 1 ? true : void 0, "aria-labelledby": ne4, "aria-orientation": t11.orientation, onKeyDown: J7, role: "listbox", tabIndex: t11.listboxState === 0 ? 0 : void 0, style: { ...p6.style, ...H13, "--button-width": d3(t11.buttonElement, true).width }, ...R4(D7) }), re5 = L();
  return import_react104.default.createElement(re, { enabled: m10 ? e8.static || h7 : false }, import_react104.default.createElement(ee3.Provider, { value: t11.mode === 1 ? t11 : { ...t11, isSelected: b9 } }, re5({ ourProps: K4, theirProps: p6, slot: ie5, defaultTag: It2, features: Ct2, visible: B3, name: "Listbox.Options" })));
}
var Mt2 = "div";
function Bt2(e8, i15) {
  let o17 = (0, import_react51.useId)(), { id: r18 = `headlessui-listbox-option-${o17}`, disabled: a20 = false, value: m10, ...x10 } = e8, d13 = (0, import_react104.useContext)(Le2) === true, p6 = Q3("Listbox.Option"), n13 = Z2("Listbox.Option"), u17 = p6.activeOptionIndex !== null ? p6.options[p6.activeOptionIndex].id === r18 : false, P7 = p6.isSelected(m10), t11 = (0, import_react104.useRef)(null), s13 = s10(t11), F6 = s3({ disabled: a20, value: m10, domRef: t11, get textValue() {
    return s13();
  } }), M9 = y(i15, t11, (b9) => {
    b9 ? p6.listRef.current.set(r18, b9) : p6.listRef.current.delete(r18);
  });
  n(() => {
    if (!p6.__demoMode && p6.listboxState === 0 && u17 && p6.activationTrigger !== 0)
      return o2().requestAnimationFrame(() => {
        var b9, c15;
        (c15 = (b9 = t11.current) == null ? void 0 : b9.scrollIntoView) == null || c15.call(b9, { block: "nearest" });
      });
  }, [t11, u17, p6.__demoMode, p6.listboxState, p6.activationTrigger, p6.activeOptionIndex]), n(() => {
    if (!d13)
      return n13.registerOption(r18, F6);
  }, [F6, r18, d13]);
  let h7 = o4((b9) => {
    var c15;
    if (a20)
      return b9.preventDefault();
    n13.onChange(m10), p6.mode === 0 && ((0, import_react_dom9.flushSync)(() => n13.closeListbox()), (c15 = p6.buttonElement) == null || c15.focus({ preventScroll: true }));
  }), D7 = o4(() => {
    if (a20)
      return n13.goToOption(c9.Nothing);
    n13.goToOption(c9.Specific, r18);
  }), O7 = u11(), g6 = o4((b9) => {
    O7.update(b9), !a20 && (u17 || n13.goToOption(c9.Specific, r18, 0));
  }), R9 = o4((b9) => {
    O7.wasMoved(b9) && (a20 || u17 || n13.goToOption(c9.Specific, r18, 0));
  }), y9 = o4((b9) => {
    O7.wasMoved(b9) && (a20 || u17 && n13.goToOption(c9.Nothing));
  }), B3 = (0, import_react104.useMemo)(() => ({ active: u17, focus: u17, selected: P7, disabled: a20, selectedOption: P7 && d13 }), [u17, P7, a20, d13]), w11 = d13 ? {} : { id: r18, ref: M9, role: "option", tabIndex: a20 === true ? void 0 : -1, "aria-disabled": a20 === true ? true : void 0, "aria-selected": P7, disabled: void 0, onClick: h7, onFocus: D7, onPointerEnter: g6, onMouseEnter: g6, onPointerMove: R9, onMouseMove: R9, onPointerLeave: y9, onMouseLeave: y9 }, _9 = L();
  return !P7 && d13 ? null : _9({ ourProps: w11, theirProps: x10, slot: B3, defaultTag: Mt2, name: "Listbox.Option" });
}
var wt2 = import_react104.Fragment;
function kt2(e8, i15) {
  let { options: o17, placeholder: r18, ...a20 } = e8, x10 = { ref: y(i15) }, d13 = Q3("ListboxSelectedOption"), p6 = (0, import_react104.useMemo)(() => ({}), []), n13 = d13.value === void 0 || d13.value === null || d13.mode === 1 && Array.isArray(d13.value) && d13.value.length === 0, u17 = L();
  return import_react104.default.createElement(Le2.Provider, { value: true }, u17({ ourProps: x10, theirProps: { ...a20, children: import_react104.default.createElement(import_react104.default.Fragment, null, r18 && n13 ? r18 : o17) }, slot: p6, defaultTag: wt2, name: "ListboxSelectedOption" }));
}
var Ut2 = K(ht2);
var Nt2 = K(_t2);
var Ht2 = Q;
var Gt2 = K(Ft2);
var Vt2 = K(Bt2);
var Kt2 = K(kt2);
var Mo = Object.assign(Ut2, { Button: Nt2, Label: Ht2, Options: Gt2, Option: Vt2, SelectedOption: Kt2 });

// ../../node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react105 = __toESM(require_react(), 1);
var import_react_dom10 = __toESM(require_react_dom(), 1);
var qe = ((r18) => (r18[r18.Open = 0] = "Open", r18[r18.Closed = 1] = "Closed", r18))(qe || {});
var ze3 = ((r18) => (r18[r18.Pointer = 0] = "Pointer", r18[r18.Other = 1] = "Other", r18))(ze3 || {});
var Ye2 = ((a20) => (a20[a20.OpenMenu = 0] = "OpenMenu", a20[a20.CloseMenu = 1] = "CloseMenu", a20[a20.GoToItem = 2] = "GoToItem", a20[a20.Search = 3] = "Search", a20[a20.ClearSearch = 4] = "ClearSearch", a20[a20.RegisterItem = 5] = "RegisterItem", a20[a20.UnregisterItem = 6] = "UnregisterItem", a20[a20.SetButtonElement = 7] = "SetButtonElement", a20[a20.SetItemsElement = 8] = "SetItemsElement", a20))(Ye2 || {});
function j7(e8, n13 = (r18) => r18) {
  let r18 = e8.activeItemIndex !== null ? e8.items[e8.activeItemIndex] : null, l14 = _4(n13(e8.items.slice()), (u17) => u17.dataRef.current.domRef.current), o17 = r18 ? l14.indexOf(r18) : null;
  return o17 === -1 && (o17 = null), { items: l14, activeItemIndex: o17 };
}
var Ze = { [1](e8) {
  return e8.menuState === 1 ? e8 : { ...e8, activeItemIndex: null, menuState: 1 };
}, [0](e8) {
  return e8.menuState === 0 ? e8 : { ...e8, __demoMode: false, menuState: 0 };
}, [2]: (e8, n13) => {
  var u17, p6, s13, m10, a20;
  if (e8.menuState === 1)
    return e8;
  let r18 = { ...e8, searchQuery: "", activationTrigger: (u17 = n13.trigger) != null ? u17 : 1, __demoMode: false };
  if (n13.focus === c9.Nothing)
    return { ...r18, activeItemIndex: null };
  if (n13.focus === c9.Specific)
    return { ...r18, activeItemIndex: e8.items.findIndex((t11) => t11.id === n13.id) };
  if (n13.focus === c9.Previous) {
    let t11 = e8.activeItemIndex;
    if (t11 !== null) {
      let d13 = e8.items[t11].dataRef.current.domRef, f22 = f14(n13, { resolveItems: () => e8.items, resolveActiveIndex: () => e8.activeItemIndex, resolveId: (c15) => c15.id, resolveDisabled: (c15) => c15.dataRef.current.disabled });
      if (f22 !== null) {
        let c15 = e8.items[f22].dataRef.current.domRef;
        if (((p6 = d13.current) == null ? void 0 : p6.previousElementSibling) === c15.current || ((s13 = c15.current) == null ? void 0 : s13.previousElementSibling) === null)
          return { ...r18, activeItemIndex: f22 };
      }
    }
  } else if (n13.focus === c9.Next) {
    let t11 = e8.activeItemIndex;
    if (t11 !== null) {
      let d13 = e8.items[t11].dataRef.current.domRef, f22 = f14(n13, { resolveItems: () => e8.items, resolveActiveIndex: () => e8.activeItemIndex, resolveId: (c15) => c15.id, resolveDisabled: (c15) => c15.dataRef.current.disabled });
      if (f22 !== null) {
        let c15 = e8.items[f22].dataRef.current.domRef;
        if (((m10 = d13.current) == null ? void 0 : m10.nextElementSibling) === c15.current || ((a20 = c15.current) == null ? void 0 : a20.nextElementSibling) === null)
          return { ...r18, activeItemIndex: f22 };
      }
    }
  }
  let l14 = j7(e8), o17 = f14(n13, { resolveItems: () => l14.items, resolveActiveIndex: () => l14.activeItemIndex, resolveId: (t11) => t11.id, resolveDisabled: (t11) => t11.dataRef.current.disabled });
  return { ...r18, ...l14, activeItemIndex: o17 };
}, [3]: (e8, n13) => {
  let l14 = e8.searchQuery !== "" ? 0 : 1, o17 = e8.searchQuery + n13.value.toLowerCase(), p6 = (e8.activeItemIndex !== null ? e8.items.slice(e8.activeItemIndex + l14).concat(e8.items.slice(0, e8.activeItemIndex + l14)) : e8.items).find((m10) => {
    var a20;
    return ((a20 = m10.dataRef.current.textValue) == null ? void 0 : a20.startsWith(o17)) && !m10.dataRef.current.disabled;
  }), s13 = p6 ? e8.items.indexOf(p6) : -1;
  return s13 === -1 || s13 === e8.activeItemIndex ? { ...e8, searchQuery: o17 } : { ...e8, searchQuery: o17, activeItemIndex: s13, activationTrigger: 1 };
}, [4](e8) {
  return e8.searchQuery === "" ? e8 : { ...e8, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e8, n13) => {
  let r18 = j7(e8, (l14) => [...l14, { id: n13.id, dataRef: n13.dataRef }]);
  return { ...e8, ...r18 };
}, [6]: (e8, n13) => {
  let r18 = j7(e8, (l14) => {
    let o17 = l14.findIndex((u17) => u17.id === n13.id);
    return o17 !== -1 && l14.splice(o17, 1), l14;
  });
  return { ...e8, ...r18, activationTrigger: 1 };
}, [7]: (e8, n13) => e8.buttonElement === n13.element ? e8 : { ...e8, buttonElement: n13.element }, [8]: (e8, n13) => e8.itemsElement === n13.element ? e8 : { ...e8, itemsElement: n13.element } };
var Q4 = (0, import_react105.createContext)(null);
Q4.displayName = "MenuContext";
function w9(e8) {
  let n13 = (0, import_react105.useContext)(Q4);
  if (n13 === null) {
    let r18 = new Error(`<${e8} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r18, w9), r18;
  }
  return n13;
}
function et(e8, n13) {
  return u2(n13.type, Ze, e8, n13);
}
var tt = import_react105.Fragment;
function nt(e8, n13) {
  let { __demoMode: r18 = false, ...l14 } = e8, o17 = (0, import_react105.useReducer)(et, { __demoMode: r18, menuState: r18 ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: u17, itemsElement: p6, buttonElement: s13 }, m10] = o17, a20 = y(n13);
  R3(u17 === 0, [s13, p6], (b9, S7) => {
    m10({ type: 1 }), A2(S7, h5.Loose) || (b9.preventDefault(), s13 == null || s13.focus());
  });
  let d13 = o4(() => {
    m10({ type: 1 });
  }), f22 = (0, import_react105.useMemo)(() => ({ open: u17 === 0, close: d13 }), [u17, d13]), c15 = { ref: a20 }, A7 = L();
  return import_react105.default.createElement(Me, null, import_react105.default.createElement(Q4.Provider, { value: o17 }, import_react105.default.createElement(c8, { value: u2(u17, { [0]: i11.Open, [1]: i11.Closed }) }, A7({ ourProps: c15, theirProps: l14, slot: f22, defaultTag: tt, name: "Menu" }))));
}
var rt = "button";
function ot(e8, n13) {
  var h7;
  let r18 = (0, import_react51.useId)(), { id: l14 = `headlessui-menu-button-${r18}`, disabled: o17 = false, autoFocus: u17 = false, ...p6 } = e8, [s13, m10] = w9("Menu.Button"), a20 = Fe(), t11 = y(n13, ye(), o4((T10) => m10({ type: 7, element: T10 }))), d13 = o4((T10) => {
    switch (T10.key) {
      case o8.Space:
      case o8.Enter:
      case o8.ArrowDown:
        T10.preventDefault(), T10.stopPropagation(), (0, import_react_dom10.flushSync)(() => m10({ type: 0 })), m10({ type: 2, focus: c9.First });
        break;
      case o8.ArrowUp:
        T10.preventDefault(), T10.stopPropagation(), (0, import_react_dom10.flushSync)(() => m10({ type: 0 })), m10({ type: 2, focus: c9.Last });
        break;
    }
  }), f22 = o4((T10) => {
    switch (T10.key) {
      case o8.Space:
        T10.preventDefault();
        break;
    }
  }), c15 = o4((T10) => {
    var F6;
    if (r5(T10.currentTarget))
      return T10.preventDefault();
    o17 || (s13.menuState === 0 ? ((0, import_react_dom10.flushSync)(() => m10({ type: 1 })), (F6 = s13.buttonElement) == null || F6.focus({ preventScroll: true })) : (T10.preventDefault(), m10({ type: 0 })));
  }), { isFocusVisible: A7, focusProps: b9 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: u17 }), { isHovered: S7, hoverProps: D7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: o17 }), { pressed: M9, pressProps: P7 } = w({ disabled: o17 }), v4 = (0, import_react105.useMemo)(() => ({ open: s13.menuState === 0, active: M9 || s13.menuState === 0, disabled: o17, hover: S7, focus: A7, autofocus: u17 }), [s13, S7, A7, M9, o17, u17]), C9 = _2(a20(), { ref: t11, id: l14, type: e6(e8, s13.buttonElement), "aria-haspopup": "menu", "aria-controls": (h7 = s13.itemsElement) == null ? void 0 : h7.id, "aria-expanded": s13.menuState === 0, disabled: o17 || void 0, autoFocus: u17, onKeyDown: d13, onKeyUp: f22, onClick: c15 }, b9, D7, P7);
  return L()({ ourProps: C9, theirProps: p6, slot: v4, defaultTag: rt, name: "Menu.Button" });
}
var at = "div";
var lt = O.RenderStrategy | O.Static;
function it(e8, n13) {
  var J7, V6;
  let r18 = (0, import_react51.useId)(), { id: l14 = `headlessui-menu-items-${r18}`, anchor: o17, portal: u17 = false, modal: p6 = true, transition: s13 = false, ...m10 } = e8, a20 = xe(o17), [t11, d13] = w9("Menu.Items"), [f22, c15] = Re(a20), A7 = be(), [b9, S7] = (0, import_react105.useState)(null), D7 = y(n13, a20 ? f22 : null, o4((i15) => d13({ type: 8, element: i15 })), S7), M9 = n9(t11.itemsElement);
  a20 && (u17 = true);
  let P7 = u13(), [v4, C9] = x3(s13, b9, P7 !== null ? (P7 & i11.Open) === i11.Open : t11.menuState === 0);
  m6(v4, t11.buttonElement, () => {
    d13({ type: 1 });
  });
  let O7 = t11.__demoMode ? false : p6 && t11.menuState === 0;
  f11(O7, M9);
  let h7 = t11.__demoMode ? false : p6 && t11.menuState === 0;
  y3(h7, { allowed: (0, import_react105.useCallback)(() => [t11.buttonElement, t11.itemsElement], [t11.buttonElement, t11.itemsElement]) });
  let T10 = t11.menuState !== 0, K4 = s9(T10, t11.buttonElement) ? false : v4;
  (0, import_react105.useEffect)(() => {
    let i15 = t11.itemsElement;
    i15 && t11.menuState === 0 && i15 !== (M9 == null ? void 0 : M9.activeElement) && i15.focus({ preventScroll: true });
  }, [t11.menuState, t11.itemsElement, M9]), F3(t11.menuState === 0, { container: t11.itemsElement, accept(i15) {
    return i15.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : i15.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(i15) {
    i15.setAttribute("role", "none");
  } });
  let I6 = p(), G7 = o4((i15) => {
    var X4, $3, q4;
    switch (I6.dispose(), i15.key) {
      case o8.Space:
        if (t11.searchQuery !== "")
          return i15.preventDefault(), i15.stopPropagation(), d13({ type: 3, value: i15.key });
      case o8.Enter:
        if (i15.preventDefault(), i15.stopPropagation(), d13({ type: 1 }), t11.activeItemIndex !== null) {
          let { dataRef: ue5 } = t11.items[t11.activeItemIndex];
          ($3 = (X4 = ue5.current) == null ? void 0 : X4.domRef.current) == null || $3.click();
        }
        G2(t11.buttonElement);
        break;
      case o8.ArrowDown:
        return i15.preventDefault(), i15.stopPropagation(), d13({ type: 2, focus: c9.Next });
      case o8.ArrowUp:
        return i15.preventDefault(), i15.stopPropagation(), d13({ type: 2, focus: c9.Previous });
      case o8.Home:
      case o8.PageUp:
        return i15.preventDefault(), i15.stopPropagation(), d13({ type: 2, focus: c9.First });
      case o8.End:
      case o8.PageDown:
        return i15.preventDefault(), i15.stopPropagation(), d13({ type: 2, focus: c9.Last });
      case o8.Escape:
        i15.preventDefault(), i15.stopPropagation(), (0, import_react_dom10.flushSync)(() => d13({ type: 1 })), (q4 = t11.buttonElement) == null || q4.focus({ preventScroll: true });
        break;
      case o8.Tab:
        i15.preventDefault(), i15.stopPropagation(), (0, import_react_dom10.flushSync)(() => d13({ type: 1 })), j3(t11.buttonElement, i15.shiftKey ? F2.Previous : F2.Next);
        break;
      default:
        i15.key.length === 1 && (d13({ type: 3, value: i15.key }), I6.setTimeout(() => d13({ type: 4 }), 350));
        break;
    }
  }), ae6 = o4((i15) => {
    switch (i15.key) {
      case o8.Space:
        i15.preventDefault();
        break;
    }
  }), le4 = (0, import_react105.useMemo)(() => ({ open: t11.menuState === 0 }), [t11.menuState]), ie5 = _2(a20 ? A7() : {}, { "aria-activedescendant": t11.activeItemIndex === null || (J7 = t11.items[t11.activeItemIndex]) == null ? void 0 : J7.id, "aria-labelledby": (V6 = t11.buttonElement) == null ? void 0 : V6.id, id: l14, onKeyDown: G7, onKeyUp: ae6, role: "menu", tabIndex: t11.menuState === 0 ? 0 : void 0, ref: D7, style: { ...m10.style, ...c15, "--button-width": d3(t11.buttonElement, true).width }, ...R4(C9) }), se4 = L();
  return import_react105.default.createElement(re, { enabled: u17 ? e8.static || v4 : false }, se4({ ourProps: ie5, theirProps: m10, slot: le4, defaultTag: at, features: lt, visible: K4, name: "Menu.Items" }));
}
var st = import_react105.Fragment;
function ut(e8, n13) {
  let r18 = (0, import_react51.useId)(), { id: l14 = `headlessui-menu-item-${r18}`, disabled: o17 = false, ...u17 } = e8, [p6, s13] = w9("Menu.Item"), m10 = p6.activeItemIndex !== null ? p6.items[p6.activeItemIndex].id === l14 : false, a20 = (0, import_react105.useRef)(null), t11 = y(n13, a20);
  n(() => {
    if (!p6.__demoMode && p6.menuState === 0 && m10 && p6.activationTrigger !== 0)
      return o2().requestAnimationFrame(() => {
        var I6, G7;
        (G7 = (I6 = a20.current) == null ? void 0 : I6.scrollIntoView) == null || G7.call(I6, { block: "nearest" });
      });
  }, [p6.__demoMode, a20, m10, p6.menuState, p6.activationTrigger, p6.activeItemIndex]);
  let d13 = s10(a20), f22 = (0, import_react105.useRef)({ disabled: o17, domRef: a20, get textValue() {
    return d13();
  } });
  n(() => {
    f22.current.disabled = o17;
  }, [f22, o17]), n(() => (s13({ type: 5, id: l14, dataRef: f22 }), () => s13({ type: 6, id: l14 })), [f22, l14]);
  let c15 = o4(() => {
    s13({ type: 1 });
  }), A7 = o4((I6) => {
    if (o17)
      return I6.preventDefault();
    s13({ type: 1 }), G2(p6.buttonElement);
  }), b9 = o4(() => {
    if (o17)
      return s13({ type: 2, focus: c9.Nothing });
    s13({ type: 2, focus: c9.Specific, id: l14 });
  }), S7 = u11(), D7 = o4((I6) => {
    S7.update(I6), !o17 && (m10 || s13({ type: 2, focus: c9.Specific, id: l14, trigger: 0 }));
  }), M9 = o4((I6) => {
    S7.wasMoved(I6) && (o17 || m10 || s13({ type: 2, focus: c9.Specific, id: l14, trigger: 0 }));
  }), P7 = o4((I6) => {
    S7.wasMoved(I6) && (o17 || m10 && s13({ type: 2, focus: c9.Nothing }));
  }), [v4, C9] = K2(), [O7, h7] = w3(), T10 = (0, import_react105.useMemo)(() => ({ active: m10, focus: m10, disabled: o17, close: c15 }), [m10, o17, c15]), F6 = { id: l14, ref: t11, role: "menuitem", tabIndex: o17 === true ? void 0 : -1, "aria-disabled": o17 === true ? true : void 0, "aria-labelledby": v4, "aria-describedby": O7, disabled: void 0, onClick: A7, onFocus: b9, onPointerEnter: D7, onMouseEnter: D7, onPointerMove: M9, onMouseMove: M9, onPointerLeave: P7, onMouseLeave: P7 }, K4 = L();
  return import_react105.default.createElement(C9, null, import_react105.default.createElement(h7, null, K4({ ourProps: F6, theirProps: u17, slot: T10, defaultTag: st, name: "Menu.Item" })));
}
var pt = "div";
function mt(e8, n13) {
  let [r18, l14] = K2(), o17 = e8, u17 = { ref: n13, "aria-labelledby": r18, role: "group" }, p6 = L();
  return import_react105.default.createElement(l14, null, p6({ ourProps: u17, theirProps: o17, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
var dt = "header";
function ct(e8, n13) {
  let r18 = (0, import_react51.useId)(), { id: l14 = `headlessui-menu-heading-${r18}`, ...o17 } = e8, u17 = P5();
  n(() => u17.register(l14), [l14, u17.register]);
  let p6 = { id: l14, ref: n13, role: "presentation", ...u17.props };
  return L()({ ourProps: p6, theirProps: o17, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
var ft = "div";
function Tt(e8, n13) {
  let r18 = e8, l14 = { ref: n13, role: "separator" };
  return L()({ ourProps: l14, theirProps: r18, slot: {}, defaultTag: ft, name: "Menu.Separator" });
}
var yt2 = K(nt);
var It3 = K(ot);
var gt2 = K(it);
var Et3 = K(ut);
var Mt3 = K(mt);
var St3 = K(ct);
var At3 = K(Tt);
var rn = Object.assign(yt2, { Button: It3, Items: gt2, Item: Et3, Section: Mt3, Heading: St3, Separator: At3 });

// ../../node_modules/@headlessui/react/dist/components/popover/popover.js
var import_react106 = __toESM(require_react(), 1);
var lt2 = ((f22) => (f22[f22.Open = 0] = "Open", f22[f22.Closed = 1] = "Closed", f22))(lt2 || {});
var at2 = ((p6) => (p6[p6.TogglePopover = 0] = "TogglePopover", p6[p6.ClosePopover = 1] = "ClosePopover", p6[p6.SetButton = 2] = "SetButton", p6[p6.SetButtonId = 3] = "SetButtonId", p6[p6.SetPanel = 4] = "SetPanel", p6[p6.SetPanelId = 5] = "SetPanelId", p6))(at2 || {});
var pt2 = { [0]: (o17) => ({ ...o17, popoverState: u2(o17.popoverState, { [0]: 1, [1]: 0 }), __demoMode: false }), [1](o17) {
  return o17.popoverState === 1 ? o17 : { ...o17, popoverState: 1, __demoMode: false };
}, [2](o17, a20) {
  return o17.button === a20.button ? o17 : { ...o17, button: a20.button };
}, [3](o17, a20) {
  return o17.buttonId === a20.buttonId ? o17 : { ...o17, buttonId: a20.buttonId };
}, [4](o17, a20) {
  return o17.panel === a20.panel ? o17 : { ...o17, panel: a20.panel };
}, [5](o17, a20) {
  return o17.panelId === a20.panelId ? o17 : { ...o17, panelId: a20.panelId };
} };
var Ee2 = (0, import_react106.createContext)(null);
Ee2.displayName = "PopoverContext";
function se3(o17) {
  let a20 = (0, import_react106.useContext)(Ee2);
  if (a20 === null) {
    let f22 = new Error(`<${o17} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f22, se3), f22;
  }
  return a20;
}
var ue4 = (0, import_react106.createContext)(null);
ue4.displayName = "PopoverAPIContext";
function be4(o17) {
  let a20 = (0, import_react106.useContext)(ue4);
  if (a20 === null) {
    let f22 = new Error(`<${o17} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f22, be4), f22;
  }
  return a20;
}
var ge3 = (0, import_react106.createContext)(null);
ge3.displayName = "PopoverGroupContext";
function Me3() {
  return (0, import_react106.useContext)(ge3);
}
var ie4 = (0, import_react106.createContext)(null);
ie4.displayName = "PopoverPanelContext";
function st2() {
  return (0, import_react106.useContext)(ie4);
}
function ut2(o17, a20) {
  return u2(a20.type, pt2, o17, a20);
}
var it2 = "div";
function dt2(o17, a20) {
  var J7;
  let { __demoMode: f22 = false, ...C9 } = o17, T10 = (0, import_react106.useRef)(null), S7 = y(a20, T2((t11) => {
    T10.current = t11;
  })), p6 = (0, import_react106.useRef)([]), l14 = (0, import_react106.useReducer)(ut2, { __demoMode: f22, popoverState: f22 ? 0 : 1, buttons: p6, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: (0, import_react106.createRef)(), afterPanelSentinel: (0, import_react106.createRef)(), afterButtonSentinel: (0, import_react106.createRef)() }), [{ popoverState: c15, button: d13, buttonId: r18, panel: s13, panelId: R9, beforePanelSentinel: m10, afterPanelSentinel: h7, afterButtonSentinel: P7 }, n13] = l14, v4 = n9((J7 = T10.current) != null ? J7 : d13), g6 = (0, import_react106.useMemo)(() => {
    if (!d13 || !s13)
      return false;
    for (let E12 of document.querySelectorAll("body > *"))
      if (Number(E12 == null ? void 0 : E12.contains(d13)) ^ Number(E12 == null ? void 0 : E12.contains(s13)))
        return true;
    let t11 = b2(), e8 = t11.indexOf(d13), u17 = (e8 + t11.length - 1) % t11.length, i15 = (e8 + 1) % t11.length, A7 = t11[u17], x10 = t11[i15];
    return !s13.contains(A7) && !s13.contains(x10);
  }, [d13, s13]), _9 = s3(r18), L6 = s3(R9), I6 = (0, import_react106.useMemo)(() => ({ buttonId: _9, panelId: L6, close: () => n13({ type: 1 }) }), [_9, L6, n13]), M9 = Me3(), k5 = M9 == null ? void 0 : M9.registerPopover, B3 = o4(() => {
    var t11;
    return (t11 = M9 == null ? void 0 : M9.isFocusWithinPopoverGroup()) != null ? t11 : (v4 == null ? void 0 : v4.activeElement) && ((d13 == null ? void 0 : d13.contains(v4.activeElement)) || (s13 == null ? void 0 : s13.contains(v4.activeElement)));
  });
  (0, import_react106.useEffect)(() => k5 == null ? void 0 : k5(I6), [k5, I6]);
  let [U8, O7] = te(), N4 = b5(d13), w11 = R7({ mainTreeNode: N4, portals: U8, defaultContainers: [d13, s13] });
  E5(v4 == null ? void 0 : v4.defaultView, "focus", (t11) => {
    var e8, u17, i15, A7, x10, E12;
    t11.target !== window && t11.target instanceof HTMLElement && c15 === 0 && (B3() || d13 && s13 && (w11.contains(t11.target) || (u17 = (e8 = m10.current) == null ? void 0 : e8.contains) != null && u17.call(e8, t11.target) || (A7 = (i15 = h7.current) == null ? void 0 : i15.contains) != null && A7.call(i15, t11.target) || (E12 = (x10 = P7.current) == null ? void 0 : x10.contains) != null && E12.call(x10, t11.target) || n13({ type: 1 })));
  }, true), R3(c15 === 0, w11.resolveContainers, (t11, e8) => {
    n13({ type: 1 }), A2(e8, h5.Loose) || (t11.preventDefault(), d13 == null || d13.focus());
  });
  let F6 = o4((t11) => {
    n13({ type: 1 });
    let e8 = (() => t11 ? t11 instanceof HTMLElement ? t11 : "current" in t11 && t11.current instanceof HTMLElement ? t11.current : d13 : d13)();
    e8 == null || e8.focus();
  }), Q6 = (0, import_react106.useMemo)(() => ({ close: F6, isPortalled: g6 }), [F6, g6]), K4 = (0, import_react106.useMemo)(() => ({ open: c15 === 0, close: F6 }), [c15, F6]), Z4 = { ref: S7 }, $3 = L();
  return import_react106.default.createElement(O4, { node: N4 }, import_react106.default.createElement(Me, null, import_react106.default.createElement(ie4.Provider, { value: null }, import_react106.default.createElement(Ee2.Provider, { value: l14 }, import_react106.default.createElement(ue4.Provider, { value: Q6 }, import_react106.default.createElement(C4, { value: F6 }, import_react106.default.createElement(c8, { value: u2(c15, { [0]: i11.Open, [1]: i11.Closed }) }, import_react106.default.createElement(O7, null, $3({ ourProps: Z4, theirProps: C9, slot: K4, defaultTag: it2, name: "Popover" })))))))));
}
var Pt3 = "button";
function ft2(o17, a20) {
  let f22 = (0, import_react51.useId)(), { id: C9 = `headlessui-popover-button-${f22}`, disabled: T10 = false, autoFocus: S7 = false, ...p6 } = o17, [l14, c15] = se3("Popover.Button"), { isPortalled: d13 } = be4("Popover.Button"), r18 = (0, import_react106.useRef)(null), s13 = `headlessui-focus-sentinel-${(0, import_react51.useId)()}`, R9 = Me3(), m10 = R9 == null ? void 0 : R9.closeOthers, P7 = st2() !== null;
  (0, import_react106.useEffect)(() => {
    if (!P7)
      return c15({ type: 3, buttonId: C9 }), () => {
        c15({ type: 3, buttonId: null });
      };
  }, [P7, C9, c15]);
  let [n13] = (0, import_react106.useState)(() => Symbol()), v4 = y(r18, a20, ye(), o4((e8) => {
    if (!P7) {
      if (e8)
        l14.buttons.current.push(n13);
      else {
        let u17 = l14.buttons.current.indexOf(n13);
        u17 !== -1 && l14.buttons.current.splice(u17, 1);
      }
      l14.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e8 && c15({ type: 2, button: e8 });
    }
  })), g6 = y(r18, a20), _9 = n9(r18), L6 = o4((e8) => {
    var u17, i15, A7;
    if (P7) {
      if (l14.popoverState === 1)
        return;
      switch (e8.key) {
        case o8.Space:
        case o8.Enter:
          e8.preventDefault(), (i15 = (u17 = e8.target).click) == null || i15.call(u17), c15({ type: 1 }), (A7 = l14.button) == null || A7.focus();
          break;
      }
    } else
      switch (e8.key) {
        case o8.Space:
        case o8.Enter:
          e8.preventDefault(), e8.stopPropagation(), l14.popoverState === 1 && (m10 == null || m10(l14.buttonId)), c15({ type: 0 });
          break;
        case o8.Escape:
          if (l14.popoverState !== 0)
            return m10 == null ? void 0 : m10(l14.buttonId);
          if (!r18.current || _9 != null && _9.activeElement && !r18.current.contains(_9.activeElement))
            return;
          e8.preventDefault(), e8.stopPropagation(), c15({ type: 1 });
          break;
      }
  }), I6 = o4((e8) => {
    P7 || e8.key === o8.Space && e8.preventDefault();
  }), M9 = o4((e8) => {
    var u17, i15;
    r5(e8.currentTarget) || T10 || (P7 ? (c15({ type: 1 }), (u17 = l14.button) == null || u17.focus()) : (e8.preventDefault(), e8.stopPropagation(), l14.popoverState === 1 && (m10 == null || m10(l14.buttonId)), c15({ type: 0 }), (i15 = l14.button) == null || i15.focus()));
  }), k5 = o4((e8) => {
    e8.preventDefault(), e8.stopPropagation();
  }), { isFocusVisible: B3, focusProps: U8 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: S7 }), { isHovered: O7, hoverProps: N4 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: T10 }), { pressed: w11, pressProps: Y4 } = w({ disabled: T10 }), F6 = l14.popoverState === 0, Q6 = (0, import_react106.useMemo)(() => ({ open: F6, active: w11 || F6, disabled: T10, hover: O7, focus: B3, autofocus: S7 }), [F6, O7, B3, w11, T10, S7]), K4 = e6(o17, l14.button), Z4 = P7 ? _2({ ref: g6, type: K4, onKeyDown: L6, onClick: M9, disabled: T10 || void 0, autoFocus: S7 }, U8, N4, Y4) : _2({ ref: v4, id: l14.buttonId, type: K4, "aria-expanded": l14.popoverState === 0, "aria-controls": l14.panel ? l14.panelId : void 0, disabled: T10 || void 0, autoFocus: S7, onKeyDown: L6, onKeyUp: I6, onClick: M9, onMouseDown: k5 }, U8, N4, Y4), $3 = u16(), J7 = o4(() => {
    let e8 = l14.panel;
    if (!e8)
      return;
    function u17() {
      u2($3.current, { [a15.Forwards]: () => P6(e8, F2.First), [a15.Backwards]: () => P6(e8, F2.Last) }) === T5.Error && P6(b2().filter((A7) => A7.dataset.headlessuiFocusGuard !== "true"), u2($3.current, { [a15.Forwards]: F2.Next, [a15.Backwards]: F2.Previous }), { relativeTo: l14.button });
    }
    u17();
  }), t11 = L();
  return import_react106.default.createElement(import_react106.default.Fragment, null, t11({ ourProps: Z4, theirProps: p6, slot: Q6, defaultTag: Pt3, name: "Popover.Button" }), F6 && !P7 && d13 && import_react106.default.createElement(f4, { id: s13, ref: l14.afterButtonSentinel, features: s4.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: J7 }));
}
var ct2 = "div";
var vt = O.RenderStrategy | O.Static;
function Oe2(o17, a20) {
  let f22 = (0, import_react51.useId)(), { id: C9 = `headlessui-popover-backdrop-${f22}`, transition: T10 = false, ...S7 } = o17, [{ popoverState: p6 }, l14] = se3("Popover.Backdrop"), [c15, d13] = (0, import_react106.useState)(null), r18 = y(a20, d13), s13 = u13(), [R9, m10] = x3(T10, c15, s13 !== null ? (s13 & i11.Open) === i11.Open : p6 === 0), h7 = o4((g6) => {
    if (r5(g6.currentTarget))
      return g6.preventDefault();
    l14({ type: 1 });
  }), P7 = (0, import_react106.useMemo)(() => ({ open: p6 === 0 }), [p6]), n13 = { ref: r18, id: C9, "aria-hidden": true, onClick: h7, ...R4(m10) };
  return L()({ ourProps: n13, theirProps: S7, slot: P7, defaultTag: ct2, features: vt, visible: R9, name: "Popover.Backdrop" });
}
var Tt2 = "div";
var mt2 = O.RenderStrategy | O.Static;
function yt3(o17, a20) {
  let f22 = (0, import_react51.useId)(), { id: C9 = `headlessui-popover-panel-${f22}`, focus: T10 = false, anchor: S7, portal: p6 = false, modal: l14 = false, transition: c15 = false, ...d13 } = o17, [r18, s13] = se3("Popover.Panel"), { close: R9, isPortalled: m10 } = be4("Popover.Panel"), h7 = `headlessui-focus-sentinel-before-${f22}`, P7 = `headlessui-focus-sentinel-after-${f22}`, n13 = (0, import_react106.useRef)(null), v4 = xe(S7), [g6, _9] = Re(v4), L6 = be();
  v4 && (p6 = true);
  let [I6, M9] = (0, import_react106.useState)(null), k5 = y(n13, a20, v4 ? g6 : null, o4((t11) => s13({ type: 4, panel: t11 })), M9), B3 = n9(n13);
  n(() => (s13({ type: 5, panelId: C9 }), () => {
    s13({ type: 5, panelId: null });
  }), [C9, s13]);
  let U8 = u13(), [O7, N4] = x3(c15, I6, U8 !== null ? (U8 & i11.Open) === i11.Open : r18.popoverState === 0);
  m6(O7, r18.button, () => {
    s13({ type: 1 });
  });
  let w11 = r18.__demoMode ? false : l14 && O7;
  f11(w11, B3);
  let Y4 = o4((t11) => {
    var e8;
    switch (t11.key) {
      case o8.Escape:
        if (r18.popoverState !== 0 || !n13.current || B3 != null && B3.activeElement && !n13.current.contains(B3.activeElement))
          return;
        t11.preventDefault(), t11.stopPropagation(), s13({ type: 1 }), (e8 = r18.button) == null || e8.focus();
        break;
    }
  });
  (0, import_react106.useEffect)(() => {
    var t11;
    o17.static || r18.popoverState === 1 && ((t11 = o17.unmount) == null || t11) && s13({ type: 4, panel: null });
  }, [r18.popoverState, o17.unmount, o17.static, s13]), (0, import_react106.useEffect)(() => {
    if (r18.__demoMode || !T10 || r18.popoverState !== 0 || !n13.current)
      return;
    let t11 = B3 == null ? void 0 : B3.activeElement;
    n13.current.contains(t11) || P6(n13.current, F2.First);
  }, [r18.__demoMode, T10, n13.current, r18.popoverState]);
  let F6 = (0, import_react106.useMemo)(() => ({ open: r18.popoverState === 0, close: R9 }), [r18.popoverState, R9]), Q6 = _2(v4 ? L6() : {}, { ref: k5, id: C9, onKeyDown: Y4, onBlur: T10 && r18.popoverState === 0 ? (t11) => {
    var u17, i15, A7, x10, E12;
    let e8 = t11.relatedTarget;
    e8 && n13.current && ((u17 = n13.current) != null && u17.contains(e8) || (s13({ type: 1 }), ((A7 = (i15 = r18.beforePanelSentinel.current) == null ? void 0 : i15.contains) != null && A7.call(i15, e8) || (E12 = (x10 = r18.afterPanelSentinel.current) == null ? void 0 : x10.contains) != null && E12.call(x10, e8)) && e8.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1, style: { ...d13.style, ..._9, "--button-width": d3(r18.button, true).width }, ...R4(N4) }), K4 = u16(), Z4 = o4(() => {
    let t11 = n13.current;
    if (!t11)
      return;
    function e8() {
      u2(K4.current, { [a15.Forwards]: () => {
        var i15;
        P6(t11, F2.First) === T5.Error && ((i15 = r18.afterPanelSentinel.current) == null || i15.focus());
      }, [a15.Backwards]: () => {
        var u17;
        (u17 = r18.button) == null || u17.focus({ preventScroll: true });
      } });
    }
    e8();
  }), $3 = o4(() => {
    let t11 = n13.current;
    if (!t11)
      return;
    function e8() {
      u2(K4.current, { [a15.Forwards]: () => {
        if (!r18.button)
          return;
        let u17 = b2(), i15 = u17.indexOf(r18.button), A7 = u17.slice(0, i15 + 1), E12 = [...u17.slice(i15 + 1), ...A7];
        for (let de6 of E12.slice())
          if (de6.dataset.headlessuiFocusGuard === "true" || I6 != null && I6.contains(de6)) {
            let Se5 = E12.indexOf(de6);
            Se5 !== -1 && E12.splice(Se5, 1);
          }
        P6(E12, F2.First, { sorted: false });
      }, [a15.Backwards]: () => {
        var i15;
        P6(t11, F2.Previous) === T5.Error && ((i15 = r18.button) == null || i15.focus());
      } });
    }
    e8();
  }), J7 = L();
  return import_react106.default.createElement(s7, null, import_react106.default.createElement(ie4.Provider, { value: C9 }, import_react106.default.createElement(ue4.Provider, { value: { close: R9, isPortalled: m10 } }, import_react106.default.createElement(re, { enabled: p6 ? o17.static || O7 : false }, O7 && m10 && import_react106.default.createElement(f4, { id: h7, ref: r18.beforePanelSentinel, features: s4.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: Z4 }), J7({ ourProps: Q6, theirProps: d13, slot: F6, defaultTag: Tt2, features: mt2, visible: O7, name: "Popover.Panel" }), O7 && m10 && import_react106.default.createElement(f4, { id: P7, ref: r18.afterPanelSentinel, features: s4.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: $3 })))));
}
var Et4 = "div";
function bt(o17, a20) {
  let f22 = (0, import_react106.useRef)(null), C9 = y(f22, a20), [T10, S7] = (0, import_react106.useState)([]), p6 = o4((P7) => {
    S7((n13) => {
      let v4 = n13.indexOf(P7);
      if (v4 !== -1) {
        let g6 = n13.slice();
        return g6.splice(v4, 1), g6;
      }
      return n13;
    });
  }), l14 = o4((P7) => (S7((n13) => [...n13, P7]), () => p6(P7))), c15 = o4(() => {
    var v4;
    let P7 = u(f22);
    if (!P7)
      return false;
    let n13 = P7.activeElement;
    return (v4 = f22.current) != null && v4.contains(n13) ? true : T10.some((g6) => {
      var _9, L6;
      return ((_9 = P7.getElementById(g6.buttonId.current)) == null ? void 0 : _9.contains(n13)) || ((L6 = P7.getElementById(g6.panelId.current)) == null ? void 0 : L6.contains(n13));
    });
  }), d13 = o4((P7) => {
    for (let n13 of T10)
      n13.buttonId.current !== P7 && n13.close();
  }), r18 = (0, import_react106.useMemo)(() => ({ registerPopover: l14, unregisterPopover: p6, isFocusWithinPopoverGroup: c15, closeOthers: d13 }), [l14, p6, c15, d13]), s13 = (0, import_react106.useMemo)(() => ({}), []), R9 = o17, m10 = { ref: C9 }, h7 = L();
  return import_react106.default.createElement(O4, null, import_react106.default.createElement(ge3.Provider, { value: r18 }, h7({ ourProps: m10, theirProps: R9, slot: s13, defaultTag: Et4, name: "Popover.Group" })));
}
var gt3 = K(dt2);
var St4 = K(ft2);
var At4 = K(Oe2);
var Ct3 = K(Oe2);
var Rt3 = K(yt3);
var Bt3 = K(bt);
var lo = Object.assign(gt3, { Button: St4, Backdrop: Ct3, Overlay: At4, Panel: Rt3, Group: Bt3 });

// ../../node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var import_react107 = __toESM(require_react(), 1);
var ke2 = ((e8) => (e8[e8.RegisterOption = 0] = "RegisterOption", e8[e8.UnregisterOption = 1] = "UnregisterOption", e8))(ke2 || {});
var Fe3 = { [0](o17, t11) {
  let e8 = [...o17.options, { id: t11.id, element: t11.element, propsRef: t11.propsRef }];
  return { ...o17, options: _4(e8, (a20) => a20.element.current) };
}, [1](o17, t11) {
  let e8 = o17.options.slice(), a20 = o17.options.findIndex((g6) => g6.id === t11.id);
  return a20 === -1 ? o17 : (e8.splice(a20, 1), { ...o17, options: e8 });
} };
var J5 = (0, import_react107.createContext)(null);
J5.displayName = "RadioGroupDataContext";
function X3(o17) {
  let t11 = (0, import_react107.useContext)(J5);
  if (t11 === null) {
    let e8 = new Error(`<${o17} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e8, X3), e8;
  }
  return t11;
}
var z2 = (0, import_react107.createContext)(null);
z2.displayName = "RadioGroupActionsContext";
function q3(o17) {
  let t11 = (0, import_react107.useContext)(z2);
  if (t11 === null) {
    let e8 = new Error(`<${o17} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e8, q3), e8;
  }
  return t11;
}
function Ie5(o17, t11) {
  return u2(t11.type, Fe3, o17, t11);
}
var Ue3 = "div";
function Me4(o17, t11) {
  let e8 = (0, import_react51.useId)(), a20 = a3(), { id: g6 = `headlessui-radiogroup-${e8}`, value: R9, form: O7, name: n13, onChange: f22, by: c15, disabled: p6 = a20 || false, defaultValue: I6, ...m10 } = o17, T10 = u9(c15), [P7, C9] = (0, import_react107.useReducer)(Ie5, { options: [] }), i15 = P7.options, [U8, h7] = K2(), [v4, L6] = w3(), D7 = (0, import_react107.useRef)(null), M9 = y(D7, t11), l14 = l2(I6), [s13, A7] = T(R9, f22, l14), S7 = (0, import_react107.useMemo)(() => i15.find((r18) => !r18.propsRef.current.disabled), [i15]), y9 = (0, import_react107.useMemo)(() => i15.some((r18) => T10(r18.propsRef.current.value, s13)), [i15, s13]), d13 = o4((r18) => {
    var u17;
    if (p6 || T10(r18, s13))
      return false;
    let k5 = (u17 = i15.find((w11) => T10(w11.propsRef.current.value, r18))) == null ? void 0 : u17.propsRef.current;
    return k5 != null && k5.disabled ? false : (A7 == null || A7(r18), true);
  }), _9 = o4((r18) => {
    let k5 = D7.current;
    if (!k5)
      return;
    let u17 = u(k5), w11 = i15.filter((b9) => b9.propsRef.current.disabled === false).map((b9) => b9.element.current);
    switch (r18.key) {
      case o8.Enter:
        p2(r18.currentTarget);
        break;
      case o8.ArrowLeft:
      case o8.ArrowUp:
        if (r18.preventDefault(), r18.stopPropagation(), P6(w11, F2.Previous | F2.WrapAround) === T5.Success) {
          let E12 = i15.find((W5) => W5.element.current === (u17 == null ? void 0 : u17.activeElement));
          E12 && d13(E12.propsRef.current.value);
        }
        break;
      case o8.ArrowRight:
      case o8.ArrowDown:
        if (r18.preventDefault(), r18.stopPropagation(), P6(w11, F2.Next | F2.WrapAround) === T5.Success) {
          let E12 = i15.find((W5) => W5.element.current === (u17 == null ? void 0 : u17.activeElement));
          E12 && d13(E12.propsRef.current.value);
        }
        break;
      case o8.Space:
        {
          r18.preventDefault(), r18.stopPropagation();
          let b9 = i15.find((E12) => E12.element.current === (u17 == null ? void 0 : u17.activeElement));
          b9 && d13(b9.propsRef.current.value);
        }
        break;
    }
  }), Q6 = o4((r18) => (C9({ type: 0, ...r18 }), () => C9({ type: 1, id: r18.id }))), ue5 = (0, import_react107.useMemo)(() => ({ value: s13, firstOption: S7, containsCheckedOption: y9, disabled: p6, compare: T10, ...P7 }), [s13, S7, y9, p6, T10, P7]), ce5 = (0, import_react107.useMemo)(() => ({ registerOption: Q6, change: d13 }), [Q6, d13]), fe5 = { ref: M9, id: g6, role: "radiogroup", "aria-labelledby": U8, "aria-describedby": v4, onKeyDown: _9 }, Te6 = (0, import_react107.useMemo)(() => ({ value: s13 }), [s13]), Re4 = (0, import_react107.useCallback)(() => {
    if (l14 !== void 0)
      return d13(l14);
  }, [d13, l14]), me4 = L();
  return import_react107.default.createElement(L6, { name: "RadioGroup.Description" }, import_react107.default.createElement(h7, { name: "RadioGroup.Label" }, import_react107.default.createElement(z2.Provider, { value: ce5 }, import_react107.default.createElement(J5.Provider, { value: ue5 }, n13 != null && import_react107.default.createElement(j2, { disabled: p6, data: { [n13]: s13 || "on" }, overrides: { type: "radio", checked: s13 != null }, form: O7, onReset: Re4 }), me4({ ourProps: fe5, theirProps: m10, slot: Te6, defaultTag: Ue3, name: "RadioGroup" })))));
}
var Se3 = "div";
function He3(o17, t11) {
  var y9;
  let e8 = X3("RadioGroup.Option"), a20 = q3("RadioGroup.Option"), g6 = (0, import_react51.useId)(), { id: R9 = `headlessui-radiogroup-option-${g6}`, value: O7, disabled: n13 = e8.disabled || false, autoFocus: f22 = false, ...c15 } = o17, p6 = (0, import_react107.useRef)(null), I6 = y(p6, t11), [m10, T10] = K2(), [P7, C9] = w3(), i15 = s3({ value: O7, disabled: n13 });
  n(() => a20.registerOption({ id: R9, element: p6, propsRef: i15 }), [R9, a20, p6, i15]);
  let U8 = o4((d13) => {
    var _9;
    if (r5(d13.currentTarget))
      return d13.preventDefault();
    a20.change(O7) && ((_9 = p6.current) == null || _9.focus());
  }), h7 = ((y9 = e8.firstOption) == null ? void 0 : y9.id) === R9, { isFocusVisible: v4, focusProps: L6 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f22 }), { isHovered: D7, hoverProps: M9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: n13 }), l14 = e8.compare(e8.value, O7), s13 = _2({ ref: I6, id: R9, role: "radio", "aria-checked": l14 ? "true" : "false", "aria-labelledby": m10, "aria-describedby": P7, "aria-disabled": n13 ? true : void 0, tabIndex: (() => n13 ? -1 : l14 || !e8.containsCheckedOption && h7 ? 0 : -1)(), onClick: n13 ? void 0 : U8, autoFocus: f22 }, L6, M9), A7 = (0, import_react107.useMemo)(() => ({ checked: l14, disabled: n13, active: v4, hover: D7, focus: v4, autofocus: f22 }), [l14, n13, D7, v4, f22]), S7 = L();
  return import_react107.default.createElement(C9, { name: "RadioGroup.Description" }, import_react107.default.createElement(T10, { name: "RadioGroup.Label" }, S7({ ourProps: s13, theirProps: c15, slot: A7, defaultTag: Se3, name: "RadioGroup.Option" })));
}
var we2 = "span";
function Ne3(o17, t11) {
  var y9;
  let e8 = X3("Radio"), a20 = q3("Radio"), g6 = (0, import_react51.useId)(), R9 = u5(), O7 = a3(), { id: n13 = R9 || `headlessui-radio-${g6}`, value: f22, disabled: c15 = e8.disabled || O7 || false, autoFocus: p6 = false, ...I6 } = o17, m10 = (0, import_react107.useRef)(null), T10 = y(m10, t11), P7 = I(), C9 = U2(), i15 = s3({ value: f22, disabled: c15 });
  n(() => a20.registerOption({ id: n13, element: m10, propsRef: i15 }), [n13, a20, m10, i15]);
  let U8 = o4((d13) => {
    var _9;
    if (r5(d13.currentTarget))
      return d13.preventDefault();
    a20.change(f22) && ((_9 = m10.current) == null || _9.focus());
  }), { isFocusVisible: h7, focusProps: v4 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: p6 }), { isHovered: L6, hoverProps: D7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: c15 }), M9 = ((y9 = e8.firstOption) == null ? void 0 : y9.id) === n13, l14 = e8.compare(e8.value, f22), s13 = _2({ ref: T10, id: n13, role: "radio", "aria-checked": l14 ? "true" : "false", "aria-labelledby": P7, "aria-describedby": C9, "aria-disabled": c15 ? true : void 0, tabIndex: (() => c15 ? -1 : l14 || !e8.containsCheckedOption && M9 ? 0 : -1)(), autoFocus: p6, onClick: c15 ? void 0 : U8 }, v4, D7), A7 = (0, import_react107.useMemo)(() => ({ checked: l14, disabled: c15, hover: L6, focus: h7, autofocus: p6 }), [l14, c15, L6, h7, p6]);
  return L()({ ourProps: s13, theirProps: I6, slot: A7, defaultTag: we2, name: "Radio" });
}
var We2 = K(Me4);
var Be2 = K(He3);
var Ve = K(Ne3);
var Ke = Q;
var $e2 = H4;
var Rt4 = Object.assign(We2, { Option: Be2, Radio: Ve, Label: Ke, Description: $e2 });

// ../../node_modules/@headlessui/react/dist/components/select/select.js
var import_react108 = __toESM(require_react(), 1);
var H11 = "select";
function B2(a20, i15) {
  let p6 = (0, import_react51.useId)(), d13 = u5(), n13 = a3(), { id: c15 = d13 || `headlessui-select-${p6}`, disabled: e8 = n13 || false, invalid: t11 = false, autoFocus: o17 = false, ...f22 } = a20, m10 = I(), u17 = U2(), { isFocusVisible: r18, focusProps: T10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o17 }), { isHovered: l14, hoverProps: b9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), { pressed: s13, pressProps: y9 } = w({ disabled: e8 }), P7 = _2({ ref: i15, id: c15, "aria-labelledby": m10, "aria-describedby": u17, "aria-invalid": t11 ? "" : void 0, disabled: e8 || void 0, autoFocus: o17 }, T10, b9, y9), S7 = (0, import_react108.useMemo)(() => ({ disabled: e8, invalid: t11, hover: l14, focus: r18, active: s13, autofocus: o17 }), [e8, t11, l14, r18, s13, o17]);
  return L()({ ourProps: P7, theirProps: f22, slot: S7, defaultTag: H11, name: "Select" });
}
var j8 = K(B2);

// ../../node_modules/@headlessui/react/dist/components/switch/switch.js
var import_react109 = __toESM(require_react(), 1);
var E10 = (0, import_react109.createContext)(null);
E10.displayName = "GroupContext";
var De5 = import_react109.Fragment;
function ge4(n13) {
  var u17;
  let [o17, s13] = (0, import_react109.useState)(null), [h7, b9] = K2(), [T10, t11] = w3(), p6 = (0, import_react109.useMemo)(() => ({ switch: o17, setSwitch: s13 }), [o17, s13]), y9 = {}, S7 = n13, c15 = L();
  return import_react109.default.createElement(t11, { name: "Switch.Description", value: T10 }, import_react109.default.createElement(b9, { name: "Switch.Label", value: h7, props: { htmlFor: (u17 = p6.switch) == null ? void 0 : u17.id, onClick(d13) {
    o17 && (d13.currentTarget instanceof HTMLLabelElement && d13.preventDefault(), o17.click(), o17.focus({ preventScroll: true }));
  } } }, import_react109.default.createElement(E10.Provider, { value: p6 }, c15({ ourProps: y9, theirProps: S7, slot: {}, defaultTag: De5, name: "Switch.Group" }))));
}
var ve2 = "button";
function xe3(n13, o17) {
  var L6;
  let s13 = (0, import_react51.useId)(), h7 = u5(), b9 = a3(), { id: T10 = h7 || `headlessui-switch-${s13}`, disabled: t11 = b9 || false, checked: p6, defaultChecked: y9, onChange: S7, name: c15, value: u17, form: d13, autoFocus: m10 = false, ...F6 } = n13, _9 = (0, import_react109.useContext)(E10), [H13, k5] = (0, import_react109.useState)(null), M9 = (0, import_react109.useRef)(null), U8 = y(M9, o17, _9 === null ? null : _9.setSwitch, k5), l14 = l2(y9), [a20, r18] = T(p6, S7, l14 != null ? l14 : false), I6 = p(), [P7, D7] = (0, import_react109.useState)(false), g6 = o4(() => {
    D7(true), r18 == null || r18(!a20), I6.nextFrame(() => {
      D7(false);
    });
  }), B3 = o4((e8) => {
    if (r5(e8.currentTarget))
      return e8.preventDefault();
    e8.preventDefault(), g6();
  }), K4 = o4((e8) => {
    e8.key === o8.Space ? (e8.preventDefault(), g6()) : e8.key === o8.Enter && p2(e8.currentTarget);
  }), W5 = o4((e8) => e8.preventDefault()), O7 = I(), N4 = U2(), { isFocusVisible: v4, focusProps: J7 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: m10 }), { isHovered: x10, hoverProps: V6 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: t11 }), { pressed: C9, pressProps: X4 } = w({ disabled: t11 }), j9 = (0, import_react109.useMemo)(() => ({ checked: a20, disabled: t11, hover: x10, focus: v4, active: C9, autofocus: m10, changing: P7 }), [a20, x10, v4, C9, t11, P7, m10]), $3 = _2({ id: T10, ref: U8, role: "switch", type: e6(n13, H13), tabIndex: n13.tabIndex === -1 ? 0 : (L6 = n13.tabIndex) != null ? L6 : 0, "aria-checked": a20, "aria-labelledby": O7, "aria-describedby": N4, disabled: t11 || void 0, autoFocus: m10, onClick: B3, onKeyUp: K4, onKeyPress: W5 }, J7, V6, X4), q4 = (0, import_react109.useCallback)(() => {
    if (l14 !== void 0)
      return r18 == null ? void 0 : r18(l14);
  }, [r18, l14]), z4 = L();
  return import_react109.default.createElement(import_react109.default.Fragment, null, c15 != null && import_react109.default.createElement(j2, { disabled: t11, data: { [c15]: u17 || "on" }, overrides: { type: "checkbox", checked: a20 }, form: d13, onReset: q4 }), z4({ ourProps: $3, theirProps: F6, slot: j9, defaultTag: ve2, name: "Switch" }));
}
var Ce3 = K(xe3);
var Le3 = ge4;
var Re3 = Q;
var Ge3 = H4;
var Ye3 = Object.assign(Ce3, { Group: Le3, Label: Re3, Description: Ge3 });

// ../../node_modules/@headlessui/react/dist/components/tabs/tabs.js
var import_react111 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/internal/focus-sentinel.js
var import_react110 = __toESM(require_react(), 1);
function b8({ onFocus: n13 }) {
  let [r18, o17] = (0, import_react110.useState)(true), u17 = f19();
  return r18 ? import_react110.default.createElement(f4, { as: "button", type: "button", features: s4.Focusable, onFocus: (a20) => {
    a20.preventDefault();
    let e8, i15 = 50;
    function t11() {
      if (i15-- <= 0) {
        e8 && cancelAnimationFrame(e8);
        return;
      }
      if (n13()) {
        if (cancelAnimationFrame(e8), !u17.current)
          return;
        o17(false);
        return;
      }
      e8 = requestAnimationFrame(t11);
    }
    e8 = requestAnimationFrame(t11);
  } }) : null;
}

// ../../node_modules/@headlessui/react/dist/utils/stable-collection.js
var l13 = __toESM(require_react(), 1);
var s12 = l13.createContext(null);
function a19() {
  return { groups: /* @__PURE__ */ new Map(), get(o17, e8) {
    var i15;
    let t11 = this.groups.get(o17);
    t11 || (t11 = /* @__PURE__ */ new Map(), this.groups.set(o17, t11));
    let n13 = (i15 = t11.get(e8)) != null ? i15 : 0;
    t11.set(e8, n13 + 1);
    let r18 = Array.from(t11.keys()).indexOf(e8);
    function u17() {
      let c15 = t11.get(e8);
      c15 > 1 ? t11.set(e8, c15 - 1) : t11.delete(e8);
    }
    return [r18, u17];
  } };
}
function f21({ children: o17 }) {
  let e8 = l13.useRef(a19());
  return l13.createElement(s12.Provider, { value: e8 }, o17);
}
function C7(o17) {
  let e8 = l13.useContext(s12);
  if (!e8)
    throw new Error("You must wrap your component in a <StableCollection>");
  let t11 = l13.useId(), [n13, r18] = e8.current.get(o17, t11);
  return l13.useEffect(() => r18, []), n13;
}

// ../../node_modules/@headlessui/react/dist/components/tabs/tabs.js
var Le4 = ((t11) => (t11[t11.Forwards = 0] = "Forwards", t11[t11.Backwards = 1] = "Backwards", t11))(Le4 || {});
var _e3 = ((l14) => (l14[l14.Less = -1] = "Less", l14[l14.Equal = 0] = "Equal", l14[l14.Greater = 1] = "Greater", l14))(_e3 || {});
var De6 = ((n13) => (n13[n13.SetSelectedIndex = 0] = "SetSelectedIndex", n13[n13.RegisterTab = 1] = "RegisterTab", n13[n13.UnregisterTab = 2] = "UnregisterTab", n13[n13.RegisterPanel = 3] = "RegisterPanel", n13[n13.UnregisterPanel = 4] = "UnregisterPanel", n13))(De6 || {});
var Se4 = { [0](e8, r18) {
  var d13;
  let t11 = _4(e8.tabs, (u17) => u17.current), l14 = _4(e8.panels, (u17) => u17.current), a20 = t11.filter((u17) => {
    var T10;
    return !((T10 = u17.current) != null && T10.hasAttribute("disabled"));
  }), n13 = { ...e8, tabs: t11, panels: l14 };
  if (r18.index < 0 || r18.index > t11.length - 1) {
    let u17 = u2(Math.sign(r18.index - e8.selectedIndex), { [-1]: () => 1, [0]: () => u2(Math.sign(r18.index), { [-1]: () => 0, [0]: () => 0, [1]: () => 1 }), [1]: () => 0 });
    if (a20.length === 0)
      return n13;
    let T10 = u2(u17, { [0]: () => t11.indexOf(a20[0]), [1]: () => t11.indexOf(a20[a20.length - 1]) });
    return { ...n13, selectedIndex: T10 === -1 ? e8.selectedIndex : T10 };
  }
  let s13 = t11.slice(0, r18.index), b9 = [...t11.slice(r18.index), ...s13].find((u17) => a20.includes(u17));
  if (!b9)
    return n13;
  let f22 = (d13 = t11.indexOf(b9)) != null ? d13 : e8.selectedIndex;
  return f22 === -1 && (f22 = e8.selectedIndex), { ...n13, selectedIndex: f22 };
}, [1](e8, r18) {
  if (e8.tabs.includes(r18.tab))
    return e8;
  let t11 = e8.tabs[e8.selectedIndex], l14 = _4([...e8.tabs, r18.tab], (n13) => n13.current), a20 = e8.selectedIndex;
  return e8.info.current.isControlled || (a20 = l14.indexOf(t11), a20 === -1 && (a20 = e8.selectedIndex)), { ...e8, tabs: l14, selectedIndex: a20 };
}, [2](e8, r18) {
  return { ...e8, tabs: e8.tabs.filter((t11) => t11 !== r18.tab) };
}, [3](e8, r18) {
  return e8.panels.includes(r18.panel) ? e8 : { ...e8, panels: _4([...e8.panels, r18.panel], (t11) => t11.current) };
}, [4](e8, r18) {
  return { ...e8, panels: e8.panels.filter((t11) => t11 !== r18.panel) };
} };
var V5 = (0, import_react111.createContext)(null);
V5.displayName = "TabsDataContext";
function C8(e8) {
  let r18 = (0, import_react111.useContext)(V5);
  if (r18 === null) {
    let t11 = new Error(`<${e8} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t11, C8), t11;
  }
  return r18;
}
var Q5 = (0, import_react111.createContext)(null);
Q5.displayName = "TabsActionsContext";
function Y3(e8) {
  let r18 = (0, import_react111.useContext)(Q5);
  if (r18 === null) {
    let t11 = new Error(`<${e8} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t11, Y3), t11;
  }
  return r18;
}
function Fe4(e8, r18) {
  return u2(r18.type, Se4, e8, r18);
}
var Ie6 = "div";
function he2(e8, r18) {
  let { defaultIndex: t11 = 0, vertical: l14 = false, manual: a20 = false, onChange: n13, selectedIndex: s13 = null, ...g6 } = e8;
  const b9 = l14 ? "vertical" : "horizontal", f22 = a20 ? "manual" : "auto";
  let d13 = s13 !== null, u17 = s3({ isControlled: d13 }), T10 = y(r18), [p6, c15] = (0, import_react111.useReducer)(Fe4, { info: u17, selectedIndex: s13 != null ? s13 : t11, tabs: [], panels: [] }), h7 = (0, import_react111.useMemo)(() => ({ selectedIndex: p6.selectedIndex }), [p6.selectedIndex]), m10 = s3(n13 || (() => {
  })), M9 = s3(p6.tabs), S7 = (0, import_react111.useMemo)(() => ({ orientation: b9, activation: f22, ...p6 }), [b9, f22, p6]), P7 = o4((i15) => (c15({ type: 1, tab: i15 }), () => c15({ type: 2, tab: i15 }))), A7 = o4((i15) => (c15({ type: 3, panel: i15 }), () => c15({ type: 4, panel: i15 }))), E12 = o4((i15) => {
    _9.current !== i15 && m10.current(i15), d13 || c15({ type: 0, index: i15 });
  }), _9 = s3(d13 ? e8.selectedIndex : p6.selectedIndex), D7 = (0, import_react111.useMemo)(() => ({ registerTab: P7, registerPanel: A7, change: E12 }), []);
  n(() => {
    c15({ type: 0, index: s13 != null ? s13 : t11 });
  }, [s13]), n(() => {
    if (_9.current === void 0 || p6.tabs.length <= 0)
      return;
    let i15 = _4(p6.tabs, (R9) => R9.current);
    i15.some((R9, X4) => p6.tabs[X4] !== R9) && E12(i15.indexOf(p6.tabs[_9.current]));
  });
  let K4 = { ref: T10 }, J7 = L();
  return import_react111.default.createElement(f21, null, import_react111.default.createElement(Q5.Provider, { value: D7 }, import_react111.default.createElement(V5.Provider, { value: S7 }, S7.tabs.length <= 0 && import_react111.default.createElement(b8, { onFocus: () => {
    var i15, G7;
    for (let R9 of M9.current)
      if (((i15 = R9.current) == null ? void 0 : i15.tabIndex) === 0)
        return (G7 = R9.current) == null || G7.focus(), true;
    return false;
  } }), J7({ ourProps: K4, theirProps: g6, slot: h7, defaultTag: Ie6, name: "Tabs" }))));
}
var ve3 = "div";
function Ce4(e8, r18) {
  let { orientation: t11, selectedIndex: l14 } = C8("Tab.List"), a20 = y(r18), n13 = (0, import_react111.useMemo)(() => ({ selectedIndex: l14 }), [l14]), s13 = e8, g6 = { ref: a20, role: "tablist", "aria-orientation": t11 };
  return L()({ ourProps: g6, theirProps: s13, slot: n13, defaultTag: ve3, name: "Tabs.List" });
}
var Me5 = "button";
function Ge4(e8, r18) {
  var ee7, te6;
  let t11 = (0, import_react51.useId)(), { id: l14 = `headlessui-tabs-tab-${t11}`, disabled: a20 = false, autoFocus: n13 = false, ...s13 } = e8, { orientation: g6, activation: b9, selectedIndex: f22, tabs: d13, panels: u17 } = C8("Tab"), T10 = Y3("Tab"), p6 = C8("Tab"), [c15, h7] = (0, import_react111.useState)(null), m10 = (0, import_react111.useRef)(null), M9 = y(m10, r18, h7);
  n(() => T10.registerTab(m10), [T10, m10]);
  let S7 = C7("tabs"), P7 = d13.indexOf(m10);
  P7 === -1 && (P7 = S7);
  let A7 = P7 === f22, E12 = o4((o17) => {
    var $3;
    let L6 = o17();
    if (L6 === T5.Success && b9 === "auto") {
      let q4 = ($3 = u(m10)) == null ? void 0 : $3.activeElement, re5 = p6.tabs.findIndex((ce5) => ce5.current === q4);
      re5 !== -1 && T10.change(re5);
    }
    return L6;
  }), _9 = o4((o17) => {
    let L6 = d13.map((q4) => q4.current).filter(Boolean);
    if (o17.key === o8.Space || o17.key === o8.Enter) {
      o17.preventDefault(), o17.stopPropagation(), T10.change(P7);
      return;
    }
    switch (o17.key) {
      case o8.Home:
      case o8.PageUp:
        return o17.preventDefault(), o17.stopPropagation(), E12(() => P6(L6, F2.First));
      case o8.End:
      case o8.PageDown:
        return o17.preventDefault(), o17.stopPropagation(), E12(() => P6(L6, F2.Last));
    }
    if (E12(() => u2(g6, { vertical() {
      return o17.key === o8.ArrowUp ? P6(L6, F2.Previous | F2.WrapAround) : o17.key === o8.ArrowDown ? P6(L6, F2.Next | F2.WrapAround) : T5.Error;
    }, horizontal() {
      return o17.key === o8.ArrowLeft ? P6(L6, F2.Previous | F2.WrapAround) : o17.key === o8.ArrowRight ? P6(L6, F2.Next | F2.WrapAround) : T5.Error;
    } })) === T5.Success)
      return o17.preventDefault();
  }), D7 = (0, import_react111.useRef)(false), K4 = o4(() => {
    var o17;
    D7.current || (D7.current = true, (o17 = m10.current) == null || o17.focus({ preventScroll: true }), T10.change(P7), t(() => {
      D7.current = false;
    }));
  }), J7 = o4((o17) => {
    o17.preventDefault();
  }), { isFocusVisible: i15, focusProps: G7 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n13 }), { isHovered: R9, hoverProps: X4 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: a20 }), { pressed: Z4, pressProps: ue5 } = w({ disabled: a20 }), Te6 = (0, import_react111.useMemo)(() => ({ selected: A7, hover: R9, active: Z4, focus: i15, autofocus: n13, disabled: a20 }), [A7, R9, i15, Z4, n13, a20]), de6 = _2({ ref: M9, onKeyDown: _9, onMouseDown: J7, onClick: K4, id: l14, role: "tab", type: e6(e8, c15), "aria-controls": (te6 = (ee7 = u17[P7]) == null ? void 0 : ee7.current) == null ? void 0 : te6.id, "aria-selected": A7, tabIndex: A7 ? 0 : -1, disabled: a20 || void 0, autoFocus: n13 }, G7, X4, ue5);
  return L()({ ourProps: de6, theirProps: s13, slot: Te6, defaultTag: Me5, name: "Tabs.Tab" });
}
var Ue4 = "div";
function He4(e8, r18) {
  let { selectedIndex: t11 } = C8("Tab.Panels"), l14 = y(r18), a20 = (0, import_react111.useMemo)(() => ({ selectedIndex: t11 }), [t11]), n13 = e8, s13 = { ref: l14 };
  return L()({ ourProps: s13, theirProps: n13, slot: a20, defaultTag: Ue4, name: "Tabs.Panels" });
}
var we3 = "div";
var Oe3 = O.RenderStrategy | O.Static;
function Ne4(e8, r18) {
  var A7, E12, _9, D7;
  let t11 = (0, import_react51.useId)(), { id: l14 = `headlessui-tabs-panel-${t11}`, tabIndex: a20 = 0, ...n13 } = e8, { selectedIndex: s13, tabs: g6, panels: b9 } = C8("Tab.Panel"), f22 = Y3("Tab.Panel"), d13 = (0, import_react111.useRef)(null), u17 = y(d13, r18);
  n(() => f22.registerPanel(d13), [f22, d13]);
  let T10 = C7("panels"), p6 = b9.indexOf(d13);
  p6 === -1 && (p6 = T10);
  let c15 = p6 === s13, { isFocusVisible: h7, focusProps: m10 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), M9 = (0, import_react111.useMemo)(() => ({ selected: c15, focus: h7 }), [c15, h7]), S7 = _2({ ref: u17, id: l14, role: "tabpanel", "aria-labelledby": (E12 = (A7 = g6[p6]) == null ? void 0 : A7.current) == null ? void 0 : E12.id, tabIndex: c15 ? a20 : -1 }, m10), P7 = L();
  return !c15 && ((_9 = n13.unmount) == null || _9) && !((D7 = n13.static) != null && D7) ? import_react111.default.createElement(f4, { "aria-hidden": "true", ...S7 }) : P7({ ourProps: S7, theirProps: n13, slot: M9, defaultTag: we3, features: Oe3, visible: c15, name: "Tabs.Panel" });
}
var ke3 = K(Ge4);
var Be3 = K(he2);
var We3 = K(Ce4);
var je3 = K(He4);
var Ke2 = K(Ne4);
var Tt3 = Object.assign(ke3, { Group: Be3, List: We3, Panels: je3, Panel: Ke2 });

// ../../node_modules/@headlessui/react/dist/components/textarea/textarea.js
var import_react112 = __toESM(require_react(), 1);
var L5 = "textarea";
function H12(s13, l14) {
  let i15 = (0, import_react51.useId)(), d13 = u5(), n13 = a3(), { id: p6 = d13 || `headlessui-textarea-${i15}`, disabled: e8 = n13 || false, autoFocus: r18 = false, invalid: a20 = false, ...T10 } = s13, f22 = I(), m10 = U2(), { isFocused: o17, focusProps: u17 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r18 }), { isHovered: t11, hoverProps: b9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e8 }), y9 = _2({ ref: l14, id: p6, "aria-labelledby": f22, "aria-describedby": m10, "aria-invalid": a20 ? "" : void 0, disabled: e8 || void 0, autoFocus: r18 }, u17, b9), x10 = (0, import_react112.useMemo)(() => ({ disabled: e8, invalid: a20, hover: t11, focus: o17, autofocus: r18 }), [e8, a20, t11, o17, r18]);
  return L()({ ourProps: y9, theirProps: T10, slot: x10, defaultTag: L5, name: "Textarea" });
}
var J6 = K(H12);

// ../../node_modules/@nfid/identitykit/dist/libs/react/index.esm.js
var import_colors = __toESM(require_colors2());

// ../../node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React20 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React4 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup2 = setRef(ref, node);
      if (!hasCleanup && typeof cleanup2 == "function") {
        hasCleanup = true;
      }
      return cleanup2;
    });
    if (hasCleanup) {
      return () => {
        for (let i15 = 0; i15 < cleanups.length; i15++) {
          const cleanup2 = cleanups[i15];
          if (typeof cleanup2 == "function") {
            cleanup2();
          } else {
            setRef(refs[i15], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React4.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/@radix-ui/react-context/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context2 = React5.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = React5.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime.jsx)(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React5.useContext(Context2);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React5.createContext(defaultContext);
    const index3 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a4;
      const { scope, children, ...context } = props;
      const Context2 = ((_a4 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a4[index3]) || BaseContext;
      const value = React5.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime.jsx)(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a4;
      const Context2 = ((_a4 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a4[index3]) || BaseContext;
      const context = React5.useContext(Context2);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React5.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React5.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes3) {
  const baseScope = scopes3[0];
  if (scopes3.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes3.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React5.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React10 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var Slot = React6.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React6.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React6.Children.count(newElement) > 1)
          return React6.Children.only(null);
        return React6.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React6.isValidElement(newElement) ? React6.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React6.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React6.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps2(slotProps, children.props);
    if (children.type !== React6.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React6.cloneElement(children, props2);
  }
  return React6.Children.count(children) > 1 ? React6.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
};
function isSlottable(child) {
  return React6.isValidElement(child) && child.type === Slottable;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a4, _b;
  let getter = (_a4 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a4.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React7.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime3.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM3.flushSync(() => target.dispatchEvent(event));
}

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React8 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React8.useRef(callback);
  React8.useEffect(() => {
    callbackRef.current = callback;
  });
  return React8.useMemo(() => (...args) => {
    var _a4;
    return (_a4 = callbackRef.current) == null ? void 0 : _a4.call(callbackRef, ...args);
  }, []);
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React9 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React9.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React10.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React10.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React10.useContext(DismissableLayerContext);
    const [node, setNode] = React10.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React10.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index3 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index3 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index3 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React10.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React10.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React10.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime4.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React10.forwardRef((props, forwardedRef) => {
  const context = React10.useContext(DismissableLayerContext);
  const ref = React10.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React10.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime4.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React10.useRef(false);
  const handleClickRef = React10.useRef(() => {
  });
  React10.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React10.useRef(false);
  React10.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
var React12 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var useLayoutEffect22 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React11.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId2 = React12["useId".toString()] || (() => void 0);
var count2 = 0;
function useId3(deterministicId) {
  const [id, setId] = React12.useState(useReactId2());
  useLayoutEffect22(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count2++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var React15 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
var React13 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React13.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime5.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime5.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// ../../node_modules/@radix-ui/react-use-size/dist/index.mjs
var React14 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React14.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React15.useState(null);
  return (0, import_jsx_runtime6.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React15.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React15.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React15.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime6.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React15.forwardRef(
  (props, forwardedRef) => {
    var _a4, _b, _c, _d, _e4, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React15.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React15.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup2 = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup2;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a4 = middlewareData.arrow) == null ? void 0 : _a4.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React15.useState();
    useLayoutEffect22(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime6.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e4 = middlewareData.transformOrigin) == null ? void 0 : _e4.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime6.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime6.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React15.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime6.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime6.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a4, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a4 = middlewareData.arrow) == null ? void 0 : _a4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x10 = "";
    let y9 = "";
    if (placedSide === "bottom") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y9 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y9 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x10 = `${-arrowHeight}px`;
      y9 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x10 = `${rects.floating.width + arrowHeight}px`;
      y9 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x10, y: y9 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// ../../node_modules/@radix-ui/react-portal/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var import_react_dom12 = __toESM(require_react_dom(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React16.forwardRef((props, forwardedRef) => {
  var _a4;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React16.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a4 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a4.body);
  return container ? import_react_dom12.default.createPortal((0, import_jsx_runtime7.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// ../../node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var React17 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React17.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId2;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId2 = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId2);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2)
        stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a4, _b;
  let getter = (_a4 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a4.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React18 = __toESM(require_react(), 1);
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React18.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop)
          handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React18.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React18.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React18.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// ../../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React19 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "VisuallyHidden";
var VisuallyHidden = React19.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime8.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME2;
var Root3 = VisuallyHidden;

// ../../node_modules/@radix-ui/react-tooltip/dist/index.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = React20.useState(true);
  const isPointerInTransitRef = React20.useRef(false);
  const skipDelayTimerRef = React20.useRef(0);
  React20.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime9.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React20.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React20.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React20.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React20.useState(null);
  const contentId = useId3();
  const openTimerRef = React20.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React20.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = React20.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React20.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React20.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React20.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React20.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime9.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime9.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React20.useCallback(() => {
        if (providerContext.isOpenDelayed)
          handleDelayedOpen();
        else
          handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React20.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React20.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React20.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React20.useRef(false);
    const hasPointerMoveOpenedRef = React20.useRef(false);
    const handlePointerUp = React20.useCallback(() => isPointerDownRef.current = false, []);
    React20.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return (0, import_jsx_runtime9.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime9.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch")
            return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current)
            context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME2, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME2, __scopeTooltip);
  return (0, import_jsx_runtime9.jsx)(PortalProvider, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime9.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime9.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "TooltipContent";
var TooltipContent = React20.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
    return (0, import_jsx_runtime9.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime9.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime9.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React20.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME2, props.__scopeTooltip);
  const ref = React20.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React20.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React20.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React20.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React20.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React20.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React20.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger == null ? void 0 : trigger.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime9.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React20.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React20.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React20.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger))
            onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime9.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime9.jsxs)(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime9.jsx)(Slottable, { children }),
              (0, import_jsx_runtime9.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime9.jsx)(Root3, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME2;
var ARROW_NAME2 = "TooltipArrow";
var TooltipArrow = React20.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime9.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME2;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x10, y: y9 } = point;
  let inside = false;
  for (let i15 = 0, j9 = polygon.length - 1; i15 < polygon.length; j9 = i15++) {
    const xi = polygon[i15].x;
    const yi = polygon[i15].y;
    const xj = polygon[j9].x;
    const yj = polygon[j9].y;
    const intersect = yi > y9 !== yj > y9 && x10 < (xj - xi) * (y9 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a20, b9) => {
    if (a20.x < b9.x)
      return -1;
    else if (a20.x > b9.x)
      return 1;
    else if (a20.y < b9.y)
      return -1;
    else if (a20.y > b9.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i15 = 0; i15 < points.length; i15++) {
    const p6 = points[i15];
    while (upperHull.length >= 2) {
      const q4 = upperHull[upperHull.length - 1];
      const r18 = upperHull[upperHull.length - 2];
      if ((q4.x - r18.x) * (p6.y - r18.y) >= (q4.y - r18.y) * (p6.x - r18.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p6);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i15 = points.length - 1; i15 >= 0; i15--) {
    const p6 = points[i15];
    while (lowerHull.length >= 2) {
      const q4 = lowerHull[lowerHull.length - 1];
      const r18 = lowerHull[lowerHull.length - 2];
      if ((q4.x - r18.x) * (p6.y - r18.y) >= (q4.y - r18.y) * (p6.x - r18.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p6);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Root32 = Tooltip;
var Trigger = TooltipTrigger;
var Portal2 = TooltipPortal;
var Content2 = TooltipContent;
var Arrow22 = TooltipArrow;

// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
var React33 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React21 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React21.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React21.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React21.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React21.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React21.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React21.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React21.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime10.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a4;
      stack = arrayRemove(stack, focusScope);
      (_a4 = stack[0]) == null ? void 0 : _a4.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index3 = updatedArray.indexOf(item);
  if (index3 !== -1) {
    updatedArray.splice(index3, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var count3 = 0;
function useFocusGuards() {
  React23.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count3++;
    return () => {
      if (count3 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count3--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t11) {
    for (var s13, i15 = 1, n13 = arguments.length; i15 < n13; i15++) {
      s13 = arguments[i15];
      for (var p6 in s13)
        if (Object.prototype.hasOwnProperty.call(s13, p6))
          t11[p6] = s13[p6];
    }
    return t11;
  };
  return __assign.apply(this, arguments);
};
function __rest(s13, e8) {
  var t11 = {};
  for (var p6 in s13)
    if (Object.prototype.hasOwnProperty.call(s13, p6) && e8.indexOf(p6) < 0)
      t11[p6] = s13[p6];
  if (s13 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i15 = 0, p6 = Object.getOwnPropertySymbols(s13); i15 < p6.length; i15++) {
      if (e8.indexOf(p6[i15]) < 0 && Object.prototype.propertyIsEnumerable.call(s13, p6[i15]))
        t11[p6[i15]] = s13[p6[i15]];
    }
  return t11;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i15 = 0, l14 = from.length, ar; i15 < l14; i15++) {
      if (ar || !(i15 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i15);
        ar[i15] = from[i15];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React32 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var React28 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react113 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react113.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React24 = __toESM(require_react());
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? React24.useLayoutEffect : React24.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs2(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect3(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../../node_modules/use-sidecar/dist/es2015/hoc.js
var React25 = __toESM(require_react());

// ../../node_modules/use-sidecar/dist/es2015/hook.js
var import_react114 = __toESM(require_react());

// ../../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a20) {
  return a20;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x10) {
          return x10 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x10) {
          return cb(x10);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x10) {
          pendingQueue.push(x10);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/renderProp.js
var React26 = __toESM(require_react());
var import_react115 = __toESM(require_react());

// ../../node_modules/use-sidecar/dist/es2015/exports.js
var React27 = __toESM(require_react());
var SideCar = function(_a4) {
  var sideCar = _a4.sideCar, rest = __rest(_a4, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React27.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React28.forwardRef(function(props, parentRef) {
  var ref = React28.useRef(null);
  var _a4 = React28.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a4[0], setCallbacks = _a4[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs2([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React28.createElement(
    React28.Fragment,
    null,
    enabled && React28.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React28.cloneElement(React28.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React28.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React31 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React30 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React29 = __toESM(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React29.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a4) {
    var styles = _a4.styles, dynamic = _a4.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x10) {
  return parseInt(x10 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a4, allowRelative, gapMode, important) {
  var left = _a4.left, top = _a4.top, right = _a4.right, gap = _a4.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React30.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a4) {
  var noRelative = _a4.noRelative, noImportant = _a4.noImportant, _b = _a4.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React30.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React30.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables(axis, current), scrollHeight = _a4[1], clientHeight = _a4[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables(axis, target), position = _a4[0], scroll_1 = _a4[1], capacity = _a4[2];
    var elementScroll2 = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll2) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll2;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x10, y9) {
  return x10[0] === y9[0] && x10[1] === y9[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React31.useRef([]);
  var touchStartRef = React31.useRef([0, 0]);
  var activeAxis = React31.useRef();
  var id = React31.useState(idCounter++)[0];
  var Style2 = React31.useState(styleSingleton)[0];
  var lastProps = React31.useRef(props);
  React31.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React31.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React31.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React31.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e8) {
      return e8.name === event.type && (e8.target === event.target || event.target === e8.shadowParent) && deltaCompare(e8.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React31.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e8) {
        return e8 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React31.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React31.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React31.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React31.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React31.createElement(
    React31.Fragment,
    null,
    inert ? React31.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React31.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React32.forwardRef(function(props, ref) {
  return React32.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount2 = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x10) {
    return Boolean(x10);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr2 = node.getAttribute(controlAttribute);
          var alreadyHidden = attr2 !== null && attr2 !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e8) {
          console.error("aria-hidden: cannot operate on ", node, e8);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount2++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount2--;
    if (!lockCount2) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React33.useRef(null);
  const contentRef = React33.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime11.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId3(),
      titleId: useId3(),
      descriptionId: useId3(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React33.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime11.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return (0, import_jsx_runtime11.jsx)(PortalProvider2, { scope: __scopeDialog, forceMount, children: React33.Children.map(children, (child) => (0, import_jsx_runtime11.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime11.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React33.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime11.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime11.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime11.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime11.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React33.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return (0, import_jsx_runtime11.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime11.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime11.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React33.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React33.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React33.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime11.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a4;
          event.preventDefault();
          (_a4 = context.triggerRef.current) == null ? void 0 : _a4.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React33.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React33.useRef(false);
    const hasPointerDownOutsideRef = React33.useRef(false);
    return (0, import_jsx_runtime11.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a4, _b;
          (_a4 = props.onCloseAutoFocus) == null ? void 0 : _a4.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a4, _b;
          (_a4 = props.onInteractOutside) == null ? void 0 : _a4.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React33.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
      (0, import_jsx_runtime11.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime11.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
        (0, import_jsx_runtime11.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime11.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime11.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime11.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime11.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React33.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React33.useEffect(() => {
    var _a4;
    const describedById = (_a4 = contentRef.current) == null ? void 0 : _a4.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Portal3 = DialogPortal;
var Content3 = DialogContent;
var Title = DialogTitle;

// ../../node_modules/@nfid/identitykit/dist/libs/react/index.esm.js
var IdentityKitTheme;
(function(IdentityKitTheme2) {
  IdentityKitTheme2["LIGHT"] = "light";
  IdentityKitTheme2["DARK"] = "dark";
  IdentityKitTheme2["SYSTEM"] = "system";
})(IdentityKitTheme || (IdentityKitTheme = {}));
var DEFAULT_SIZES = {
  width: 450,
  height: 640
};
var ThemeContext = (0, import_react116.createContext)(IdentityKitTheme.SYSTEM);
var Context = createContext(null);
var Agent = class _Agent {
  constructor(signerAgentStrategy, agentStrategy, delegation) {
    __publicField(this, "signerAgentStrategy");
    __publicField(this, "agentStrategy");
    __publicField(this, "delegation");
    this.signerAgentStrategy = signerAgentStrategy;
    this.agentStrategy = agentStrategy;
    this.delegation = delegation;
  }
  static async create({ delegation, signerAgent, agent }) {
    return new _Agent(signerAgent, agent, delegation);
  }
  async call(...params) {
    var _a4;
    const delegationTargets = (_a4 = this.delegation) == null ? void 0 : _a4.targets;
    const strategy = this.delegation && (!(delegationTargets == null ? void 0 : delegationTargets.length) || (delegationTargets == null ? void 0 : delegationTargets.find((t11) => t11.compareTo(Principal.from(params[0])) === "eq"))) ? this.agentStrategy : this.signerAgentStrategy;
    return strategy.call(...params);
  }
  async query(...params) {
    var _a4;
    const delegationTargets = (_a4 = this.delegation) == null ? void 0 : _a4.targets;
    const strategy = this.delegation && (!(delegationTargets == null ? void 0 : delegationTargets.length) || (delegationTargets == null ? void 0 : delegationTargets.find((t11) => t11.compareTo(Principal.from(params[0])) === "eq"))) ? this.agentStrategy : this.signerAgentStrategy;
    return strategy.query(...params);
  }
  get rootKey() {
    return this.agentStrategy.rootKey;
  }
  async fetchRootKey() {
    return this.agentStrategy.fetchRootKey();
  }
  async getPrincipal() {
    return this.agentStrategy.getPrincipal();
  }
  async status() {
    return this.agentStrategy.status();
  }
  async readState(...params) {
    var _a4;
    const delegationTargets = (_a4 = this.delegation) == null ? void 0 : _a4.targets;
    const strategy = this.delegation && (!(delegationTargets == null ? void 0 : delegationTargets.length) || (delegationTargets == null ? void 0 : delegationTargets.find((t11) => t11.compareTo(Principal.from(params[0])) === "eq"))) ? this.agentStrategy : this.signerAgentStrategy;
    return strategy.readState(...params);
  }
  async createReadStateRequest(...params) {
    var _a4, _b;
    return (_b = (_a4 = this.agentStrategy).createReadStateRequest) == null ? void 0 : _b.call(_a4, ...params);
  }
};
var DEFAULT_MAX_TIME_TO_LIVE = BigInt(18e11);
var DEFAULT_IDLE_TIMEOUT = 144e5;
var TIMEOUT_MAX_DELAY = 2147483647;
var TimeoutManager = class {
  /**
   * @param options {@link IdleManagerOptions}
   */
  constructor(options) {
    __publicField(this, "callbacks", []);
    __publicField(this, "timeout");
    __publicField(this, "timeoutID");
    const { onTimeout, timeout } = options || {};
    this.callbacks = onTimeout ? [onTimeout] : [];
    this.timeout = timeout > TIMEOUT_MAX_DELAY ? TIMEOUT_MAX_DELAY : timeout;
    const _resetTimer = this._resetTimer.bind(this);
    window.addEventListener("load", _resetTimer, true);
    _resetTimer();
  }
  /**
   * @param {TimeoutCB} callback function to be called on timeout
   */
  registerCallback(callback) {
    this.callbacks.push(callback);
  }
  /**
   * Cleans up the timeout manager and its listeners
   */
  exit() {
    clearTimeout(this.timeoutID);
    window.removeEventListener("load", this._resetTimer, true);
  }
  /**
   * Resets the timeouts during cleanup
   */
  _resetTimer() {
    const exit = this.exit.bind(this);
    window.clearTimeout(this.timeoutID);
    this.timeoutID = window.setTimeout(() => {
      exit();
      this.callbacks.forEach((cb) => cb());
    }, this.timeout);
  }
};
var events2 = ["mousedown", "mousemove", "keydown", "touchstart", "wheel"];
var IdleManager2 = class extends TimeoutManager {
  constructor(options = {}) {
    super({ timeout: options.idleTimeout || DEFAULT_IDLE_TIMEOUT, onTimeout: options.onIdle });
    const _resetTimer = this._resetTimer.bind(this);
    events2.forEach(function(name) {
      document.addEventListener(name, _resetTimer, true);
    });
    const debounce2 = (func, wait) => {
      let timeout;
      return (...args) => {
        const context = this;
        const later = function() {
          timeout = void 0;
          func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = window.setTimeout(later, wait);
      };
    };
    if (options == null ? void 0 : options.captureScroll) {
      const scroll = debounce2(_resetTimer, (options == null ? void 0 : options.scrollDebounce) ?? 100);
      window.addEventListener("scroll", scroll, true);
    }
  }
};
var STORAGE_KEY = "client";
var STORAGE_CONNECTED_OWNER_KEY = "connected-owner";
var STORAGE_CONNECTED_SUBACCOUNT_KEY = "connected-subaccount";
var SignerClient = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "idleManager");
    __publicField(this, "storage", new IdbStorage());
    __publicField(this, "connectedUser");
    var _a4;
    this.options = options;
    if (!((_a4 = options == null ? void 0 : options.idleOptions) == null ? void 0 : _a4.disableIdle)) {
      this.idleManager = new IdleManager2(options.idleOptions);
      this.registerDefaultIdleCallback();
    }
    if (options.storage)
      this.storage = options.storage;
  }
  registerDefaultIdleCallback() {
    var _a4, _b, _c;
    if (!((_b = (_a4 = this.options) == null ? void 0 : _a4.idleOptions) == null ? void 0 : _b.disableDefaultIdleCallback)) {
      (_c = this.idleManager) == null ? void 0 : _c.registerCallback(async () => {
        await this.logout();
      });
    }
  }
  async logout(options) {
    var _a4, _b, _c;
    await this.setConnectedUserToStorage(void 0);
    (_a4 = this.idleManager) == null ? void 0 : _a4.exit();
    this.idleManager = void 0;
    await ((_c = (_b = this.options).onLogout) == null ? void 0 : _c.call(_b));
    if (options == null ? void 0 : options.returnTo) {
      try {
        window.history.pushState({}, "", options.returnTo);
      } catch (e8) {
        window.location.href = options.returnTo;
      }
    }
  }
  async setConnectedUser(user) {
    if (!user)
      this.connectedUser = void 0;
    else {
      let subAccount;
      if (user.subAccount) {
        const subAccountOrError = _.fromBytes(new Uint8Array(user.subAccount));
        if (typeof subAccountOrError === typeof Error) {
          throw subAccount;
        }
        subAccount = subAccountOrError;
      }
      this.connectedUser = {
        principal: Principal.from(user.owner),
        subAccount
      };
    }
  }
  async setConnectedUserToStorage(user) {
    if (!user) {
      await this.storage.remove(STORAGE_CONNECTED_OWNER_KEY);
      await this.storage.remove(STORAGE_CONNECTED_SUBACCOUNT_KEY);
      localStorage.removeItem("connected");
      this.setConnectedUser(void 0);
      return;
    }
    await this.storage.set(STORAGE_CONNECTED_OWNER_KEY, user.owner);
    localStorage.setItem("connected", "1");
    if (user.subAccount)
      await this.storage.set(STORAGE_CONNECTED_SUBACCOUNT_KEY, new TextDecoder().decode(user.subAccount));
    this.setConnectedUser({
      owner: user.owner,
      subAccount: user.subAccount
    });
  }
  // sync method to check if it's needed to check authorization reading from async storage
  static shouldCheckIsUserConnected() {
    return !!localStorage.getItem("connected");
  }
  async getConnectedUserFromStorage() {
    const owner = await this.storage.get(STORAGE_CONNECTED_OWNER_KEY);
    if (!owner)
      return;
    const subAccount = await this.storage.get(STORAGE_CONNECTED_SUBACCOUNT_KEY);
    return {
      owner: owner.toString(),
      subAccount: subAccount ? new TextEncoder().encode(subAccount.toString()).buffer : void 0
    };
  }
  get crypto() {
    return this.options.crypto ?? globalThis.crypto;
  }
};
var ED25519_KEY_LABEL2 = "Ed25519";
var DelegationType;
(function(DelegationType2) {
  DelegationType2["ACCOUNT"] = "ACCOUNT";
  DelegationType2["RELYING_PARTY"] = "RELYING_PARTY";
})(DelegationType || (DelegationType = {}));
var NANOS_IN_MILLIS = BigInt(1e6);
var DelegationSignerClient = class _DelegationSignerClient extends SignerClient {
  constructor(options, identity2, baseIdentity, targets, maxTimeToLive = BigInt(DEFAULT_MAX_TIME_TO_LIVE)) {
    super(options);
    __publicField(this, "identity");
    __publicField(this, "baseIdentity");
    __publicField(this, "targets");
    __publicField(this, "maxTimeToLive");
    __publicField(this, "expirationManager");
    this.identity = identity2;
    this.baseIdentity = baseIdentity;
    this.targets = targets;
    this.maxTimeToLive = maxTimeToLive;
  }
  static async create(options) {
    const storage = options.storage ?? new IdbStorage();
    let baseIdentity = options.identity;
    let identity2 = new AnonymousIdentity();
    if (this.shouldCheckIsUserConnected() && !baseIdentity) {
      baseIdentity = await getIdentity(STORAGE_KEY, storage);
    }
    if (!baseIdentity) {
      const createdBaseIdentity = await (!(options == null ? void 0 : options.keyType) || (options == null ? void 0 : options.keyType) === ED25519_KEY_LABEL2 ? Ed25519KeyIdentity.generate(crypto.getRandomValues(new Uint8Array(32))) : ECDSAKeyIdentity.generate());
      baseIdentity = createdBaseIdentity;
    }
    if (this.shouldCheckIsUserConnected()) {
      const delegationChain = await getDelegationChain(STORAGE_KEY, storage);
      const delegationValid = baseIdentity && delegationChain && isDelegationValid(delegationChain);
      identity2 = delegationValid ? _DelegationSignerClient.createIdentity(baseIdentity, delegationChain) : new AnonymousIdentity();
      const signerClient2 = new _DelegationSignerClient(options, identity2, baseIdentity, options.targets, options.maxTimeToLive);
      if (delegationValid) {
        signerClient2.initExpirationManager(delegationChain);
      }
      const storageConnectedUser = await signerClient2.getConnectedUserFromStorage();
      await signerClient2.setConnectedUser(storageConnectedUser);
      return signerClient2;
    }
    const signerClient = new _DelegationSignerClient(options, identity2, baseIdentity, options.targets, options.maxTimeToLive);
    return signerClient;
  }
  static createIdentity(baseIdentity, delegationChain) {
    if (baseIdentity instanceof PartialIdentity) {
      return PartialDelegationIdentity.fromDelegation(baseIdentity, delegationChain);
    }
    return DelegationIdentity.fromDelegation(baseIdentity, delegationChain);
  }
  async login() {
    var _a4, _b;
    const params = this.options.derivationOrigin ? {
      icrc95DerivationOrigin: this.options.derivationOrigin
    } : {};
    const delegationChainResponse = await this.options.signer.sendRequest({
      id: this.crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc34_delegation",
      params: {
        ...params,
        publicKey: toBase64(this.baseIdentity.getPublicKey().toDer()),
        targets: this.targets,
        maxTimeToLive: this.maxTimeToLive === void 0 ? void 0 : String(this.maxTimeToLive)
      }
    });
    if ("error" in delegationChainResponse) {
      throw Error(delegationChainResponse.error.message);
    }
    const delegationChain = DelegationChain.fromDelegations(delegationChainResponse.result.signerDelegation.map((delegation) => {
      var _a5;
      return {
        delegation: new Delegation(fromBase64(delegation.delegation.pubkey), BigInt(delegation.delegation.expiration), (_a5 = delegation.delegation.targets) == null ? void 0 : _a5.map((principal) => Principal.fromText(principal))),
        signature: fromBase64(delegation.signature)
      };
    }), fromBase64(delegationChainResponse.result.publicKey));
    if (this.baseIdentity instanceof Ed25519KeyIdentity || this.baseIdentity instanceof ECDSAKeyIdentity) {
      await setIdentity(STORAGE_KEY, this.baseIdentity, this.storage);
    }
    await setDelegationChain(STORAGE_KEY, delegationChain, this.storage);
    this.identity = _DelegationSignerClient.createIdentity(this.baseIdentity, delegationChain);
    await this.setConnectedUserToStorage({ owner: this.identity.getPrincipal().toString() });
    if (!((_b = (_a4 = this.options) == null ? void 0 : _a4.idleOptions) == null ? void 0 : _b.disableIdle) && !this.idleManager) {
      this.idleManager = new IdleManager2(this.options.idleOptions);
      this.registerDefaultIdleCallback();
    }
    return this.initExpirationManager(delegationChain);
  }
  initExpirationManager(delegationChain) {
    var _a4;
    if (!this.expirationManager) {
      const delegationExpirationInMillis = Number(delegationChain.delegations.reduce((acc, value) => {
        const bigIntValue = BigInt(value.delegation.expiration) / NANOS_IN_MILLIS;
        return bigIntValue > acc ? bigIntValue : acc;
      }, BigInt(delegationChain.delegations[0].delegation.expiration) / NANOS_IN_MILLIS)) - Date.now();
      this.expirationManager = new TimeoutManager({ timeout: delegationExpirationInMillis });
      (_a4 = this.expirationManager) == null ? void 0 : _a4.registerCallback(async () => {
        await this.logout();
      });
    }
  }
  async logout(options) {
    await Promise.all([
      removeIdentity(STORAGE_KEY, this.storage),
      removeDelegationChain(STORAGE_KEY, this.storage)
    ]);
    this.identity = new AnonymousIdentity();
    return super.logout(options);
  }
  getIdentity() {
    return this.identity;
  }
  async getDelegationType() {
    var _a4;
    if (!this.connectedUser)
      throw new Error("Not authorized");
    const delegationChain = await getDelegationChain(STORAGE_KEY, this.storage);
    if (!delegationChain)
      throw new Error("Not authorized");
    return ((_a4 = delegationChain.delegations[0].delegation.targets) == null ? void 0 : _a4.length) ? DelegationType.ACCOUNT : DelegationType.RELYING_PARTY;
  }
  async getDelegation() {
    const chain = await getDelegationChain(STORAGE_KEY, this.storage);
    return chain == null ? void 0 : chain.delegations[0];
  }
};
var AccountsSignerClient = class _AccountsSignerClient extends SignerClient {
  static async create(options) {
    const signerClient = new _AccountsSignerClient(options);
    if (SignerClient.shouldCheckIsUserConnected()) {
      const storageConnectedUser = await signerClient.getConnectedUserFromStorage();
      await signerClient.setConnectedUser(storageConnectedUser);
    }
    return signerClient;
  }
  async login() {
    var _a4, _b, _c, _d;
    const params = this.options.derivationOrigin ? {
      params: {
        icrc95DerivationOrigin: this.options.derivationOrigin
      }
    } : {};
    const accountsResponse = await this.options.signer.sendRequest({
      method: "icrc27_accounts",
      id: this.crypto.randomUUID(),
      jsonrpc: "2.0",
      ...params
    });
    if ("error" in accountsResponse) {
      throw Error(accountsResponse.error.message);
    }
    const accounts = accountsResponse.result.accounts.map(({ owner, subaccount }) => {
      return {
        owner: Principal.fromText(owner),
        subaccount: subaccount === void 0 ? void 0 : fromBase64(subaccount)
      };
    });
    await this.setAccounts(accounts);
    const account = accounts[0];
    if (!account.subaccount) {
      if (!((_b = (_a4 = this.options) == null ? void 0 : _a4.idleOptions) == null ? void 0 : _b.disableIdle) && !this.idleManager) {
        this.idleManager = new IdleManager2(this.options.idleOptions);
        this.registerDefaultIdleCallback();
      }
      await this.setConnectedUserToStorage({ owner: account.owner.toString() });
      return;
    }
    await this.setConnectedUserToStorage({
      owner: account.owner.toString(),
      subAccount: account.subaccount
    });
    if (!((_d = (_c = this.options) == null ? void 0 : _c.idleOptions) == null ? void 0 : _d.disableIdle) && !this.idleManager) {
      this.idleManager = new IdleManager2(this.options.idleOptions);
      this.registerDefaultIdleCallback();
    }
  }
  async logout(options) {
    await this.storage.remove(`accounts-${STORAGE_KEY}`);
    return super.logout(options);
  }
  async setAccounts(accounts) {
    return this.storage.set(`accounts-${STORAGE_KEY}`, JSON.stringify(accounts.map((acc) => ({
      owner: acc.owner.toString(),
      subaccount: acc.subaccount && new TextDecoder().decode(acc.subaccount)
    }))));
  }
  async getAccounts() {
    const storageData = await this.storage.get(`accounts-${STORAGE_KEY}`);
    if (!storageData || typeof storageData !== "string")
      return;
    return JSON.parse(storageData).map(({ owner, subaccount }) => {
      let subAccount;
      if (subaccount) {
        const subAccountOrError = _.fromBytes(new Uint8Array(new TextEncoder().encode(subaccount)));
        if (typeof subAccountOrError === typeof Error) {
          throw subAccount;
        }
        subAccount = subAccountOrError;
      }
      return {
        principal: Principal.from(owner),
        subAccount
      };
    });
  }
};
var IdentityKitAuthType = {
  DELEGATION: "DELEGATION",
  ACCOUNTS: "ACCOUNTS"
};
var IdentityKit = class {
  constructor(signerClient) {
    __publicField(this, "signerClient");
    this.signerClient = signerClient;
  }
  async getIcpBalance() {
    const connectedUser = await this.signerClient.connectedUser;
    if (!connectedUser)
      throw new Error("Not authenticated");
    const balance = (await ze.create().accountBalance({
      accountIdentifier: D.fromPrincipal({
        principal: connectedUser.principal,
        subAccount: connectedUser.subAccount
      }),
      certified: false
    })).toString();
    return Number(balance) / 10 ** 8;
  }
  static async create({ signerClientOptions, authType }) {
    if (authType === IdentityKitAuthType.DELEGATION) {
      const signerClient = await DelegationSignerClient.create(signerClientOptions);
      return new this(signerClient);
    } else {
      const signerClient = await AccountsSignerClient.create(signerClientOptions);
      return new this(signerClient);
    }
  }
};
var TransportType;
(function(TransportType2) {
  TransportType2[TransportType2["NEW_TAB"] = 0] = "NEW_TAB";
  TransportType2[TransportType2["EXTENSION"] = 1] = "EXTENSION";
  TransportType2[TransportType2["INTERNET_IDENTITY"] = 2] = "INTERNET_IDENTITY";
  TransportType2[TransportType2["STOIC"] = 3] = "STOIC";
})(TransportType || (TransportType = {}));
var NFIDW = {
  id: "NFIDW",
  description: "Quickly sign in or create an anonymous, self-sovereign wallet with your email address or passkey.",
  providerUrl: "https://nfid.one/rpc",
  transportType: TransportType.NEW_TAB,
  label: "NFID Wallet",
  icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45MDIyIDMuMTU2MjlDMTYuNzcxNCAzLjA2MzYzIDE3LjQwMDggMi4yODM5OCAxNy4zMDgxIDEuNDE0ODlDMTcuMjE1NSAwLjU0NTgwOSAxNi40MzU4IC0wLjA4MzYwOTkgMTUuNTY2NyAwLjAwOTA0OTQ2TDEyLjMzNDUgMC4zNTM2MzNDMTAuNjc4NiAwLjUzMDE2NSA5LjM1MDQ2IDAuNjcxNzUxIDguMjcxOCAwLjg2NzMwNkM3LjE2MDYgMS4wNjg3NiA2LjIwODI3IDEuMzQ0MTQgNS4zMjM3OCAxLjgzOTgxQzMuODg3NzMgMi42NDQ1NyAyLjY5NzE5IDMuODIzODUgMS44Nzk0NCA1LjI1MTk2QzEuMzc1NjggNi4xMzE3MyAxLjA5MjA0IDcuMDgxMTIgMC44ODExODUgOC4xODk2MUMwLjY3NjUzNSA5LjI2NTQ5IDAuNTIzODkzIDEwLjU5MSAwLjMzMzYyMSAxMi4yNDMyTDAuMzI1NDI0IDEyLjMxNDRMMC4wMDgwNjAwNiAxNS40NzA0Qy0wLjA3OTM4NzUgMTYuMzQgMC41NTQ3MjYgMTcuMTE1OSAxLjQyNDM5IDE3LjIwMzRDMi4yOTQwNiAxNy4yOTA4IDMuMDY5OTUgMTYuNjU2NyAzLjE1NzQgMTUuNzg3MUwzLjQ3MjQ4IDEyLjY1MzhDMy42NzA1NCAxMC45MzQgMy44MTA2NiA5LjcyNzMgMy45OTA2NiA4Ljc4MTAzQzQuMTY3MzEgNy44NTIzNSA0LjM2NDQ5IDcuMjgxODEgNC42MjYyNiA2LjgyNDY3QzUuMTU5MDEgNS44OTQyNyA1LjkzNDg3IDUuMTI1NTkgNi44NzEyMSA0LjYwMDg2QzcuMzMxNTEgNC4zNDI5MSA3LjkwNDg2IDQuMTUwNTEgOC44MzY0NiAzLjk4MTYxQzkuNzg3NjYgMy44MDkxNiAxMS4wMDA1IDMuNjc4ODggMTIuNzI5OSAzLjQ5NDVMMTUuOTAyMiAzLjE1NjI5Wk00Ni42OTE5IDEuNDE0ODlDNDYuNTk5MiAyLjI4Mzk4IDQ3LjIyODYgMy4wNjM2MyA0OC4wOTc4IDMuMTU2MjlMNTEuMjcwMSAzLjQ5NDVDNTIuOTk5NSAzLjY3ODg4IDU0LjIxMjMgMy44MDkxNiA1NS4xNjM1IDMuOTgxNjFDNTYuMDk1MSA0LjE1MDUxIDU2LjY2ODUgNC4zNDI5MSA1Ny4xMjg4IDQuNjAwODZDNTguMDY1MSA1LjEyNTU5IDU4Ljg0MSA1Ljg5NDI3IDU5LjM3MzcgNi44MjQ2N0M1OS42MzU1IDcuMjgxODEgNTkuODMyNyA3Ljg1MjM1IDYwLjAwOTMgOC43ODEwM0M2MC4xODkzIDkuNzI3MyA2MC4zMjk1IDEwLjkzNCA2MC41Mjc1IDEyLjY1MzhMNjAuODQyNiAxNS43ODcxQzYwLjkzIDE2LjY1NjcgNjEuNzA1OSAxNy4yOTA4IDYyLjU3NTYgMTcuMjAzNEM2My40NDUzIDE3LjExNTkgNjQuMDc5NCAxNi4zNCA2My45OTE5IDE1LjQ3MDRMNjMuNjc0NiAxMi4zMTQ0TDYzLjY2NjQgMTIuMjQzMkM2My40NzYxIDEwLjU5MSA2My4zMjM1IDkuMjY1NDkgNjMuMTE4OCA4LjE4OTYxQzYyLjkwOCA3LjA4MTEyIDYyLjYyNDMgNi4xMzE3MyA2Mi4xMjA2IDUuMjUxOTZDNjEuMzAyOCAzLjgyMzg1IDYwLjExMjMgMi42NDQ1NyA1OC42NzYyIDEuODM5ODFDNTcuNzkxNyAxLjM0NDE0IDU2LjgzOTQgMS4wNjg3NiA1NS43MjgyIDAuODY3MzA2QzU0LjY0OTUgMC42NzE3NTEgNTMuMzIxNCAwLjUzMDE2NSA1MS42NjU1IDAuMzUzNjMzTDQ4LjQzMzMgMC4wMDkwNDk0NkM0Ny41NjQyIC0wLjA4MzYwOTkgNDYuNzg0NSAwLjU0NTgwOSA0Ni42OTE5IDEuNDE0ODlaTTQ2LjY5MTkgNjIuNTg1MUM0Ni41OTkyIDYxLjcxNiA0Ny4yMjg2IDYwLjkzNjQgNDguMDk3OCA2MC44NDM3TDUxLjI3MDEgNjAuNTA1NUM1Mi45OTk1IDYwLjMyMTEgNTQuMjEyMyA2MC4xOTA4IDU1LjE2MzUgNjAuMDE4NEM1Ni4wOTUxIDU5Ljg0OTUgNTYuNjY4NSA1OS42NTcxIDU3LjEyODggNTkuMzk5MUM1OC4wNjUxIDU4Ljg3NDQgNTguODQxIDU4LjEwNTcgNTkuMzczNyA1Ny4xNzUzQzU5LjYzNTUgNTYuNzE4MiA1OS44MzI3IDU2LjE0NzYgNjAuMDA5MyA1NS4yMTlDNjAuMTg5MyA1NC4yNzI3IDYwLjMyOTUgNTMuMDY2IDYwLjUyNzUgNTEuMzQ2Mkw2MC44NDI2IDQ4LjIxMjlDNjAuOTMgNDcuMzQzMyA2MS43MDU5IDQ2LjcwOTIgNjIuNTc1NiA0Ni43OTY2QzYzLjQ0NTMgNDYuODg0MSA2NC4wNzk0IDQ3LjY2IDYzLjk5MTkgNDguNTI5Nkw2My42NzQ2IDUxLjY4NTZMNjMuNjY2NCA1MS43NTY4QzYzLjQ3NjEgNTMuNDA5IDYzLjMyMzUgNTQuNzM0NSA2My4xMTg4IDU1LjgxMDRDNjIuOTA4IDU2LjkxODkgNjIuNjI0MyA1Ny44NjgzIDYyLjEyMDYgNTguNzQ4QzYxLjMwMjggNjAuMTc2MiA2MC4xMTIzIDYxLjM1NTQgNTguNjc2MiA2Mi4xNjAyQzU3Ljc5MTcgNjIuNjU1OSA1Ni44Mzk0IDYyLjkzMTIgNTUuNzI4MiA2My4xMzI3QzU0LjY0OTYgNjMuMzI4MiA1My4zMjE2IDYzLjQ2OTggNTEuNjY1OCA2My42NDYzTDUxLjY2NTYgNjMuNjQ2M0w1MS42NjU1IDYzLjY0NjRMNTEuNjY1NSA2My42NDY0TDQ4LjQzMzMgNjMuOTkxQzQ3LjU2NDIgNjQuMDgzNiA0Ni43ODQ1IDYzLjQ1NDIgNDYuNjkxOSA2Mi41ODUxWk0xNy4zMDgxIDYyLjU4NTZDMTcuNDAwOCA2MS43MTY1IDE2Ljc3MTQgNjAuOTM2OSAxNS45MDIyIDYwLjg0NDJMMTIuNzI5OSA2MC41MDZDMTEuMDAwNSA2MC4zMjE2IDkuNzg3NjYgNjAuMTkxMyA4LjgzNjQ2IDYwLjAxODlDNy45MDQ4NiA1OS44NSA3LjMzMTUxIDU5LjY1NzYgNi44NzEyMSA1OS4zOTk2QzUuOTM0ODcgNTguODc0OSA1LjE1OTAxIDU4LjEwNjIgNC42MjYyNiA1Ny4xNzU4QzQuMzY0NDkgNTYuNzE4NyA0LjE2NzMxIDU2LjE0ODEgMy45OTA2NiA1NS4yMTk1QzMuODEwNjYgNTQuMjczMiAzLjY3MDU0IDUzLjA2NjUgMy40NzI0OCA1MS4zNDY3TDMuMTU3NCA0OC4yMTM0QzMuMDY5OTUgNDcuMzQzOCAyLjI5NDA2IDQ2LjcwOTcgMS40MjQzOSA0Ni43OTcxQzAuNTU0NzI2IDQ2Ljg4NDYgLTAuMDc5Mzg3NSA0Ny42NjA0IDAuMDA4MDYwMDYgNDguNTMwMUwwLjMyNTQyNCA1MS42ODYxTDAuMzMzNjIxIDUxLjc1NzNDMC41MjM4OTMgNTMuNDA5NSAwLjY3NjUzNSA1NC43MzUgMC44ODExODUgNTUuODEwOUMxLjA5MjA0IDU2LjkxOTQgMS4zNzU2OCA1Ny44Njg4IDEuODc5NDQgNTguNzQ4NUMyLjY5NzE5IDYwLjE3NjYgMy44ODc3MyA2MS4zNTU5IDUuMzIzNzggNjIuMTYwN0M2LjIwODI3IDYyLjY1NjMgNy4xNjA2IDYyLjkzMTcgOC4yNzE4IDYzLjEzMzJDOS4zNTA0NCA2My4zMjg3IDEwLjY3ODYgNjMuNDcwMyAxMi4zMzQ1IDYzLjY0NjhMMTIuMzM0NSA2My42NDY5TDE1LjU2NjcgNjMuOTkxNEMxNi40MzU4IDY0LjA4NDEgMTcuMjE1NSA2My40NTQ3IDE3LjMwODEgNjIuNTg1NlpNMTYuNDUxMiAxOS43OTU0QzE1LjY5NTUgMTkuNzk1NCAxNS4wODI4IDIwLjQwODEgMTUuMDgyOCAyMS4xNjM4VjQzLjI5NzJDMTUuMDgyOCA0NC4wNTMgMTUuNjk1NSA0NC42NjU2IDE2LjQ1MTIgNDQuNjY1NkgyMC43NDk0QzIxLjUwNTIgNDQuNjY1NiAyMi4xMTc4IDQ0LjA1MyAyMi4xMTc4IDQzLjI5NzJWMjEuMTYzOEMyMi4xMTc4IDIwLjQwODEgMjEuNTA1MiAxOS43OTU0IDIwLjc0OTQgMTkuNzk1NEgxNi40NTEyWk0yOC4xMDgyIDE5Ljc5NTRDMjcuMzUyNSAxOS43OTU0IDI2LjczOTggMjAuNDA4MSAyNi43Mzk4IDIxLjE2MzhWNDMuMjk3MkMyNi43Mzk4IDQ0LjA1MyAyNy4zNTI1IDQ0LjY2NTYgMjguMTA4MiA0NC42NjU2SDM4LjUwMDRDNDEuMjI0NCA0NC42NjU2IDQzLjY0MDUgNDQuMTU2NCA0NS43NDg3IDQzLjEzNzlDNDcuODU2OCA0Mi4xMTk0IDQ5LjQ5MTIgNDAuNjc0NiA1MC42NTE5IDM4LjgwMzRDNTEuODEyNSAzNi45MzIyIDUyLjM5MjkgMzQuNzQxMiA1Mi4zOTI5IDMyLjIzMDVDNTIuMzkyOSAyOS43MTk4IDUxLjgxMjUgMjcuNTI4OSA1MC42NTE5IDI1LjY1NzdDNDkuNDkxMiAyMy43ODY1IDQ3Ljg1NjggMjIuMzQxNyA0NS43NDg3IDIxLjMyMzJDNDMuNjQwNSAyMC4zMDQ3IDQxLjIyNDQgMTkuNzk1NCAzOC41MDA0IDE5Ljc5NTRIMjguMTA4MlpNNDMuMzMyNiAzNy4yNDAxQzQyLjA1MzUgMzguNDQ4MSA0MC4zNDggMzkuMDUyMSAzOC4yMTYyIDM5LjA1MjFIMzQuMTg1NEMzMy45NTg3IDM5LjA1MjEgMzMuNzc0OSAzOC44NjgzIDMzLjc3NDkgMzguNjQxNlYyNS44MTk1QzMzLjc3NDkgMjUuNTkyOCAzMy45NTg3IDI1LjQwOSAzNC4xODU0IDI1LjQwOUgzOC4yMTYyQzQwLjM0OCAyNS40MDkgNDIuMDUzNSAyNi4wMTMgNDMuMzMyNiAyNy4yMjFDNDQuNjM1NCAyOC40Mjg5IDQ1LjI4NjggMzAuMDk4OCA0NS4yODY4IDMyLjIzMDVDNDUuMjg2OCAzNC4zNjIzIDQ0LjYzNTQgMzYuMDMyMSA0My4zMzI2IDM3LjI0MDFaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfODAzODBfNTQpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfODAzODBfNTQiIHgxPSIwLjc2NTgxMiIgeTE9Ii0yLjcwNDk2ZS0wNyIgeDI9IjYzLjU0MTciIHkyPSI2NC4yNzkzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEE2OTUiLz4KPHN0b3Agb2Zmc2V0PSIwLjUiIHN0b3AtY29sb3I9IiMwMTg0NzciLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDA2RjY0Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg=="
};
({
  transportType: TransportType.NEW_TAB
});
var InternetIdentity = {
  id: "InternetIdentity",
  providerUrl: "",
  transportType: TransportType.INTERNET_IDENTITY,
  label: "Internet Identity",
  icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzNTguOCAxNzkuOCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzU4LjggMTc5Ljg7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCNTVkdJRF8yXyk7fQoJLnN0MntmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOiMyOUFCRTI7fQo8L3N0eWxlPgo8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIyNC43ODUzIiB5MT0iMjU3Ljc1MzYiIHgyPSIzNDguMDY2MyIgeTI9IjEzMy40NTgxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMjcyKSI+Cgk8c3RvcCAgb2Zmc2V0PSIwLjIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjE1QTI0Ii8+Cgk8c3RvcCAgb2Zmc2V0PSIwLjY4NDEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkIwM0IiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI3MS42LDBjLTIwLDAtNDEuOSwxMC45LTY1LDMyLjRjLTEwLjksMTAuMS0yMC41LDIxLjEtMjcuNSwyOS44YzAsMCwxMS4yLDEyLjksMjMuNSwyNi44CgljNi43LTguNCwxNi4yLTE5LjgsMjcuMy0zMC4xYzIwLjUtMTkuMiwzMy45LTIzLjEsNDEuNi0yMy4xYzI4LjgsMCw1Mi4yLDI0LjIsNTIuMiw1NC4xYzAsMjkuNi0yMy40LDUzLjgtNTIuMiw1NC4xCgljLTEuNCwwLTMtMC4yLTUtMC42YzguNCwzLjksMTcuNSw2LjcsMjYsNi43YzUyLjgsMCw2My4yLTM2LjUsNjMuOC0zOS4xYzEuNS02LjcsMi40LTEzLjcsMi40LTIwLjlDMzU4LjYsNDAuNCwzMTkuNiwwLDI3MS42LDB6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMzLjk0NjEiIHkxPSIxMDYuNDI2MiIgeDI9IjEwLjY2NTMiIHkyPSIyMzAuNzIxNSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDI3MikiPgoJPHN0b3AgIG9mZnNldD0iMC4yMSIgc3R5bGU9InN0b3AtY29sb3I6I0VEMUU3OSIvPgoJPHN0b3AgIG9mZnNldD0iMC44OTI5IiBzdHlsZT0ic3RvcC1jb2xvcjojNTIyNzg1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik04Ny4xLDE3OS44YzIwLDAsNDEuOS0xMC45LDY1LTMyLjRjMTAuOS0xMC4xLDIwLjUtMjEuMSwyNy41LTI5LjhjMCwwLTExLjItMTIuOS0yMy41LTI2LjgKCWMtNi43LDguNC0xNi4yLDE5LjgtMjcuMywzMC4xYy0yMC41LDE5LTM0LDIzLjEtNDEuNiwyMy4xYy0yOC44LDAtNTIuMi0yNC4yLTUyLjItNTQuMWMwLTI5LjYsMjMuNC01My44LDUyLjItNTQuMQoJYzEuNCwwLDMsMC4yLDUsMC42Yy04LjQtMy45LTE3LjUtNi43LTI2LTYuN0MxMy40LDI5LjYsMyw2Ni4xLDIuNCw2OC44QzAuOSw3NS41LDAsODIuNSwwLDg5LjdDMCwxMzkuNCwzOSwxNzkuOCw4Ny4xLDE3OS44eiIvPgo8cGF0aCBjbGFzcz0ic3QyIiBkPSJNMTI3LjMsNTkuN2MtNS44LTUuNi0zNC0yOC41LTYxLTI5LjNDMTguMSwyOS4yLDQsNjQuMiwyLjcsNjguN0MxMiwyOS41LDQ2LjQsMC4yLDg3LjIsMAoJYzMzLjMsMCw2NywzMi43LDkxLjksNjIuMmMwLDAsMC4xLTAuMSwwLjEtMC4xYzAsMCwxMS4yLDEyLjksMjMuNSwyNi44YzAsMCwxNCwxNi41LDI4LjgsMzFjNS44LDUuNiwzMy45LDI4LjIsNjAuOSwyOQoJYzQ5LjUsMS40LDYzLjItMzUuNiw2My45LTM4LjRjLTkuMSwzOS41LTQzLjYsNjguOS04NC42LDY5LjFjLTMzLjMsMC02Ny0zMi43LTkyLTYyLjJjMCwwLjEtMC4xLDAuMS0wLjEsMC4yCgljMCwwLTExLjItMTIuOS0yMy41LTI2LjhDMTU2LjIsOTAuOCwxNDIuMiw3NC4yLDEyNy4zLDU5Ljd6IE0yLjcsNjkuMWMwLTAuMSwwLTAuMiwwLjEtMC4zQzIuNyw2OC45LDIuNyw2OSwyLjcsNjkuMXoiLz4KPC9zdmc+Cg=="
};
({
  transportType: TransportType.STOIC
});
({
  transportType: TransportType.NEW_TAB
});
function useCreateIdentityKit({ selectedSigner, clearSigner, signerClientOptions = {}, authType, onConnectFailure, onConnectSuccess, realConnectDisabled, ...props }) {
  const [ik, setIk] = (0, import_react116.useState)(null);
  const [user, setUser] = (0, import_react116.useState)();
  const [icpBalance, setIcpBalance] = (0, import_react116.useState)();
  const onDisconnect = (0, import_react116.useCallback)(async () => {
    var _a4, _b;
    setIk(null);
    setUser(void 0);
    setIcpBalance(void 0);
    await ((_a4 = selectedSigner == null ? void 0 : selectedSigner.value.transport.connection) == null ? void 0 : _a4.disconnect());
    await clearSigner();
    (_b = props.onDisconnect) == null ? void 0 : _b.call(props);
    if ((selectedSigner == null ? void 0 : selectedSigner.id) === InternetIdentity.id)
      window.location.reload();
  }, [ik == null ? void 0 : ik.signerClient, clearSigner, props.onDisconnect, selectedSigner]);
  const disconnect = (0, import_react116.useCallback)(async () => {
    var _a4;
    return await ((_a4 = ik == null ? void 0 : ik.signerClient) == null ? void 0 : _a4.logout());
  }, [ik == null ? void 0 : ik.signerClient]);
  const fetchIcpBalance = (0, import_react116.useMemo)(() => {
    if (!user || !ik)
      return;
    return () => ik.getIcpBalance().then(setIcpBalance);
  }, [ik, user, setIcpBalance]);
  (0, import_react116.useEffect)(() => {
    setIk(null);
    if (selectedSigner && !(ik == null ? void 0 : ik.signerClient)) {
      IdentityKit.create({
        authType,
        signerClientOptions: {
          ...signerClientOptions,
          crypto,
          signer: selectedSigner.value,
          onLogout: onDisconnect
        }
      }).then(async (instance) => {
        var _a4, _b, _c;
        if (!realConnectDisabled) {
          if (!instance.signerClient.connectedUser) {
            try {
              await instance.signerClient.login();
              setUser(instance.signerClient.connectedUser);
              onConnectSuccess == null ? void 0 : onConnectSuccess();
            } catch (e8) {
              await ((_a4 = selectedSigner.value.transport.connection) == null ? void 0 : _a4.disconnect());
              await clearSigner();
              onConnectFailure == null ? void 0 : onConnectFailure(e8);
            }
          } else {
            if (((_c = (_b = instance.signerClient).getIdentity) == null ? void 0 : _c.call(_b)) instanceof AnonymousIdentity) {
              await instance.signerClient.logout();
              await disconnect();
              return;
            }
            setUser(instance.signerClient.connectedUser);
          }
        } else {
          onConnectSuccess == null ? void 0 : onConnectSuccess();
        }
        setIk(instance);
      });
    }
  }, [selectedSigner, realConnectDisabled]);
  (0, import_react116.useEffect)(() => {
    if (icpBalance === void 0) {
      fetchIcpBalance == null ? void 0 : fetchIcpBalance();
    }
  }, [icpBalance, user, fetchIcpBalance]);
  return {
    user,
    disconnect,
    icpBalance,
    signerClient: ik == null ? void 0 : ik.signerClient,
    fetchIcpBalance
  };
}
function useProceedTheme(theme = IdentityKitTheme.SYSTEM) {
  const [finalTheme, setFinalTheme] = (0, import_react116.useState)(theme);
  (0, import_react116.useEffect)(() => {
    if (!theme || theme === IdentityKitTheme.SYSTEM) {
      setFinalTheme(window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? IdentityKitTheme.DARK : IdentityKitTheme.LIGHT);
    } else {
      setFinalTheme(theme);
    }
  }, [theme]);
  return finalTheme;
}
async function getPopupTransportBuilder(options) {
  return new PostMessageTransport({
    ...options,
    detectNonClickEstablishment: false
  });
}
async function getExtensionTransportBuilder({ uuid }) {
  return BrowserExtensionTransport.findTransport({ uuid });
}
async function getAuthClientTransportBuilder(options) {
  return await AuthClientTransport.create({
    ...options,
    authClientCreateOptions: {
      ...options.authClientCreateOptions,
      idleOptions: {
        disableIdle: true
      }
    }
  });
}
async function getStoicTransportBuilder({ maxTimeToLive }) {
  return await StoicTransport.create({ maxTimeToLive });
}
var _TransportBuilder = class _TransportBuilder {
  static async build(request) {
    return await _TransportBuilder.builders[request.transportType]({
      ...request,
      maxTimeToLive: request.maxTimeToLive || DEFAULT_MAX_TIME_TO_LIVE
    });
  }
};
__publicField(_TransportBuilder, "builders", {
  [TransportType.NEW_TAB]: ({ url, crypto: crypto2, window: window2, windowOpenerFeatures }) => getPopupTransportBuilder({
    url,
    crypto: crypto2,
    window: window2,
    windowOpenerFeatures
  }),
  [TransportType.EXTENSION]: ({ id }) => {
    if (!id) {
      throw Error("Id is required to find the ICRC-94 specific wallet");
    }
    return getExtensionTransportBuilder({ uuid: id });
  },
  [TransportType.INTERNET_IDENTITY]: ({ maxTimeToLive, derivationOrigin, identity: identity2, keyType, storage, allowInternetIdentityPinAuthentication, url }) => getAuthClientTransportBuilder({
    authClientCreateOptions: {
      identity: identity2,
      keyType,
      storage
    },
    authClientLoginOptions: {
      maxTimeToLive,
      derivationOrigin,
      allowPinAuthentication: allowInternetIdentityPinAuthentication,
      identityProvider: url
    }
  }),
  [TransportType.STOIC]: ({ maxTimeToLive }) => getStoicTransportBuilder({ maxTimeToLive })
});
var TransportBuilder = _TransportBuilder;
function useProceedSigner({ signers, transports, closeModal, crypto: crypto2, window: window2, windowOpenerFeatures, onConnectFailure }) {
  const [localStorageSigner, setLocalStorageSigner] = (0, import_react116.useState)(typeof window2 !== "undefined" && localStorage.getItem("signerId") || "");
  const [selectedSigner, setSelectedSigner] = (0, import_react116.useState)(void 0);
  const [isSignerBeingSelected, setIsSignerBeingSelected] = (0, import_react116.useState)(false);
  const selectSigner = (0, import_react116.useCallback)(async (signerId) => {
    var _a4, _b, _c;
    if (!signerId) {
      localStorage.removeItem("signerId");
      setLocalStorageSigner(void 0);
      return setSelectedSigner(void 0);
    }
    try {
      setIsSignerBeingSelected(true);
      closeModal();
      const signerConfig = signers.find((s13) => s13.id === signerId);
      if (!signerConfig)
        throw new Error(`Signer with id ${signerId} not found`);
      const transport = (_a4 = transports == null ? void 0 : transports.find((t11) => t11.signerId === signerId)) == null ? void 0 : _a4.value;
      if (!transport)
        throw new Error("Transport was not found");
      if (!((_b = transport.connection) == null ? void 0 : _b.connected) && !localStorageSigner) {
        await ((_c = transport.connection) == null ? void 0 : _c.connect());
      }
      const createdSigner = new Signer({
        crypto: crypto2,
        transport
      });
      setSelectedSigner({ value: createdSigner, id: signerId });
      setIsSignerBeingSelected(false);
    } catch (e8) {
      setIsSignerBeingSelected(false);
      onConnectFailure == null ? void 0 : onConnectFailure(e8);
      return;
    }
  }, [signers, crypto2, closeModal, transports, localStorageSigner]);
  const selectCustomSigner = (0, import_react116.useCallback)(async (url) => {
    const transport = await TransportBuilder.build({
      transportType: TransportType.NEW_TAB,
      url,
      crypto: crypto2,
      window: window2,
      windowOpenerFeatures
    });
    const signer = new Signer({ crypto: crypto2, transport });
    setSelectedSigner({ value: signer, id: url });
    closeModal();
  }, [crypto2, window2, closeModal, windowOpenerFeatures]);
  (0, import_react116.useEffect)(() => {
    const lsSigner = localStorage.getItem("signerId");
    if (!selectedSigner && lsSigner && transports) {
      selectSigner(lsSigner);
    }
  }, [selectedSigner, selectSigner, transports]);
  const setSelectedSignerToLocalStorage = (0, import_react116.useCallback)(() => {
    if (selectedSigner && (selectedSigner == null ? void 0 : selectedSigner.id)) {
      localStorage.setItem("signerId", selectedSigner == null ? void 0 : selectedSigner.id);
    }
  }, [selectedSigner]);
  return {
    selectSigner,
    setSelectedSignerToLocalStorage,
    // clears both local state and local storage
    clearSigner: () => selectSigner(),
    selectCustomSigner,
    // selected signer is local storage signer by default (in case authenticated user)
    selectedSigner,
    // signer id in localStorage (used on connected user page reload)
    localStorageSigner,
    isSignerBeingSelected
  };
}
var ContextNotInitializedError = class extends Error {
  constructor() {
    super("IdentityKit context not initialized");
  }
};
function useBalance() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return {
      balance: ctx.icpBalance,
      fetchBalance: ctx.fetchIcpBalance
    };
  });
}
function useSigner() {
  return useContextSelector(Context, (ctx) => {
    var _a4;
    if (!ctx)
      throw new ContextNotInitializedError();
    return (_a4 = ctx.selectedSigner) == null ? void 0 : _a4.value;
  });
}
function useModal() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return {
      isModalOpen: ctx.isModalOpen,
      toggleModal: ctx.toggleModal,
      featuredSigner: ctx.featuredSigner,
      signers: ctx.signers,
      selectCustomSigner: ctx.selectCustomSigner,
      selectSigner: ctx.selectSigner
    };
  });
}
function useTheme() {
  return (0, import_react116.useContext)(ThemeContext);
}
function useAuthType() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.authType;
  });
}
function useUser() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.user;
  });
}
function useSignerClient() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.signerClient;
  });
}
function useIsInitializing() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.isInitializing;
  });
}
function useIsUserConnecting() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.isUserConnecting;
  });
}
function useConnect() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.connect;
  });
}
function useDisconnect() {
  return useContextSelector(Context, (ctx) => {
    if (!ctx)
      throw new ContextNotInitializedError();
    return ctx.disconnect;
  });
}
function useSignerConfig() {
  return useContextSelector(Context, (ctx) => {
    var _a4, _b, _c, _d;
    if (!ctx)
      throw new ContextNotInitializedError();
    return ((_a4 = ctx.selectedSigner) == null ? void 0 : _a4.id) ? ctx.signers.find((s13) => {
      var _a5;
      return s13.id === ((_a5 = ctx.selectedSigner) == null ? void 0 : _a5.id);
    }) ?? {
      id: (_b = ctx.selectedSigner) == null ? void 0 : _b.id,
      label: (_c = ctx.selectedSigner) == null ? void 0 : _c.id,
      transportType: TransportType.NEW_TAB,
      providerUrl: (_d = ctx.selectedSigner) == null ? void 0 : _d.id
    } : void 0;
  });
}
function useIdentity() {
  const signerClient = useSignerClient();
  const authType = useAuthType();
  const identity2 = (0, import_react116.useMemo)(() => authType === IdentityKitAuthType.ACCOUNTS || signerClient instanceof AccountsSignerClient ? void 0 : signerClient == null ? void 0 : signerClient.getIdentity(), [authType, signerClient]);
  return identity2;
}
function useAccounts() {
  const authType = useAuthType();
  const signerClient = useSignerClient();
  const user = useUser();
  const [accounts, setAccounts] = (0, import_react116.useState)();
  (0, import_react116.useEffect)(() => {
    if (!user) {
      setAccounts(void 0);
    } else {
      if (authType === IdentityKitAuthType.ACCOUNTS && !accounts && signerClient instanceof AccountsSignerClient) {
        signerClient == null ? void 0 : signerClient.getAccounts().then(setAccounts);
      }
    }
  }, [user, authType, signerClient]);
  return accounts;
}
function useDelegationType() {
  const signerClient = useSignerClient();
  const authType = useAuthType();
  const user = useUser();
  const delegationType = (0, import_use_async_memo.useAsyncMemo)(() => {
    if (!user || !signerClient || authType !== IdentityKitAuthType.DELEGATION || signerClient instanceof AccountsSignerClient)
      return void 0;
    return signerClient.getDelegationType();
  }, [user, authType, signerClient]);
  return delegationType;
}
function useAgent(agentOptions = {}) {
  const identity2 = useIdentity();
  const selectedSigner = useSigner();
  const user = useUser();
  const signerClient = useSignerClient();
  const authType = useAuthType();
  const ikAgent = (0, import_use_async_memo.useAsyncMemo)(async () => {
    if (!selectedSigner || !user || !signerClient)
      return void 0;
    const isAccountsAuth = authType === IdentityKitAuthType.ACCOUNTS;
    if (!isAccountsAuth && !identity2)
      return void 0;
    const delegation = isAccountsAuth ? void 0 : await signerClient.getDelegation();
    const defaultAgent = await HttpAgent.create({
      identity: identity2,
      ...agentOptions
    });
    const signerAgent = await SignerAgent.create({
      signer: selectedSigner,
      account: user.principal,
      agent: defaultAgent
    });
    return Agent.create({
      signerAgent,
      agent: defaultAgent,
      identity: identity2,
      delegation: delegation == null ? void 0 : delegation.delegation
    });
  }, [selectedSigner, signerClient, authType, identity2]);
  return ikAgent;
}
function useClickOutside(handler) {
  const ref = (0, import_react116.useRef)(null);
  (0, import_react116.useEffect)(() => {
    const listener = (event) => {
      const el = ref == null ? void 0 : ref.current;
      if (!el || el.contains(event.target))
        return;
      handler(event);
    };
    document.addEventListener(`mousedown`, listener);
    document.addEventListener(`touchstart`, listener);
    return () => {
      document.removeEventListener(`mousedown`, listener);
      document.removeEventListener(`touchstart`, listener);
    };
  }, [ref, handler]);
  return ref;
}
function useAuth() {
  const user = useUser();
  const isConnecting = useIsUserConnecting();
  const connect = useConnect();
  const disconnect = useDisconnect();
  return {
    user,
    isConnecting,
    connect,
    disconnect
  };
}
function useCreatePromise() {
  const [, setResolvedValue] = (0, import_react116.useState)();
  const promiseRef = (0, import_react116.useRef)({
    promise: null,
    resolve: null,
    reject: null
  });
  const createPromise = (0, import_react116.useCallback)(() => {
    promiseRef.current.promise = new Promise((resolve2, reject2) => {
      promiseRef.current.resolve = resolve2;
      promiseRef.current.reject = reject2;
    });
    return promiseRef.current.promise;
  }, []);
  const resolve = (0, import_react116.useCallback)((value) => {
    if (promiseRef.current.resolve) {
      promiseRef.current.resolve(value);
      setResolvedValue(value);
    }
  }, []);
  const reject = (0, import_react116.useCallback)((error2) => {
    if (promiseRef.current.reject) {
      promiseRef.current.reject(error2);
      setResolvedValue(void 0);
    }
  }, []);
  return { createPromise, resolve, reject, promise: promiseRef.current.promise };
}
function useIdentityKit() {
  const ctx = useContext(Context);
  if (!ctx) {
    throw new ContextNotInitializedError();
  }
  const { selectedSigner, user, icpBalance, authType, isInitializing, isUserConnecting, connect, disconnect, fetchIcpBalance } = ctx;
  const identity2 = useIdentity();
  const delegationType = useDelegationType();
  const accounts = useAccounts();
  return {
    signer: selectedSigner == null ? void 0 : selectedSigner.value,
    user,
    icpBalance,
    authType,
    accounts,
    delegationType,
    identity: identity2,
    isInitializing,
    isUserConnecting,
    connect,
    disconnect,
    fetchIcpBalance
  };
}
function ThemeProvider({ children, ...props }) {
  const theme = useProceedTheme(props.theme);
  return (0, import_jsx_runtime12.jsx)(ThemeContext.Provider, { value: theme, children });
}
var validateUrl = (url) => {
  const urlPattern = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
  return urlPattern.test(url);
};
var ICP_DECIMALS = 8;
function countDecimals(value) {
  if (Math.floor(value) === value)
    return 0;
  const str = value.toString();
  if (str.indexOf(".") !== -1 && str.indexOf("-") !== -1) {
    return Number(str.split("-")[1]);
  } else if (str.indexOf(".") !== -1) {
    return Number(str.split(".")[1].length);
  }
  return Number(str.split("-")[1]);
}
function formatIcp(value) {
  if (!value)
    return value.toString();
  const decimals = countDecimals(value);
  const formattedValue = value.toFixed(decimals > ICP_DECIMALS ? ICP_DECIMALS : decimals);
  if (!Number(formattedValue))
    return "0";
  return formattedValue;
}
var Spinner = ({ className }) => {
  return (0, import_jsx_runtime12.jsxs)("svg", { className: clsx_default("animate-spin", "ik-h-5 ik-w-5", className), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [(0, import_jsx_runtime12.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), (0, import_jsx_runtime12.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] });
};
var getButtonClassName = ({ className, type = "primary", block, large }) => clsx_default(type === "primary" ? "ik-component ik-border-transparent ik-bg-primary ik-text-white hover:ik-bg-teal-600 active:ik-bg-teal-700 active:ik-border-primary hover:ik-shadow-md ik-font-bold ik-px-[10px] ik-min-w-[140px] ik-h-[40px] ik-flex ik-items-center ik-justify-center ik-px-[15px] ik-rounded-xl border" : "ik-component ik-border-transparent", "ik-bg-gray-200 ik-text-black hover:ik-bg-gray-100 active:ik-bg-gray-300 active:ik-border-gray-200 hover:ik-shadow-md ik-font-bold ik-px-[10px] ik-min-w-[140px] ik-h-[40px] ik-flex ik-items-center ik-justify-center ik-px-[15px] ik-rounded-xl ik-border", {
  "disabled:ik-shadow-none disabled:ik-bg-gray-300 disabled:ik-border-gray-300 dark:disabled:ik-bg-zinc-700 dark:disabled:ik-border-zinc-700": type === "primary",
  "ik-w-full ik-block": block,
  "ik-h-[48px]": large
}, className);
var Button$1 = ({ children, className, disabled, loading, icon, id, block, large, type = "primary", as: Component = "button", ...buttonProps }) => {
  return (0, import_jsx_runtime12.jsx)(Component, { id, disabled: disabled || loading, className: getButtonClassName({ className, type, block, large }), ...buttonProps, children: (0, import_jsx_runtime12.jsxs)("div", { className: "ik-flex ik-items-center ik-justify-center ik-space-x-2", children: [loading ? (0, import_jsx_runtime12.jsx)(Spinner, { className: "mr-1 text-white" }) : icon ? (0, import_jsx_runtime12.jsx)("div", { className: "ik-flex ik-items-center ik-justify-center ik-w-6 ik-h-6", children: icon }) : null, children ? (0, import_jsx_runtime12.jsx)("div", { className: "ik-text-center", children }) : null] }) });
};
function ConnectButton({ onClick, className, disabled, loading, children }) {
  return (0, import_jsx_runtime12.jsx)(Button$1, { id: "connect", disabled, loading, onClick, className, children: children ?? (0, import_jsx_runtime12.jsx)("small", { children: "Connect wallet" }) });
}
function Item({ className, children, ...props }) {
  return (0, import_jsx_runtime12.jsx)("div", { className: clsx_default("ik-component ik-flex ik-justify-between ik-w-full ik-p-2.5 ik-text-black dark:ik-text-white ik-cursor-pointer", className), ...props, children });
}
function ItemText(props) {
  return (0, import_jsx_runtime12.jsx)("small", { ...props, className: clsx_default("ik-component ik-font-semibold ik-text-black dark:ik-text-white", props.className) });
}
function Items({ className, innerClassName, children, ...props }) {
  const theme = useTheme();
  const menuItems = !Array.isArray(children) ? [children] : children;
  return (0, import_jsx_runtime12.jsx)(gt2, { anchor: "bottom end", transition: true, "data-identity-kit-theme": theme, className: clsx_default("ik-min-w-[320px] ik-rounded-3xl ik-bg-white dark:ik-bg-zinc-900 ik-shadow-lg ik-transition focus:ik-outline-none data-[closed]:ik-scale-95 data-[closed]:ik-transform data-[closed]:ik-opacity-0 data-[enter]:ik-duration-100 data-[leave]:ik-duration-75 data-[enter]:ik-ease-out data-[leave]:ik-ease-in ik-p-2.5 [--anchor-gap:8px] ik-z-[999]", className), ...props, children: (0, import_jsx_runtime12.jsx)("div", { className: clsx_default("ik-py-1", innerClassName), children: menuItems }) });
}
function CopyToClipboard({ component: Component, onCopied, onCopiedTimeout, value }) {
  const [clicked, setClicked] = (0, import_react116.useState)(false);
  return (0, import_jsx_runtime12.jsx)(Component, { onClick: () => {
    if (clicked)
      return;
    setClicked(true);
    setTimeout(() => {
      setClicked(false);
      onCopiedTimeout == null ? void 0 : onCopiedTimeout();
    }, 1e3);
    navigator.clipboard.writeText(value);
    onCopied == null ? void 0 : onCopied();
  } });
}
function Copy(props) {
  const theme = useTheme();
  return (0, import_jsx_runtime12.jsxs)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime12.jsx)("path", { d: "M11.7795 5.55534V5.55534C11.7795 4.727 11.7795 4.31283 11.6442 3.98612C11.4638 3.55052 11.1177 3.20443 10.6821 3.024C10.3554 2.88867 9.94119 2.88867 9.11285 2.88867H6.44618C4.77008 2.88867 3.93202 2.88867 3.41132 3.40937C2.89062 3.93007 2.89062 4.76812 2.89062 6.44423V9.1109C2.89062 9.93924 2.89062 10.3534 3.02595 10.6801C3.20638 11.1157 3.55247 11.4618 3.98808 11.6422C4.31478 11.7776 4.72895 11.7776 5.55729 11.7776V11.7776", stroke: theme === IdentityKitTheme.DARK ? import_colors.default.white : import_colors.default.black, strokeWidth: "1.8" }), (0, import_jsx_runtime12.jsx)("rect", { x: "8.22266", y: "8.22266", width: "8.88889", height: "8.88889", rx: "1.77778", stroke: theme === IdentityKitTheme.DARK ? import_colors.default.white : import_colors.default.black, strokeWidth: "1.8" })] });
}
function Logout(props) {
  const theme = useTheme();
  return (0, import_jsx_runtime12.jsxs)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime12.jsx)("path", { d: "M9.99996 2.5L9.16663 2.5C6.8096 2.5 5.63109 2.5 4.89886 3.23223C4.16663 3.96447 4.16663 5.14298 4.16663 7.5L4.16663 12.5C4.16663 14.857 4.16663 16.0355 4.89886 16.7678C5.63109 17.5 6.8096 17.5 9.16663 17.5L9.99996 17.5", stroke: theme === IdentityKitTheme.DARK ? import_colors.default.white : import_colors.default.black, strokeWidth: "1.8", strokeLinecap: "round" }), (0, import_jsx_runtime12.jsx)("path", { d: "M13.0209 6.25L16.7709 10M16.7709 10L13.0209 13.75M16.7709 10L9.27087 10", stroke: theme === IdentityKitTheme.DARK ? import_colors.default.white : import_colors.default.black, strokeWidth: "1.8", strokeLinecap: "round" })] });
}
function Copied(props) {
  return (0, import_jsx_runtime12.jsxs)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime12.jsx)("path", { d: "M11.7795 5.55534V5.55534C11.7795 4.727 11.7795 4.31283 11.6442 3.98612C11.4638 3.55052 11.1177 3.20443 10.6821 3.024C10.3554 2.88867 9.94119 2.88867 9.11285 2.88867H6.44618C4.77008 2.88867 3.93202 2.88867 3.41132 3.40937C2.89062 3.93007 2.89062 4.76812 2.89062 6.44423V9.1109C2.89062 9.93924 2.89062 10.3534 3.02595 10.6801C3.20638 11.1157 3.55247 11.4618 3.98808 11.6422C4.31478 11.7776 4.72895 11.7776 5.55729 11.7776V11.7776", stroke: import_colors.default.green[500], strokeWidth: "1.8" }), (0, import_jsx_runtime12.jsx)("path", { d: "M11.332 12.2222L13.2544 14L17.1098 10", stroke: import_colors.default.green[500], strokeWidth: "1.8", strokeLinecap: "round" }), (0, import_jsx_runtime12.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.0131 13.4522V13.6147C18.0132 14.4022 18.0132 15.0818 17.94 15.6262C17.8615 16.2101 17.6843 16.7714 17.2288 17.2269C16.7734 17.6823 16.2121 17.8595 15.6282 17.938C15.0837 18.0112 14.4041 18.0112 13.6167 18.0112H11.7207C10.9332 18.0112 10.2536 18.0112 9.70915 17.938C9.12524 17.8595 8.56397 17.6823 8.10853 17.2269C7.65308 16.7714 7.47584 16.2101 7.39734 15.6262C7.32414 15.0818 7.32418 14.4022 7.32422 13.6147L7.32422 13.5556V11.7778L7.32422 11.7187C7.32418 10.9312 7.32414 10.2516 7.39734 9.7072C7.47584 9.12328 7.65308 8.56201 8.10853 8.10657C8.56397 7.65113 9.12524 7.47389 9.70915 7.39538C10.2536 7.32218 10.9332 7.32222 11.7207 7.32227L11.7798 7.32227H13.5576L13.6167 7.32227C14.3298 7.32223 14.9545 7.32219 15.4705 7.37656L13.7581 9.12233C13.6932 9.12228 13.6263 9.12227 13.5576 9.12227H11.7798C10.9163 9.12227 10.3592 9.12418 9.949 9.17933C9.56468 9.231 9.44658 9.31411 9.38132 9.37936C9.31606 9.44462 9.23295 9.56273 9.18129 9.94704C9.12613 10.3572 9.12422 10.9143 9.12422 11.7778V13.5556C9.12422 14.4191 9.12613 14.9762 9.18129 15.3864C9.23295 15.7707 9.31606 15.8888 9.38132 15.9541C9.44658 16.0193 9.56468 16.1024 9.949 16.1541C10.3592 16.2092 10.9163 16.2112 11.7798 16.2112H13.5576C14.4211 16.2112 14.9781 16.2092 15.3883 16.1541C15.7727 16.1024 15.8908 16.0193 15.956 15.9541C16.0213 15.8888 16.1044 15.7707 16.1561 15.3864C16.1569 15.3799 16.1578 15.3733 16.1586 15.3668L16.3425 15.1756L17.3496 14.1286L18.0131 13.4522Z", fill: import_colors.default.green[500] })] });
}
var VISIBLE_ADDRESS_CHARS_NUMBER = 5;
function AddressItem({ value, onClick, ...props }) {
  const [connectedAddressCopied, setConnectedAddressCopied] = (0, import_react116.useState)(false);
  return (0, import_jsx_runtime12.jsx)(CopyToClipboard, { value, onCopied: () => setConnectedAddressCopied(true), onCopiedTimeout: () => setConnectedAddressCopied(false), component: (componentProps) => (0, import_jsx_runtime12.jsxs)(Item, { onClick: (e8) => {
    componentProps.onClick();
    onClick == null ? void 0 : onClick(e8);
  }, ...props, className: clsx_default("ik-component", props.className), children: [(0, import_jsx_runtime12.jsx)(ItemText, { children: "Wallet address" }), (0, import_jsx_runtime12.jsxs)("div", { className: "ik-flex", children: [(0, import_jsx_runtime12.jsx)("small", { className: "ik-font-semibold", children: `${value.substring(0, VISIBLE_ADDRESS_CHARS_NUMBER)}...${value.substring(value.length - VISIBLE_ADDRESS_CHARS_NUMBER)}` }), connectedAddressCopied ? (0, import_jsx_runtime12.jsx)(Copied, { className: "ik-ml-2" }) : (0, import_jsx_runtime12.jsx)(Copy, { className: "ik-ml-2" })] })] }) });
}
function DisconnectItem(props) {
  return (0, import_jsx_runtime12.jsxs)(Item, { ...props, className: clsx_default("ik-component", props.className), children: [(0, import_jsx_runtime12.jsx)(ItemText, { className: "ik-disconnect", children: "Disconnect" }), (0, import_jsx_runtime12.jsx)(Logout, {})] });
}
function Menu({ className, children, ...props }) {
  return (0, import_jsx_runtime12.jsx)(rn, { as: "div", className: clsx_default("ik-component ik-inline-block ik-text-left", className), ...props, children });
}
function Button({ className, ...props }) {
  return (0, import_jsx_runtime12.jsx)(It3, { ...props, className: clsx_default("ik-component", className) });
}
function ConnectedButton({ connectedAccount, icpBalance, className, children, ...props }) {
  return (0, import_jsx_runtime12.jsx)(Button, { id: "connect", type: "button", ...props, className: getButtonClassName({ className, type: "secondary" }), children: children ? children : (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsxs)("small", { className: "ik-mr-2", children: [connectedAccount.substring(0, 5), "...", connectedAccount.substring(connectedAccount.length - 5)] }), (0, import_jsx_runtime12.jsx)("div", { className: "ik-bg-white ik-px-[5px] ik-rounded-md", children: (0, import_jsx_runtime12.jsx)("small", { className: "ik-text-black ik-font-normal ik-text-xs", children: icpBalance !== void 0 && `${formatIcp(icpBalance)} ICP` }) })] }) });
}
function ConnectWallet({ connectButtonComponent, connectedButtonComponent, dropdownMenuComponent }) {
  const connect = useConnect();
  const disconnect = useDisconnect();
  const user = useUser();
  const { balance } = useBalance();
  const isInitializing = useIsInitializing();
  const isUserConnecting = useIsUserConnecting();
  const ConnectButtonComponent = connectButtonComponent ?? ConnectButton;
  const ConnectedButtonComponent = connectedButtonComponent ?? ConnectedButton;
  const DropdownMenuComponent = dropdownMenuComponent ?? Menu;
  if (!user)
    return (0, import_jsx_runtime12.jsx)(ConnectButtonComponent, { onClick: () => connect(), disabled: isInitializing, loading: isUserConnecting });
  const connectedAccount = user.principal.toString();
  const props = { disconnect, icpBalance: balance, connectedAccount };
  return (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children: (0, import_jsx_runtime12.jsxs)(DropdownMenuComponent, { ...dropdownMenuComponent ? props : {}, children: [(0, import_jsx_runtime12.jsx)(ConnectedButtonComponent, { connectedAccount, icpBalance: balance }), (0, import_jsx_runtime12.jsxs)(Items, { children: [(0, import_jsx_runtime12.jsx)(AddressItem, { value: connectedAccount }), (0, import_jsx_runtime12.jsx)(DisconnectItem, { onClick: disconnect })] })] }) });
}
var Tooltip2 = ({ tip, children, className, ...contentProps }) => {
  return (0, import_jsx_runtime12.jsxs)(Root32, { children: [(0, import_jsx_runtime12.jsx)(Trigger, { asChild: true, children }), (0, import_jsx_runtime12.jsx)(Portal2, { children: (0, import_jsx_runtime12.jsxs)(Content2, { sideOffset: 5, className: clsx_default("ik-text-white ik-text-sm ik-font-light ik-bg-black ik-py-2 ik-px-6 ik-rounded", className, ["left", "right"].includes(contentProps.side || "top") ? "ik-my-2" : "ik-mx-2"), ...contentProps, children: [tip, (0, import_jsx_runtime12.jsx)(Arrow22, { className: "ik-fill-current ik-text-black" })] }) })] });
};
var Header = ({ onBack, isViewAll }) => {
  return (0, import_jsx_runtime12.jsxs)("div", { className: "ik-flex ik-items-center ik-justify-between", children: [(0, import_jsx_runtime12.jsxs)("div", { className: "ik-flex ik-items-center ik-gap-[10px]", children: [isViewAll && (0, import_jsx_runtime12.jsxs)("svg", { "data-testid": "svg", onClick: onBack, className: "ik-text-black ik-cursor-pointer dark:ik-text-white", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime12.jsx)("path", { d: "M18.7272 11.864L4.99932 11.864", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime12.jsx)("path", { d: "M11.6562 18.5207L4.9994 11.8639L11.6562 5.20703", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" })] }), (0, import_jsx_runtime12.jsx)("p", { className: clsx_default("ik-font-bold ik-text-black dark:ik-text-white"), children: "Connect your wallet" })] }), (0, import_jsx_runtime12.jsx)(Tooltip2, { align: "end", side: "bottom", tip: (0, import_jsx_runtime12.jsxs)("div", { className: "ik-text-white ik-leading-[16px]", children: [(0, import_jsx_runtime12.jsx)("div", { className: "ik-text-sm ik-font-bold", children: "What is a Wallet?" }), (0, import_jsx_runtime12.jsx)("div", { className: "ik-text-xs ik-font-bold ik-mt-[12px]", children: "A home for digital assets" }), (0, import_jsx_runtime12.jsx)("p", { className: "ik-text-xs", children: "Wallets are used to send, receive, store, and display digital assets." }), (0, import_jsx_runtime12.jsx)("div", { className: "ik-text-xs ik-font-bold ik-mt-[12px]", children: "A new way to sign in" }), (0, import_jsx_runtime12.jsx)("p", { className: "ik-text-xs", children: "Instead of creating new accounts and passwords on every website, just connect your wallet instead." })] }), className: "ik-px-3 ik-bg-black ik-w-[320px] ik-z-[1011] -mr-[15px]", children: (0, import_jsx_runtime12.jsxs)("svg", { className: "ik-cursor-pointer", "data-testid": "info", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime12.jsx)("path", { d: "M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z", stroke: "#9CA3AF", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime12.jsx)("path", { d: "M12 16.125V11.3125", stroke: "#9CA3AF", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime12.jsx)("path", { d: "M12 7.875H12.0092", stroke: "#9CA3AF", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" })] }) })] });
};
var CustomSignerInput = ({ onSubmit }) => {
  const [value, setValue] = (0, import_react116.useState)("");
  const isValueValid = !value || validateUrl(value);
  return (0, import_jsx_runtime12.jsxs)("div", { children: [(0, import_jsx_runtime12.jsx)("div", { className: "ik-text-black dark:ik-text-white ik-font-bold ik-my-[20px]", children: "CustomConnect" }), (0, import_jsx_runtime12.jsxs)("div", { className: "ik-flex ik-items-center ik-gap-[12px] ik-relative", children: [(0, import_jsx_runtime12.jsx)("input", { className: "ik-rounded-xl ik-border ik-border-gray-400 ik-px-[10px] ik-h-[48px] ik-flex-1 ik-flex-shrink ik-text-sm ik-text-black dark:ik-text-white focus:ik-border-gray-400 ik-outline-none", placeholder: "https://wallet.url", type: "text", value, onChange: (e8) => {
    setValue(e8.target.value);
  }, name: "url" }), (0, import_jsx_runtime12.jsx)(Button$1, { large: true, disabled: !value || !isValueValid, className: "ik-w-[110px]", onClick: () => onSubmit(value), children: (0, import_jsx_runtime12.jsx)("small", { children: "Connect" }) })] }), !!value && !isValueValid && (0, import_jsx_runtime12.jsx)("p", { className: "ik-text-xs ik-text-red-500 ik-block ik-mt-1", children: "Invalid url" })] });
};
var SelectWalletList = ({ signers, onSelectSigner, isViewAll, onViewAll, featuredSigner, onCustomSignerSelect }) => {
  return (0, import_jsx_runtime12.jsxs)("div", { children: [(0, import_jsx_runtime12.jsx)("div", { className: "ik-flex ik-flex-col ik-gap-2 ik-relative ik-overflow-auto ik-max-h-[420px]", children: signers.map((signer) => {
    var _a4;
    return (0, import_jsx_runtime12.jsx)("div", { className: clsx_default("ik-border ik-shadow-[0px_2px_10px_rgba(0,0,0,0.03)] ik-rounded-[13px]", (featuredSigner == null ? void 0 : featuredSigner.id) === signer.id ? "ik-border-teal-600" : "ik-border-black/5 dark:ik-border-white/5"), children: (0, import_jsx_runtime12.jsxs)("div", { id: `signer_${signer.id}`, className: clsx_default("ik-bg-white dark:ik-bg-zinc-800 ik-rounded-[12px] ik-cursor-pointer", "hover:ik-bg-gray-50 dark:hover:ik-bg-signerDarkHoverBg", "ik-flex ik-items-center ik-space-x-3 ik-w-full ik-p-5", (featuredSigner == null ? void 0 : featuredSigner.id) === signer.id && ((_a4 = signer == null ? void 0 : signer.description) == null ? void 0 : _a4.length) && "!ik-items-start"), onClick: async () => {
      await onSelectSigner(signer.id);
    }, children: [(0, import_jsx_runtime12.jsx)("img", { src: signer.icon, alt: signer.label, className: "ik-w-8 ik-h-8" }), (0, import_jsx_runtime12.jsxs)("div", { className: "ik-text-black dark:ik-text-white", children: [(0, import_jsx_runtime12.jsx)("p", { className: "ik-text-sm ik-font-bold ik-leading-[25px]", children: signer.label }), (featuredSigner == null ? void 0 : featuredSigner.id) === signer.id && signer.description && (0, import_jsx_runtime12.jsx)("p", { className: "ik-text-xs ik-text-gray-400 dark:ik-text-zinc-400 ik-leading-[20px]", children: signer.description })] })] }) }, `signer_${signer.id}`);
  }) }), !isViewAll ? (0, import_jsx_runtime12.jsx)("div", { className: "ik-flex ik-py-3.5 ik-mt-2", children: (0, import_jsx_runtime12.jsx)("small", { onClick: onViewAll, className: "ik-text-primary dark:ik-text-teal-500 ik-font-bold ik-cursor-pointer ik-mx-auto ik-block", children: "View all" }) }) : (0, import_jsx_runtime12.jsx)(CustomSignerInput, { onSubmit: onCustomSignerSelect })] });
};
var Modal = () => {
  const { isModalOpen, toggleModal, signers, selectSigner, selectCustomSigner, featuredSigner } = useModal();
  const theme = useTheme();
  const [isViewAll, setIsViewAll] = (0, import_react116.useState)(false);
  const ref = useClickOutside(() => {
    if (isModalOpen)
      toggleModal();
  });
  (0, import_react116.useEffect)(() => {
    setTimeout(() => {
      if (!isModalOpen) {
        document.body.removeAttribute("data-scroll-locked");
      }
      document.body.style.pointerEvents = isModalOpen ? "none" : "";
      document.body.style.userSelect = isModalOpen ? "none" : "";
      document.body.style.overflow = isModalOpen ? "hidden" : "";
    }, 0);
  }, [isModalOpen]);
  const sortedSigners = (0, import_react116.useMemo)(() => {
    return signers.sort((a20, b9) => {
      if (a20.id === (featuredSigner == null ? void 0 : featuredSigner.id))
        return -1;
      if (b9.id === (featuredSigner == null ? void 0 : featuredSigner.id))
        return 1;
      return 0;
    });
  }, [signers, featuredSigner]);
  return (0, import_jsx_runtime12.jsx)(TooltipProvider, { children: (0, import_jsx_runtime12.jsx)(Root4, { open: true, children: (0, import_jsx_runtime12.jsxs)(Portal3, { children: [(0, import_jsx_runtime12.jsx)("div", { className: clsx_default(isModalOpen ? "ik-block" : "ik-hidden", "ik-component ik-bg-black ik-bg-opacity-25 ik-backdrop-blur-[2px]", "ik-fixed ik-inset-0 ik-z-[1009]") }), (0, import_jsx_runtime12.jsxs)(Content3, { ref, id: "ik-identity-kit-modal", "data-identity-kit-theme": theme, "aria-describedby": void 0, className: clsx_default("ik-component ik-flex-col ik-fixed ik-p-0 focus:ik-outline-none ik-z-[1010]", "ik-shadow-lg", "ik-top-[50%] ik-left-[50%] ik-max-h-[85vh] ik-w-[90vw] ik-max-w-[490px] ik-translate-x-[-50%] ik-translate-y-[-50%]", isModalOpen ? "ik-flex" : "ik-hidden"), children: [(0, import_jsx_runtime12.jsx)(Title, { className: "ik-hidden", children: "Select signer" }), (0, import_jsx_runtime12.jsxs)("div", { className: clsx_default("ik-flex ik-flex-col ik-rounded-xl ik-h-full", "ik-bg-[#FAFAFA] dark:ik-bg-black", "ik-p-[20px] ik-gap-[10px]"), children: [(0, import_jsx_runtime12.jsx)(Header, { onBack: () => setIsViewAll(false), isViewAll }), (0, import_jsx_runtime12.jsx)(SelectWalletList, { signers: sortedSigners, featuredSigner, onSelectSigner: selectSigner, isViewAll, onViewAll: () => setIsViewAll(true), onCustomSignerSelect: (url) => {
    if (!url)
      return;
    selectCustomSigner(url);
  } })] })] })] }) }) });
};
globalThis.global = globalThis;
var Provider = ({ children, signerClientOptions = {}, crypto: crypto2 = globalThis.crypto, window: window2 = globalThis.window, authType = IdentityKitAuthType.DELEGATION, realConnectDisabled, allowInternetIdentityPinAuthentication, discoverExtensionSigners = true, windowOpenerFeatures, ...props }) => {
  const [isModalOpen, setIsModalOpen] = (0, import_react116.useState)(false);
  const { createPromise, resolve, reject } = useCreatePromise();
  const toggleModal = () => {
    setIsModalOpen((prev) => !prev);
  };
  const [transports, setTransports] = (0, import_react116.useState)();
  const [transportsLoading, setTransportsLoading] = (0, import_react116.useState)(false);
  const { maxTimeToLive, keyType, storage, identity: identity2 } = signerClientOptions;
  const { signers, featuredSigner } = (0, import_react116.useMemo)(() => {
    const signersList = !props.signers || !props.signers.length ? [NFIDW, InternetIdentity] : props.signers;
    const selectedFeaturedSigner = props.featuredSigner === false ? void 0 : props.featuredSigner ?? signersList[0];
    return {
      signers: signersList,
      featuredSigner: selectedFeaturedSigner
    };
  }, [props.signers, props.featuredSigner, signerClientOptions]);
  (0, import_react116.useEffect)(() => {
    if (signers.length && !transports && !transportsLoading) {
      setTransportsLoading(true);
      Promise.all(signers.map(async (signer) => {
        const transport = await TransportBuilder.build({
          maxTimeToLive,
          derivationOrigin: signerClientOptions.derivationOrigin,
          allowInternetIdentityPinAuthentication,
          keyType,
          storage,
          identity: identity2,
          id: signer.id,
          transportType: signer.transportType,
          url: signer.providerUrl,
          crypto: crypto2,
          window: window2,
          windowOpenerFeatures
        });
        return {
          value: transport,
          signerId: signer.id
        };
      })).then(setTransports).finally(() => {
        setTransportsLoading(false);
      });
    }
  }, [signers, transports, transportsLoading]);
  const [discoveredSigners, setDiscoveredSigners] = (0, import_react116.useState)([]);
  (0, import_react116.useEffect)(() => {
    if (!discoverExtensionSigners) {
      return;
    }
    BrowserExtensionTransport.discover().then(async (providerDetails) => {
      setDiscoveredSigners(await Promise.all(providerDetails.map(async (providerDetail) => ({
        config: {
          id: providerDetail.uuid,
          providerUrl: "",
          label: providerDetail.name,
          transportType: TransportType.EXTENSION,
          icon: providerDetail.icon
        },
        transport: {
          signerId: providerDetail.uuid,
          value: await TransportBuilder.build({
            maxTimeToLive,
            derivationOrigin: signerClientOptions.derivationOrigin,
            allowInternetIdentityPinAuthentication,
            keyType,
            storage,
            identity: identity2,
            id: providerDetail.uuid,
            transportType: TransportType.EXTENSION,
            url: "",
            crypto: crypto2,
            window: window2
          })
        }
      }))));
    });
  }, [discoverExtensionSigners]);
  const signersIncludingDiscovered = (0, import_react116.useMemo)(() => [...signers, ...discoveredSigners.map(({ config }) => config)], [signers, discoveredSigners]);
  const transportsIncludingDiscovered = (0, import_react116.useMemo)(() => [...transports ?? [], ...discoveredSigners.map(({ transport }) => transport)], [transports, discoveredSigners]);
  const { selectSigner, clearSigner, selectedSigner, localStorageSigner, selectCustomSigner, setSelectedSignerToLocalStorage, isSignerBeingSelected } = useProceedSigner({
    signers: signersIncludingDiscovered,
    closeModal: () => setIsModalOpen(false),
    onConnectFailure: reject,
    crypto: crypto2,
    window: window2,
    windowOpenerFeatures,
    transports: transportsIncludingDiscovered
  });
  const onConnectSuccess = (0, import_react116.useCallback)(() => {
    setSelectedSignerToLocalStorage();
    resolve();
  }, [setSelectedSignerToLocalStorage, resolve]);
  const identityKit = useCreateIdentityKit({
    selectedSigner,
    clearSigner,
    signerClientOptions: { ...signerClientOptions, crypto: crypto2 },
    authType,
    onConnectSuccess,
    onConnectFailure: reject,
    onDisconnect: props.onDisconnect,
    realConnectDisabled
  });
  const isInitializing = (0, import_react116.useMemo)(() => !transports || !!localStorageSigner && !identityKit.user, [localStorageSigner, identityKit.user, transports]);
  const isUserConnecting = (0, import_react116.useMemo)(() => selectedSigner ? !identityKit.user : isSignerBeingSelected, [selectedSigner, identityKit.user, isSignerBeingSelected]);
  const connect = (0, import_react116.useCallback)(async (signerIdOrUrl) => {
    try {
      if (isInitializing)
        throw new Error("Identitykit is not initialized yet");
      if (!signerIdOrUrl)
        setIsModalOpen(true);
      else {
        if (signers.find((s13) => s13.id === signerIdOrUrl))
          await selectSigner(signerIdOrUrl);
        else {
          if (!validateUrl(signerIdOrUrl))
            throw new Error("Provided value is not valid signer id or url");
          await selectCustomSigner(signerIdOrUrl);
        }
      }
    } catch (e8) {
      if (props.onConnectFailure) {
        props.onConnectFailure(e8);
      } else {
        throw e8;
      }
    }
    return createPromise().then(() => {
      var _a4;
      (_a4 = props.onConnectSuccess) == null ? void 0 : _a4.call(props);
    }).catch(async (e8) => {
      if (props.onConnectFailure) {
        props.onConnectFailure(e8);
      } else {
        throw e8;
      }
    });
  }, [isInitializing, signers, selectedSigner]);
  return (0, import_jsx_runtime12.jsx)(Context.Provider, { value: {
    signers: signersIncludingDiscovered,
    selectedSigner,
    isModalOpen,
    featuredSigner,
    user: identityKit.user,
    icpBalance: identityKit.icpBalance,
    authType,
    signerClient: identityKit.signerClient,
    isInitializing,
    isUserConnecting,
    toggleModal,
    selectSigner,
    selectCustomSigner,
    connect,
    disconnect: identityKit.disconnect,
    fetchIcpBalance: identityKit.fetchIcpBalance
  }, children: (0, import_jsx_runtime12.jsxs)(ThemeProvider, { theme: props.theme, children: [(0, import_jsx_runtime12.jsx)(Modal, {}), children] }) });
};
export {
  ConnectWallet,
  ConnectButton as ConnectWalletButton,
  Menu as ConnectWalletDropdownMenu,
  AddressItem as ConnectWalletDropdownMenuAddressItem,
  Button as ConnectWalletDropdownMenuButton,
  DisconnectItem as ConnectWalletDropdownMenuDisconnectItem,
  Item as ConnectWalletDropdownMenuItem,
  Items as ConnectWalletDropdownMenuItems,
  ConnectedButton as ConnectedWalletButton,
  DEFAULT_SIZES,
  Provider as IdentityKitProvider,
  IdentityKitTheme,
  formatIcp,
  useAccounts,
  useAgent,
  useAuth,
  useBalance,
  useDelegationType,
  useIdentity,
  useIdentityKit,
  useIsInitializing,
  useSignerConfig as useSigner
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@nfid_identitykit_react.js.map
