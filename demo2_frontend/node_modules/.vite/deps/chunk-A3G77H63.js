import {
  Actor
} from "./chunk-KPLXDLSU.js";
import {
  AnonymousIdentity,
  Certificate,
  ED25519_OID,
  Expiry,
  HttpAgent,
  IC_ROOT_KEY,
  LookupStatus,
  PipeArrayBuffer,
  Principal,
  SignIdentity,
  SubmitRequestType,
  bufEquals,
  bufFromBufLike,
  cbor_exports,
  compare,
  ed25519,
  fromHex,
  init_esm,
  init_utils,
  lebDecode,
  lookupResultToBuffer,
  requestIdOf,
  require_src,
  require_src2,
  toHex,
  uint8ToBuf,
  unwrapDER,
  wrapDER
} from "./chunk-CGUMSA2O.js";
import {
  __toESM
} from "./chunk-2GTGKKMZ.js";

// ../../node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
var __classPrivateFieldSet = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _Ed25519PublicKey_rawKey;
var _Ed25519PublicKey_derKey;
var _Ed25519KeyIdentity_publicKey;
var _Ed25519KeyIdentity_privateKey;
function isObject(value2) {
  return value2 !== null && typeof value2 === "object";
}
var Ed25519PublicKey = class _Ed25519PublicKey {
  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
  constructor(key) {
    _Ed25519PublicKey_rawKey.set(this, void 0);
    _Ed25519PublicKey_derKey.set(this, void 0);
    if (key.byteLength !== _Ed25519PublicKey.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, "f");
    __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, _Ed25519PublicKey.derEncode(key), "f");
  }
  /**
   * Construct Ed25519PublicKey from an existing PublicKey
   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string
   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey
   */
  static from(maybeKey) {
    if (typeof maybeKey === "string") {
      const key = fromHex(maybeKey);
      return this.fromRaw(key);
    } else if (isObject(maybeKey)) {
      const key = maybeKey;
      if (isObject(key) && Object.hasOwnProperty.call(key, "__derEncodedPublicKey__")) {
        return this.fromDer(key);
      } else if (ArrayBuffer.isView(key)) {
        const view = key;
        return this.fromRaw(bufFromBufLike(view.buffer));
      } else if (key instanceof ArrayBuffer) {
        return this.fromRaw(key);
      } else if ("rawKey" in key) {
        return this.fromRaw(key.rawKey);
      } else if ("derKey" in key) {
        return this.fromDer(key.derKey);
      } else if ("toDer" in key) {
        return this.fromDer(key.toDer());
      }
    }
    throw new Error("Cannot construct Ed25519PublicKey from the provided key.");
  }
  static fromRaw(rawKey) {
    return new _Ed25519PublicKey(rawKey);
  }
  static fromDer(derKey) {
    return new _Ed25519PublicKey(this.derDecode(derKey));
  }
  static derEncode(publicKey) {
    const key = wrapDER(publicKey, ED25519_OID).buffer;
    key.__derEncodedPublicKey__ = void 0;
    return key;
  }
  static derDecode(key) {
    const unwrapped = unwrapDER(key, ED25519_OID);
    if (unwrapped.length !== this.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    return unwrapped;
  }
  get rawKey() {
    return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
  }
  get derKey() {
    return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
  }
  toDer() {
    return this.derKey;
  }
  toRaw() {
    return this.rawKey;
  }
};
_Ed25519PublicKey_rawKey = /* @__PURE__ */ new WeakMap(), _Ed25519PublicKey_derKey = /* @__PURE__ */ new WeakMap();
Ed25519PublicKey.RAW_KEY_LENGTH = 32;
var Ed25519KeyIdentity = class _Ed25519KeyIdentity extends SignIdentity {
  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
  constructor(publicKey, privateKey) {
    super();
    _Ed25519KeyIdentity_publicKey.set(this, void 0);
    _Ed25519KeyIdentity_privateKey.set(this, void 0);
    __classPrivateFieldSet(this, _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), "f");
    __classPrivateFieldSet(this, _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), "f");
  }
  /**
   * Generate a new Ed25519KeyIdentity.
   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.
   * @returns Ed25519KeyIdentity
   */
  static generate(seed) {
    if (seed && seed.length !== 32) {
      throw new Error("Ed25519 Seed needs to be 32 bytes long.");
    }
    if (!seed)
      seed = ed25519.utils.randomPrivateKey();
    if (bufEquals(seed, new Uint8Array(new Array(32).fill(0)))) {
      console.warn("Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.");
    }
    const sk = new Uint8Array(32);
    for (let i = 0; i < 32; i++)
      sk[i] = new Uint8Array(seed)[i];
    const pk = ed25519.getPublicKey(sk);
    return _Ed25519KeyIdentity.fromKeyPair(pk, sk);
  }
  static fromParsedJson(obj) {
    const [publicKeyDer, privateKeyRaw] = obj;
    return new _Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHex(publicKeyDer)), fromHex(privateKeyRaw));
  }
  static fromJSON(json) {
    const parsed = JSON.parse(json);
    if (Array.isArray(parsed)) {
      if (typeof parsed[0] === "string" && typeof parsed[1] === "string") {
        return this.fromParsedJson([parsed[0], parsed[1]]);
      } else {
        throw new Error("Deserialization error: JSON must have at least 2 items.");
      }
    }
    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);
  }
  static fromKeyPair(publicKey, privateKey) {
    return new _Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
  }
  static fromSecretKey(secretKey) {
    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));
    return _Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);
  }
  /**
   * Serialize this key to JSON.
   */
  toJSON() {
    return [toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f").toDer()), toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"))];
  }
  /**
   * Return a copy of the key pair.
   */
  getKeyPair() {
    return {
      secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"),
      publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f")
    };
  }
  /**
   * Return the public key.
   */
  getPublicKey() {
    return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f");
  }
  /**
   * Signs a blob of data, with this identity's private key.
   * @param challenge - challenge to sign with this identity's secretKey, producing a signature
   */
  async sign(challenge) {
    const blob = new Uint8Array(challenge);
    const signature = uint8ToBuf(ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f").slice(0, 32)));
    Object.defineProperty(signature, "__signature__", {
      enumerable: false,
      value: void 0
    });
    return signature;
  }
  /**
   * Verify
   * @param sig - signature to verify
   * @param msg - message to verify
   * @param pk - public key
   * @returns - true if the signature is valid, false otherwise
   */
  static verify(sig, msg, pk) {
    const [signature, message, publicKey] = [sig, msg, pk].map((x2) => {
      if (typeof x2 === "string") {
        x2 = fromHex(x2);
      }
      if (x2 instanceof Uint8Array) {
        x2 = x2.buffer;
      }
      return new Uint8Array(x2);
    });
    return ed25519.verify(message, signature, publicKey);
  }
};
_Ed25519KeyIdentity_publicKey = /* @__PURE__ */ new WeakMap(), _Ed25519KeyIdentity_privateKey = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js
var CryptoError = class _CryptoError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    Object.setPrototypeOf(this, _CryptoError.prototype);
  }
};
function _getEffectiveCrypto(subtleCrypto) {
  if (typeof globalThis !== "undefined" && globalThis["crypto"] && globalThis["crypto"]["subtle"]) {
    return globalThis["crypto"]["subtle"];
  }
  if (subtleCrypto) {
    return subtleCrypto;
  } else if (typeof crypto !== "undefined" && crypto["subtle"]) {
    return crypto.subtle;
  } else {
    throw new CryptoError("Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto");
  }
}
var ECDSAKeyIdentity = class _ECDSAKeyIdentity extends SignIdentity {
  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.
  constructor(keyPair, derKey, subtleCrypto) {
    super();
    this._keyPair = keyPair;
    this._derKey = derKey;
    this._subtleCrypto = subtleCrypto;
  }
  /**
   * Generates a randomly generated identity for use in calls to the Internet Computer.
   * @param {CryptoKeyOptions} options optional settings
   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.
   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for
   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface
   * @constructs ECDSAKeyIdentity
   * @returns a {@link ECDSAKeyIdentity}
   */
  static async generate(options) {
    const { extractable = false, keyUsages = ["sign", "verify"], subtleCrypto } = options !== null && options !== void 0 ? options : {};
    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
    const keyPair = await effectiveCrypto.generateKey({
      name: "ECDSA",
      namedCurve: "P-256"
    }, extractable, keyUsages);
    const derKey = await effectiveCrypto.exportKey("spki", keyPair.publicKey);
    return new this(keyPair, derKey, effectiveCrypto);
  }
  /**
   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key
   * @param keyPair a CryptoKeyPair
   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally
   * @returns an {@link ECDSAKeyIdentity}
   */
  static async fromKeyPair(keyPair, subtleCrypto) {
    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
    const derKey = await effectiveCrypto.exportKey("spki", keyPair.publicKey);
    return new _ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);
  }
  /**
   * Return the internally-used key pair.
   * @returns a CryptoKeyPair
   */
  getKeyPair() {
    return this._keyPair;
  }
  /**
   * Return the public key.
   * @returns an {@link PublicKey & DerCryptoKey}
   */
  getPublicKey() {
    const derKey = this._derKey;
    const key = Object.create(this._keyPair.publicKey);
    key.toDer = function() {
      return derKey;
    };
    return key;
  }
  /**
   * Signs a blob of data, with this identity's private key.
   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature
   * @returns {Promise<Signature>} signature
   */
  async sign(challenge) {
    const params = {
      name: "ECDSA",
      hash: { name: "SHA-256" }
    };
    const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);
    return signature;
  }
};

// ../../node_modules/@dfinity/identity/lib/esm/identity/partial.js
init_esm();
var __classPrivateFieldSet2 = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _PartialIdentity_inner;
var PartialIdentity = class {
  constructor(inner) {
    _PartialIdentity_inner.set(this, void 0);
    __classPrivateFieldSet2(this, _PartialIdentity_inner, inner, "f");
  }
  /**
   * The raw public key of this identity.
   */
  get rawKey() {
    return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").rawKey;
  }
  /**
   * The DER-encoded public key of this identity.
   */
  get derKey() {
    return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").derKey;
  }
  /**
   * The DER-encoded public key of this identity.
   */
  toDer() {
    return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").toDer();
  }
  /**
   * The inner {@link PublicKey} used by this identity.
   */
  getPublicKey() {
    return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f");
  }
  /**
   * The {@link Principal} of this identity.
   */
  getPrincipal() {
    return Principal.from(__classPrivateFieldGet2(this, _PartialIdentity_inner, "f").rawKey);
  }
  /**
   * Required for the Identity interface, but cannot implemented for just a public key.
   */
  transformRequest() {
    return Promise.reject("Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.");
  }
};
_PartialIdentity_inner = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@dfinity/identity/lib/esm/identity/delegation.js
init_esm();
var cbor = __toESM(require_src2());
var __classPrivateFieldSet3 = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __rest = function(s, e4) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e4.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e4.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _PartialDelegationIdentity_delegation;
var domainSeparator = new TextEncoder().encode("ic-request-auth-delegation");
var requestDomainSeparator = new TextEncoder().encode("\nic-request");
function _parseBlob(value2) {
  if (typeof value2 !== "string" || value2.length < 64) {
    throw new Error("Invalid public key.");
  }
  return fromHex(value2);
}
var Delegation = class {
  constructor(pubkey, expiration, targets) {
    this.pubkey = pubkey;
    this.expiration = expiration;
    this.targets = targets;
  }
  toCBOR() {
    return cbor.value.map(Object.assign({ pubkey: cbor.value.bytes(this.pubkey), expiration: cbor.value.u64(this.expiration.toString(16), 16) }, this.targets && {
      targets: cbor.value.array(this.targets.map((t) => cbor.value.bytes(t.toUint8Array())))
    }));
  }
  toJSON() {
    return Object.assign({ expiration: this.expiration.toString(16), pubkey: toHex(this.pubkey) }, this.targets && { targets: this.targets.map((p) => p.toHex()) });
  }
};
async function _createSingleDelegation(from, to, expiration, targets) {
  const delegation = new Delegation(
    to.toDer(),
    BigInt(+expiration) * BigInt(1e6),
    // In nanoseconds.
    targets
  );
  const challenge = new Uint8Array([
    ...domainSeparator,
    ...new Uint8Array(requestIdOf(Object.assign({}, delegation)))
  ]);
  const signature = await from.sign(challenge);
  return {
    delegation,
    signature
  };
}
var DelegationChain = class _DelegationChain {
  constructor(delegations, publicKey) {
    this.delegations = delegations;
    this.publicKey = publicKey;
  }
  /**
   * Create a delegation chain between two (or more) keys. By default, the expiration time
   * will be very short (15 minutes).
   *
   * To build a chain of more than 2 identities, this function needs to be called multiple times,
   * passing the previous delegation chain into the options argument. For example:
   * @example
   * const rootKey = createKey();
   * const middleKey = createKey();
   * const bottomeKey = createKey();
   *
   * const rootToMiddle = await DelegationChain.create(
   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),
   * );
   * const middleToBottom = await DelegationChain.create(
   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },
   * );
   *
   * // We can now use a delegation identity that uses the delegation above:
   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);
   * @param from The identity that will delegate.
   * @param to The identity that gets delegated. It can now sign messages as if it was the
   *           identity above.
   * @param expiration The length the delegation is valid. By default, 15 minutes from calling
   *                   this function.
   * @param options A set of options for this delegation. expiration and previous
   * @param options.previous - Another DelegationChain that this chain should start with.
   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)
   */
  static async create(from, to, expiration = new Date(Date.now() + 15 * 60 * 1e3), options = {}) {
    var _a2, _b;
    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);
    return new _DelegationChain([...((_a2 = options.previous) === null || _a2 === void 0 ? void 0 : _a2.delegations) || [], delegation], ((_b = options.previous) === null || _b === void 0 ? void 0 : _b.publicKey) || from.getPublicKey().toDer());
  }
  /**
   * Creates a DelegationChain object from a JSON string.
   * @param json The JSON string to parse.
   */
  static fromJSON(json) {
    const { publicKey, delegations } = typeof json === "string" ? JSON.parse(json) : json;
    if (!Array.isArray(delegations)) {
      throw new Error("Invalid delegations.");
    }
    const parsedDelegations = delegations.map((signedDelegation) => {
      const { delegation, signature } = signedDelegation;
      const { pubkey, expiration, targets } = delegation;
      if (targets !== void 0 && !Array.isArray(targets)) {
        throw new Error("Invalid targets.");
      }
      return {
        delegation: new Delegation(
          _parseBlob(pubkey),
          BigInt("0x" + expiration),
          // expiration in JSON is an hexa string (See toJSON() below).
          targets && targets.map((t) => {
            if (typeof t !== "string") {
              throw new Error("Invalid target.");
            }
            return Principal.fromHex(t);
          })
        ),
        signature: _parseBlob(signature)
      };
    });
    return new this(parsedDelegations, _parseBlob(publicKey));
  }
  /**
   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.
   * @param delegations The list of delegations.
   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.
   */
  static fromDelegations(delegations, publicKey) {
    return new this(delegations, publicKey);
  }
  toJSON() {
    return {
      delegations: this.delegations.map((signedDelegation) => {
        const { delegation, signature } = signedDelegation;
        const { targets } = delegation;
        return {
          delegation: Object.assign({ expiration: delegation.expiration.toString(16), pubkey: toHex(delegation.pubkey) }, targets && {
            targets: targets.map((t) => t.toHex())
          }),
          signature: toHex(signature)
        };
      }),
      publicKey: toHex(this.publicKey)
    };
  }
};
var DelegationIdentity = class extends SignIdentity {
  constructor(_inner, _delegation) {
    super();
    this._inner = _inner;
    this._delegation = _delegation;
  }
  /**
   * Create a delegation without having access to delegateKey.
   * @param key The key used to sign the requests.
   * @param delegation A delegation object created using `createDelegation`.
   */
  static fromDelegation(key, delegation) {
    return new this(key, delegation);
  }
  getDelegation() {
    return this._delegation;
  }
  getPublicKey() {
    return {
      derKey: this._delegation.publicKey,
      toDer: () => this._delegation.publicKey
    };
  }
  sign(blob) {
    return this._inner.sign(blob);
  }
  async transformRequest(request) {
    const { body } = request, fields = __rest(request, ["body"]);
    const requestId = await requestIdOf(body);
    return Object.assign(Object.assign({}, fields), { body: {
      content: body,
      sender_sig: await this.sign(new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)])),
      sender_delegation: this._delegation.delegations,
      sender_pubkey: this._delegation.publicKey
    } });
  }
};
var PartialDelegationIdentity = class _PartialDelegationIdentity extends PartialIdentity {
  constructor(inner, delegation) {
    super(inner);
    _PartialDelegationIdentity_delegation.set(this, void 0);
    __classPrivateFieldSet3(this, _PartialDelegationIdentity_delegation, delegation, "f");
  }
  /**
   * The Delegation Chain of this identity.
   */
  get delegation() {
    return __classPrivateFieldGet3(this, _PartialDelegationIdentity_delegation, "f");
  }
  /**
   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.
   * @param key The {@link PublicKey} to delegate to.
   * @param delegation a {@link DelegationChain} targeting the inner key.
   * @constructs PartialDelegationIdentity
   */
  static fromDelegation(key, delegation) {
    return new _PartialDelegationIdentity(key, delegation);
  }
};
_PartialDelegationIdentity_delegation = /* @__PURE__ */ new WeakMap();
function isDelegationValid(chain, checks) {
  for (const { delegation } of chain.delegations) {
    if (+new Date(Number(delegation.expiration / BigInt(1e6))) <= +Date.now()) {
      return false;
    }
  }
  const scopes = [];
  const maybeScope = checks === null || checks === void 0 ? void 0 : checks.scope;
  if (maybeScope) {
    if (Array.isArray(maybeScope)) {
      scopes.push(...maybeScope.map((s) => typeof s === "string" ? Principal.fromText(s) : s));
    } else {
      scopes.push(typeof maybeScope === "string" ? Principal.fromText(maybeScope) : maybeScope);
    }
  }
  for (const s of scopes) {
    const scope = s.toText();
    for (const { delegation } of chain.delegations) {
      if (delegation.targets === void 0) {
        continue;
      }
      let none = true;
      for (const target of delegation.targets) {
        if (target.toText() === scope) {
          none = false;
          break;
        }
      }
      if (none) {
        return false;
      }
    }
  }
  return true;
}

// ../../node_modules/@dfinity/identity/lib/esm/identity/webauthn.js
var import_borc = __toESM(require_src());
init_utils();
var PubKeyCoseAlgo;
(function(PubKeyCoseAlgo2) {
  PubKeyCoseAlgo2[PubKeyCoseAlgo2["ECDSA_WITH_SHA256"] = -7] = "ECDSA_WITH_SHA256";
})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));

// ../../node_modules/@slide-computer/signer/lib/esm/utils.js
var ENCODE_CHUNK_SIZE = 1e5;
var fromBase64 = (base64) => {
  if (typeof globalThis.Buffer !== "undefined") {
    return globalThis.Buffer.from(base64, "base64").buffer;
  }
  if (typeof globalThis.atob !== "undefined") {
    return Uint8Array.from(globalThis.atob(base64), (m3) => m3.charCodeAt(0)).buffer;
  }
  throw Error("Could not decode base64 string");
};
var toBase64 = (bytes) => {
  if (typeof globalThis.Buffer !== "undefined") {
    return globalThis.Buffer.from(bytes).toString("base64");
  }
  if (typeof globalThis.btoa !== "undefined") {
    return btoa(Array.from({ length: Math.ceil(bytes.byteLength / ENCODE_CHUNK_SIZE) }).map((_2, index) => String.fromCharCode(...new Uint8Array(bytes.slice(index * ENCODE_CHUNK_SIZE, (index + 1) * ENCODE_CHUNK_SIZE)))).join(""));
  }
  throw Error("Could not encode base64 string");
};

// ../../node_modules/@slide-computer/signer/lib/esm/signer.js
init_esm();

// ../../node_modules/@slide-computer/signer/lib/esm/errors.js
var INVALID_REQUEST_ERROR = -32600;
var NOT_SUPPORTED_ERROR = 2e3;
var NETWORK_ERROR = 4e3;

// ../../node_modules/@slide-computer/signer/lib/esm/signer.js
var __classPrivateFieldSet4 = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _Signer_options;
var _Signer_channel;
var _Signer_establishingChannel;
var _Signer_scheduledChannelClosure;
var SignerError = class _SignerError extends Error {
  constructor(error) {
    super(error.message);
    Object.setPrototypeOf(this, _SignerError.prototype);
    this.code = error.code;
    this.data = error.data;
  }
};
var wrapTransportError = (error) => new SignerError({
  code: NETWORK_ERROR,
  message: error instanceof Error ? error.message : "Network error"
});
var unwrapResponse = (response) => {
  if ("error" in response) {
    throw new SignerError(response.error);
  }
  if ("result" in response) {
    return response.result;
  }
  throw new SignerError({
    code: NETWORK_ERROR,
    message: "Invalid response"
  });
};
var Signer = class {
  constructor(options) {
    _Signer_options.set(this, void 0);
    _Signer_channel.set(this, void 0);
    _Signer_establishingChannel.set(this, void 0);
    _Signer_scheduledChannelClosure.set(this, void 0);
    __classPrivateFieldSet4(this, _Signer_options, Object.assign({ autoCloseTransportChannel: true, closeTransportChannelAfter: 200, crypto: globalThis.crypto }, options), "f");
  }
  get transport() {
    return __classPrivateFieldGet4(this, _Signer_options, "f").transport;
  }
  async openChannel() {
    clearTimeout(__classPrivateFieldGet4(this, _Signer_scheduledChannelClosure, "f"));
    if (__classPrivateFieldGet4(this, _Signer_establishingChannel, "f")) {
      await __classPrivateFieldGet4(this, _Signer_establishingChannel, "f");
    }
    if (__classPrivateFieldGet4(this, _Signer_channel, "f") && !__classPrivateFieldGet4(this, _Signer_channel, "f").closed) {
      return __classPrivateFieldGet4(this, _Signer_channel, "f");
    }
    const channel = __classPrivateFieldGet4(this, _Signer_options, "f").transport.establishChannel();
    __classPrivateFieldSet4(this, _Signer_establishingChannel, channel.then(() => {
    }).catch(() => {
    }), "f");
    __classPrivateFieldSet4(this, _Signer_channel, void 0, "f");
    __classPrivateFieldSet4(this, _Signer_channel, await channel.catch((error) => {
      throw wrapTransportError(error);
    }), "f");
    __classPrivateFieldSet4(this, _Signer_establishingChannel, void 0, "f");
    return __classPrivateFieldGet4(this, _Signer_channel, "f");
  }
  async closeChannel() {
    var _a2;
    await ((_a2 = __classPrivateFieldGet4(this, _Signer_channel, "f")) === null || _a2 === void 0 ? void 0 : _a2.close());
  }
  async transformRequest(request) {
    if (__classPrivateFieldGet4(this, _Signer_options, "f").derivationOrigin) {
      return Object.assign(Object.assign({}, request), { params: Object.assign(Object.assign({}, request.params), { icrc95DerivationOrigin: __classPrivateFieldGet4(this, _Signer_options, "f").derivationOrigin }) });
    }
    return request;
  }
  async sendRequest(request) {
    const channel = await this.openChannel();
    return new Promise(async (resolve, reject) => {
      const responseListener = channel.addEventListener("response", async (response) => {
        if (response.id !== request.id) {
          return;
        }
        responseListener();
        closeListener();
        resolve(response);
        if (__classPrivateFieldGet4(this, _Signer_options, "f").autoCloseTransportChannel) {
          __classPrivateFieldSet4(this, _Signer_scheduledChannelClosure, setTimeout(() => {
            if (!channel.closed) {
              channel.close();
            }
          }, __classPrivateFieldGet4(this, _Signer_options, "f").closeTransportChannelAfter), "f");
        }
      });
      const closeListener = channel.addEventListener("close", () => {
        responseListener();
        closeListener();
        reject(new SignerError({
          code: NETWORK_ERROR,
          message: "Channel was closed before a response was received"
        }));
      });
      try {
        await channel.send(await this.transformRequest(request));
      } catch (error) {
        responseListener();
        closeListener();
        reject(wrapTransportError(error));
      }
    });
  }
  async supportedStandards() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_supported_standards"
    });
    const result = unwrapResponse(response);
    return result.supportedStandards;
  }
  async requestPermissions(scopes) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_request_permissions",
      params: { scopes }
    });
    const result = unwrapResponse(response);
    return result.scopes;
  }
  async permissions() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_permissions"
    });
    const result = unwrapResponse(response);
    return result.scopes;
  }
  async accounts() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc27_accounts"
    });
    const result = unwrapResponse(response);
    return result.accounts.map(({ owner, subaccount }) => ({
      owner: Principal.fromText(owner),
      subaccount: subaccount === void 0 ? void 0 : fromBase64(subaccount)
    }));
  }
  async delegation(params) {
    var _a2;
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc34_delegation",
      params: {
        publicKey: toBase64(params.publicKey),
        targets: (_a2 = params.targets) === null || _a2 === void 0 ? void 0 : _a2.map((p) => p.toText()),
        maxTimeToLive: params.maxTimeToLive === void 0 ? void 0 : String(params.maxTimeToLive)
      }
    });
    const result = unwrapResponse(response);
    return DelegationChain.fromDelegations(result.signerDelegation.map((delegation) => {
      var _a3;
      return {
        delegation: new Delegation(fromBase64(delegation.delegation.pubkey), BigInt(delegation.delegation.expiration), (_a3 = delegation.delegation.targets) === null || _a3 === void 0 ? void 0 : _a3.map((principal) => Principal.fromText(principal))),
        signature: fromBase64(delegation.signature)
      };
    }), fromBase64(result.publicKey));
  }
  async callCanister(params) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc49_call_canister",
      params: {
        canisterId: params.canisterId.toText(),
        sender: params.sender.toText(),
        method: params.method,
        arg: toBase64(params.arg)
      }
    });
    const result = unwrapResponse(response);
    const contentMap = fromBase64(result.contentMap);
    const certificate = fromBase64(result.certificate);
    return { contentMap, certificate };
  }
  async batchCallCanister(params) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet4(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc112_batch_call_canister",
      params: {
        sender: params.sender.toText(),
        requests: params.requests.map((requests) => requests.map((request) => ({
          canisterId: request.canisterId.toText(),
          method: request.method,
          arg: toBase64(request.arg)
        }))),
        validation: params.validation ? {
          canisterId: params.validation.canisterId.toText(),
          method: params.validation.method
        } : void 0
      }
    });
    const result = unwrapResponse(response);
    if (params.requests.length !== result.responses.length || params.requests.some((entries, index) => entries.length !== result.responses[index].length)) {
      throw new SignerError({
        code: NETWORK_ERROR,
        message: "Invalid batch call canister response, responses structure does not match request structure"
      });
    }
    return result.responses.map((responses) => responses.map((response2) => {
      if ("result" in response2) {
        const contentMap = fromBase64(response2.result.contentMap);
        const certificate = fromBase64(response2.result.certificate);
        return { result: { contentMap, certificate } };
      }
      return response2;
    }));
  }
};
_Signer_options = /* @__PURE__ */ new WeakMap(), _Signer_channel = /* @__PURE__ */ new WeakMap(), _Signer_establishingChannel = /* @__PURE__ */ new WeakMap(), _Signer_scheduledChannelClosure = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@slide-computer/signer/lib/esm/icrc34/delegation.js
init_esm();

// ../../node_modules/@slide-computer/signer/lib/esm/transport.js
var isJsonRpcMessage = (message) => typeof message === "object" && !!message && "jsonrpc" in message && message.jsonrpc === "2.0";
var isJsonRpcRequest = (message) => isJsonRpcMessage(message) && "method" in message && typeof message.method === "string";
var isJsonRpcResponse = (message) => isJsonRpcMessage(message) && "id" in message && (typeof message.id === "string" || typeof message.id === "number");

// ../../node_modules/@slide-computer/signer-agent/lib/esm/agent.js
init_esm();

// ../../node_modules/@slide-computer/signer-agent/lib/esm/utils.js
init_esm();

// ../../node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v3, b3) {
    var alphabet, c3, caseChanged, e4, i, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2))
      return new BigNumber2(v3, b3);
    if (b3 == null) {
      if (v3 && v3._isBigNumber === true) {
        x2.s = v3.s;
        if (!v3.c || v3.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v3.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v3.e;
          x2.c = v3.c.slice();
        }
        return;
      }
      if ((isNum = typeof v3 == "number") && v3 * 0 == 0) {
        x2.s = 1 / v3 < 0 ? (v3 = -v3, -1) : 1;
        if (v3 === ~~v3) {
          for (e4 = 0, i = v3; i >= 10; i /= 10, e4++)
            ;
          if (e4 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e4;
            x2.c = [v3];
          }
          return;
        }
        str = String(v3);
      } else {
        if (!isNumeric.test(str = String(v3)))
          return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e4 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e4 < 0)
          e4 = i;
        e4 += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e4 < 0) {
        e4 = str.length;
      }
    } else {
      intCheck(b3, 2, ALPHABET.length, "Base");
      if (b3 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v3);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v3);
      if (isNum = typeof v3 == "number") {
        if (v3 * 0 != 0)
          return parseNumeric(x2, str, isNum, b3);
        x2.s = 1 / v3 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v3);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b3);
      e4 = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c3 = str.charAt(i)) < 0) {
          if (c3 == ".") {
            if (i > e4) {
              e4 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e4 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v3), isNum, b3);
        }
      }
      isNum = false;
      str = convertBase(str, b3, 10, x2.s);
      if ((e4 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e4 = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v3 > MAX_SAFE_INTEGER || v3 !== mathfloor(v3))) {
        throw Error(tooManyDigits + x2.s * v3);
      }
      if ((e4 = e4 - i - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e4 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e4;
        x2.c = [];
        i = (e4 + 1) % LOG_BASE;
        if (e4 < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x2.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x2.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v3;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v3 = obj[p];
          intCheck(v3, 0, MAX, p);
          DECIMAL_PLACES = v3;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v3 = obj[p];
          intCheck(v3, 0, 8, p);
          ROUNDING_MODE = v3;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v3 = obj[p];
          if (v3 && v3.pop) {
            intCheck(v3[0], -MAX, 0, p);
            intCheck(v3[1], 0, MAX, p);
            TO_EXP_NEG = v3[0];
            TO_EXP_POS = v3[1];
          } else {
            intCheck(v3, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v3 < 0 ? -v3 : v3);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v3 = obj[p];
          if (v3 && v3.pop) {
            intCheck(v3[0], -MAX, -1, p);
            intCheck(v3[1], 1, MAX, p);
            MIN_EXP = v3[0];
            MAX_EXP = v3[1];
          } else {
            intCheck(v3, -MAX, MAX, p);
            if (v3) {
              MIN_EXP = -(MAX_EXP = v3 < 0 ? -v3 : v3);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v3);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v3 = obj[p];
          if (v3 === !!v3) {
            if (v3) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v3;
              } else {
                CRYPTO = !v3;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v3;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v3);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v3 = obj[p];
          intCheck(v3, 0, 9, p);
          MODULO_MODE = v3;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v3 = obj[p];
          intCheck(v3, 0, MAX, p);
          POW_PRECISION = v3;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v3 = obj[p];
          if (typeof v3 == "object")
            FORMAT = v3;
          else
            throw Error(bignumberError + p + " not an object: " + v3);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v3 = obj[p];
          if (typeof v3 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v3)) {
            alphabetHasNormalDecimalDigits = v3.slice(0, 10) == "0123456789";
            ALPHABET = v3;
          } else {
            throw Error(bignumberError + p + " invalid: " + v3);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v3) {
    if (!v3 || v3._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c3 = v3.c, e4 = v3.e, s = v3.s;
    out:
      if ({}.toString.call(c3) == "[object Array]") {
        if ((s === 1 || s === -1) && e4 >= -MAX && e4 <= MAX && e4 === mathfloor(e4)) {
          if (c3[0] === 0) {
            if (e4 === 0 && c3.length === 1)
              return true;
            break out;
          }
          i = (e4 + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c3[0]).length == i) {
            for (i = 0; i < c3.length; i++) {
              n = c3[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c3 === null && e4 === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v3);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b3, e4, k3, v3, i = 0, c3 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k3 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k3 *= 2));
          for (; i < k3; ) {
            v3 = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v3 >= 9e15) {
              b3 = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b3[0];
              a[i + 1] = b3[1];
            } else {
              c3.push(v3 % 1e14);
              i += 2;
            }
          }
          i = k3 / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k3 *= 7);
          for (; i < k3; ) {
            v3 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v3 >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c3.push(v3 % 1e14);
              i += 7;
            }
          }
          i = k3 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k3; ) {
          v3 = random53bitInt();
          if (v3 < 9e15)
            c3[i++] = v3 % 1e14;
        }
      }
      k3 = c3[--i];
      dp %= LOG_BASE;
      if (k3 && dp) {
        v3 = POWS_TEN[LOG_BASE - dp];
        c3[i] = mathfloor(k3 / v3) * v3;
      }
      for (; c3[i] === 0; c3.pop(), i--)
        ;
      if (i < 0) {
        c3 = [e4 = 0];
      } else {
        for (e4 = -1; c3[0] === 0; c3.splice(0, 1), e4 -= LOG_BASE)
          ;
        for (i = 1, v3 = c3[0]; v3 >= 10; v3 /= 10, i++)
          ;
        if (i < LOG_BASE)
          e4 -= LOG_BASE - i;
      }
      rand.e = e4;
      rand.c = c3;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j3, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j3 = 0; j3 < arr.length; j3++) {
          if (arr[j3] > baseOut - 1) {
            if (arr[j3 + 1] == null)
              arr[j3 + 1] = 0;
            arr[j3 + 1] += arr[j3] / baseOut | 0;
            arr[j3] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d3, e4, k3, r2, x2, xc, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k3 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y2 = new BigNumber2(baseIn);
        x2 = y2.pow(str.length - i);
        POW_PRECISION = k3;
        y2.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y2.e = y2.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e4 = k3 = xc.length;
      for (; xc[--k3] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e4;
      } else {
        x2.c = xc;
        x2.e = e4;
        x2.s = sign;
        x2 = div(x2, y2, dp, rm, baseOut);
        xc = x2.c;
        r2 = x2.r;
        e4 = x2.e;
      }
      d3 = e4 + dp + 1;
      i = xc[d3];
      k3 = baseOut / 2;
      r2 = r2 || d3 < 0 || xc[d3 + 1] != null;
      r2 = rm < 4 ? (i != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i > k3 || i == k3 && (rm == 4 || r2 || rm == 6 && xc[d3 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d3 < 1 || !xc[0]) {
        str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d3;
        if (r2) {
          for (--baseOut; ++xc[--d3] > baseOut; ) {
            xc[d3] = 0;
            if (!d3) {
              ++e4;
              xc = [1].concat(xc);
            }
          }
        }
        for (k3 = xc.length; !xc[--k3]; )
          ;
        for (i = 0, str = ""; i <= k3; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e4, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x2, k3, base) {
      var m3, temp, xlo, xhi, carry = 0, i = x2.length, klo = k3 % SQRT_BASE, khi = k3 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i--; ) {
        xlo = x2[i] % SQRT_BASE;
        xhi = x2[i] / SQRT_BASE | 0;
        m3 = khi * xlo + xhi * klo;
        temp = klo * xlo + m3 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m3 / SQRT_BASE | 0) + khi * xhi;
        x2[i] = temp % base;
      }
      if (carry)
        x2 = [carry].concat(x2);
      return x2;
    }
    function compare3(a, b3, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b3[i]) {
            cmp = a[i] > b3[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b3, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b3[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b3[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x2, y2, dp, rm, base) {
      var cmp, e4, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e4 = x2.e - y2.e;
      s = dp + e4 + 1;
      if (!base) {
        base = BASE;
        e4 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e4--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round(q, dp + (q.e = i + e4 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e4;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e4, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e4 = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e4 || e4 <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e4);
      } else {
        i -= ne;
        str = toFixedPoint(str, e4, "0");
        if (e4 + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e4 - len;
          if (i > 0) {
            if (e4 + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k3, y2, i = 1, x2 = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y2 = new BigNumber2(args[i]);
      if (!y2.s || (k3 = compare2(x2, y2)) === n || k3 === 0 && x2.s === n) {
        x2 = y2;
      }
    }
    return x2;
  }
  function normalise(n, c3, e4) {
    var i = 1, j3 = c3.length;
    for (; !c3[--j3]; c3.pop())
      ;
    for (j3 = c3[0]; j3 >= 10; j3 /= 10, i++)
      ;
    if ((e4 = i + e4 * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e4 < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e4;
      n.c = c3;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b3) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m3, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b3 || b3 == base ? p1 : m3;
          });
          if (b3) {
            base = b3;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round(x2, sd, rm, r2) {
    var d3, i, j3, k3, n, ni, rd, xc = x2.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d3 = 1, k3 = xc[0]; k3 >= 10; k3 /= 10, d3++)
          ;
        i = sd - d3;
        if (i < 0) {
          i += LOG_BASE;
          j3 = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d3 - j3 - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r2) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d3 = 1;
              i %= LOG_BASE;
              j3 = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k3 = xc[ni];
            for (d3 = 1; k3 >= 10; k3 /= 10, d3++)
              ;
            i %= LOG_BASE;
            j3 = i - LOG_BASE + d3;
            rd = j3 < 0 ? 0 : mathfloor(n / pows10[d3 - j3 - 1] % 10);
          }
        }
        r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j3 < 0 ? n : n % pows10[d3 - j3 - 1]);
        r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j3 > 0 ? n / pows10[d3 - j3] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r2) {
            sd -= x2.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc[0] = x2.e = 0;
          }
          return x2;
        }
        if (i == 0) {
          xc.length = ni;
          k3 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k3 = pows10[LOG_BASE - i];
          xc[ni] = j3 > 0 ? mathfloor(n / pows10[d3 - j3] % pows10[j3]) * k3 : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j3 = xc[0]; j3 >= 10; j3 /= 10, i++)
                ;
              j3 = xc[0] += k3;
              for (k3 = 1; j3 >= 10; j3 /= 10, k3++)
                ;
              if (i != k3) {
                x2.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k3;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k3 = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n) {
    var str, e4 = n.e;
    if (e4 === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(str, e4) : toFixedPoint(str, e4, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0)
      x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y2, b3) {
    return compare2(this, new BigNumber2(y2, b3));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c3, n, v3, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c3 = x2.c))
      return null;
    n = ((v3 = c3.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v3 = c3[v3])
      for (; v3 % 10 == 0; v3 /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P2.dividedBy = P2.div = function(y2, b3) {
    return div(this, new BigNumber2(y2, b3), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y2, b3) {
    return div(this, new BigNumber2(y2, b3), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n, m3) {
    var half, isModExp, i, k3, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m3 != null)
      m3 = new BigNumber2(m3);
    nIsBig = n.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
      y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m3 ? y2.mod(m3) : y2;
    }
    nIsNeg = n.s < 0;
    if (m3) {
      if (m3.c ? !m3.c[0] : !m3.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m3.isInteger();
      if (isModExp)
        x2 = x2.mod(m3);
    } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k3 = x2.s < 0 && isOdd(n) ? -0 : 0;
      if (x2.e > -1)
        k3 = 1 / k3;
      return new BigNumber2(nIsNeg ? 1 / k3 : k3);
    } else if (POW_PRECISION) {
      k3 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y2 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y2 = y2.times(x2);
        if (!y2.c)
          break;
        if (k3) {
          if (y2.c.length > k3)
            y2.c.length = k3;
        } else if (isModExp) {
          y2 = y2.mod(m3);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x2 = x2.times(x2);
      if (k3) {
        if (x2.c && x2.c.length > k3)
          x2.c.length = k3;
      } else if (isModExp) {
        x2 = x2.mod(m3);
      }
    }
    if (isModExp)
      return y2;
    if (nIsNeg)
      y2 = ONE.div(y2);
    return m3 ? y2.mod(m3) : k3 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
  };
  P2.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y2, b3) {
    return compare2(this, new BigNumber2(y2, b3)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y2, b3) {
    return compare2(this, new BigNumber2(y2, b3)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b3) {
    return (b3 = compare2(this, new BigNumber2(y2, b3))) === 1 || b3 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y2, b3) {
    return compare2(this, new BigNumber2(y2, b3)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y2, b3) {
    return (b3 = compare2(this, new BigNumber2(y2, b3))) === -1 || b3 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y2, b3) {
    var i, j3, t, xLTy, x2 = this, a = x2.s;
    y2 = new BigNumber2(y2, b3);
    b3 = y2.s;
    if (!a || !b3)
      return new BigNumber2(NaN);
    if (a != b3) {
      y2.s = -b3;
      return x2.plus(y2);
    }
    var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
    if (!xe2 || !ye2) {
      if (!xc || !yc)
        return xc ? (y2.s = -b3, y2) : new BigNumber2(yc ? x2 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y2.s = -b3, y2) : new BigNumber2(xc[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a = xe2 - ye2) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye2 = xe2;
        t = yc;
      }
      t.reverse();
      for (b3 = a; b3--; t.push(0))
        ;
      t.reverse();
    } else {
      j3 = (xLTy = (a = xc.length) < (b3 = yc.length)) ? a : b3;
      for (a = b3 = 0; b3 < j3; b3++) {
        if (xc[b3] != yc[b3]) {
          xLTy = xc[b3] < yc[b3];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y2.s = -y2.s;
    }
    b3 = (j3 = yc.length) - (i = xc.length);
    if (b3 > 0)
      for (; b3--; xc[i++] = 0)
        ;
    b3 = BASE - 1;
    for (; j3 > a; ) {
      if (xc[--j3] < yc[j3]) {
        for (i = j3; i && !xc[--i]; xc[i] = b3)
          ;
        --xc[i];
        xc[j3] += BASE;
      }
      xc[j3] -= yc[j3];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye2)
      ;
    if (!xc[0]) {
      y2.s = ROUNDING_MODE == 3 ? -1 : 1;
      y2.c = [y2.e = 0];
      return y2;
    }
    return normalise(y2, xc, ye2);
  };
  P2.modulo = P2.mod = function(y2, b3) {
    var q, s, x2 = this;
    y2 = new BigNumber2(y2, b3);
    if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y2.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s = y2.s;
      y2.s = 1;
      q = div(x2, y2, 0, 3);
      y2.s = s;
      q.s *= s;
    } else {
      q = div(x2, y2, 0, MODULO_MODE);
    }
    y2 = x2.minus(q.times(y2));
    if (!y2.c[0] && MODULO_MODE == 1)
      y2.s = x2.s;
    return y2;
  };
  P2.multipliedBy = P2.times = function(y2, b3) {
    var c3, e4, i, j3, k3, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b3)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y2.c = y2.e = y2.s = null;
      } else {
        y2.s *= x2.s;
        if (!xc || !yc) {
          y2.c = y2.e = null;
        } else {
          y2.c = [0];
          y2.e = 0;
        }
      }
      return y2;
    }
    e4 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
    y2.s *= x2.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c3 = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k3 = xcL, j3 = i + k3; j3 > i; ) {
        xlo = xc[--k3] % sqrtBase;
        xhi = xc[k3] / sqrtBase | 0;
        m3 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j3] + c3;
        c3 = (xlo / base | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
        zc[j3--] = xlo % base;
      }
      zc[j3] = c3;
    }
    if (c3) {
      ++e4;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y2, zc, e4);
  };
  P2.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y2, b3) {
    var t, x2 = this, a = x2.s;
    y2 = new BigNumber2(y2, b3);
    b3 = y2.s;
    if (!a || !b3)
      return new BigNumber2(NaN);
    if (a != b3) {
      y2.s = -b3;
      return x2.minus(y2);
    }
    var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
    if (!xe2 || !ye2) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a * 0);
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a = xe2 - ye2) {
      if (a > 0) {
        ye2 = xe2;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b3 = yc.length;
    if (a - b3 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b3 = a;
    }
    for (a = 0; b3; ) {
      a = (xc[--b3] = xc[b3] + yc[b3] + a) / BASE | 0;
      xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye2;
    }
    return normalise(y2, xc, ye2);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c3, n, v3, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), sd, rm);
    }
    if (!(c3 = x2.c))
      return null;
    v3 = c3.length - 1;
    n = v3 * LOG_BASE + 1;
    if (v3 = c3[v3]) {
      for (; v3 % 10 == 0; v3 /= 10, n--)
        ;
      for (v3 = c3[0]; v3 >= 10; v3 /= 10, n++)
        ;
    }
    if (sd && x2.e + 1 > n)
      n = x2.e + 1;
    return n;
  };
  P2.shiftedBy = function(k3) {
    intCheck(k3, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k3);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m3, n, r2, rep, t, x2 = this, c3 = x2.c, s = x2.s, e4 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c3 || !c3[0]) {
      return new BigNumber2(!s || s < 0 && (!c3 || c3[0]) ? NaN : c3 ? x2 : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x2));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c3);
      if ((n.length + e4) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e4 = bitFloor((e4 + 1) / 2) - (e4 < 0 || e4 % 2);
      if (s == 1 / 0) {
        n = "5e" + e4;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e4;
      }
      r2 = new BigNumber2(n);
    } else {
      r2 = new BigNumber2(s + "");
    }
    if (r2.c[0]) {
      e4 = r2.e;
      s = e4 + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r2;
        r2 = half.times(t.plus(div(x2, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r2.c)).slice(0, s)) {
          if (r2.e < e4)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x2)) {
                r2 = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m3 = !r2.times(r2).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d3, d0, d1, d22, e4, exp, n, n0, n1, q, r2, s, x2 = this, xc = x2.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x2);
    d3 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e4 = d3.e = s.length - x2.e - 1;
    d3.c[0] = POWS_TEN[(exp = e4 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d3) > 0 ? e4 > 0 ? d3 : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d3, 0, 1);
      d22 = d0.plus(q.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d3 = n.minus(q.times(d22 = d3));
      n = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e4 = e4 * 2;
    r2 = div(n1, d1, e4, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e4, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b3) {
    var str, n = this, s = n.s, e4 = n.e;
    if (e4 === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b3 == null) {
        str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e4) : toFixedPoint(coeffToString(n.c), e4, "0");
      } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e4 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b3, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e4, "0"), 10, b3, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z2, i = 1, j3 = a.length, r2 = a[0] + "";
  for (; i < j3; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s)
      ;
    r2 += s;
  }
  for (j3 = r2.length; r2.charCodeAt(--j3) === 48; )
    ;
  return r2.slice(0, j3 + 1 || 1);
}
function compare2(x2, y2) {
  var a, b3, xc = x2.c, yc = y2.c, i = x2.s, j3 = y2.s, k3 = x2.e, l = y2.e;
  if (!i || !j3)
    return null;
  a = xc && !xc[0];
  b3 = yc && !yc[0];
  if (a || b3)
    return a ? b3 ? 0 : -j3 : i;
  if (i != j3)
    return i;
  a = i < 0;
  b3 = k3 == l;
  if (!xc || !yc)
    return b3 ? 0 : !xc ^ a ? 1 : -1;
  if (!b3)
    return k3 > l ^ a ? 1 : -1;
  j3 = (k3 = xc.length) < (l = yc.length) ? k3 : l;
  for (i = 0; i < j3; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k3 == l ? 0 : k3 > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k3 = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k3 && n.c[k3] % 2 != 0;
}
function toExponential(str, e4) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e4 < 0 ? "e" : "e+") + e4;
}
function toFixedPoint(str, e4, z2) {
  var len, zs;
  if (e4 < 0) {
    for (zs = z2 + "."; ++e4; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e4 > len) {
      for (zs = z2, e4 -= len; --e4; zs += z2)
        ;
      str += zs;
    } else if (e4 < len) {
      str = str.slice(0, e4) + "." + str.slice(e4);
    }
  }
  return str;
}
var BigNumber = clone();

// ../../node_modules/@slide-computer/signer-agent/lib/esm/utils.js
var decodeCallRequest = (contentMap) => {
  const decoded = cbor_exports.decode(contentMap);
  const expiry = new Expiry(0);
  expiry._value = BigInt(decoded.ingress_expiry.toString(10));
  return Object.assign(Object.assign({}, decoded), { canister_id: Principal.from(decoded.canister_id), ingress_expiry: expiry });
};

// ../../node_modules/@slide-computer/signer-agent/lib/esm/queue.js
var __classPrivateFieldGet5 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet5 = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var _Queue_ongoing;
var Queue = class {
  constructor() {
    _Queue_ongoing.set(this, Promise.resolve());
  }
  async schedule(job) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet5(this, _Queue_ongoing, __classPrivateFieldGet5(this, _Queue_ongoing, "f").finally(async () => {
        try {
          resolve(await job());
        } catch (error) {
          reject(error);
        }
      }), "f");
    });
  }
};
_Queue_ongoing = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@slide-computer/signer-agent/lib/esm/agent.js
var __classPrivateFieldGet6 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet6 = function(receiver, state, value2, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
};
var _SignerAgent_instances;
var _a;
var _SignerAgent_isInternalConstructing;
var _SignerAgent_options;
var _SignerAgent_certificates;
var _SignerAgent_queue;
var _SignerAgent_executeTimeout;
var _SignerAgent_scheduled;
var _SignerAgent_autoBatch;
var _SignerAgent_validation;
var _SignerAgent_executeQueue;
var _SignerAgent_executeBatch;
var ROOT_KEY = new Uint8Array(IC_ROOT_KEY.match(/[\da-f]{2}/gi).map((h4) => parseInt(h4, 16))).buffer;
var MAX_AGE_IN_MINUTES = 5;
var INVALID_RESPONSE_MESSAGE = "Received invalid response from signer";
var SignerAgentError = class _SignerAgentError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _SignerAgentError.prototype);
  }
};
var SignerAgent = class {
  constructor(options) {
    _SignerAgent_instances.add(this);
    _SignerAgent_options.set(this, void 0);
    _SignerAgent_certificates.set(this, /* @__PURE__ */ new Map());
    _SignerAgent_queue.set(this, new Queue());
    _SignerAgent_executeTimeout.set(this, void 0);
    _SignerAgent_scheduled.set(this, [[]]);
    _SignerAgent_autoBatch.set(this, true);
    _SignerAgent_validation.set(this, void 0);
    const throwError = !__classPrivateFieldGet6(_a, _a, "f", _SignerAgent_isInternalConstructing);
    __classPrivateFieldSet6(_a, _a, false, "f", _SignerAgent_isInternalConstructing);
    if (throwError) {
      throw new SignerAgentError("SignerAgent is not constructable");
    }
    __classPrivateFieldSet6(this, _SignerAgent_options, options, "f");
  }
  get rootKey() {
    var _b;
    return (_b = __classPrivateFieldGet6(this, _SignerAgent_options, "f").agent.rootKey) !== null && _b !== void 0 ? _b : ROOT_KEY;
  }
  get signer() {
    return __classPrivateFieldGet6(this, _SignerAgent_options, "f").signer;
  }
  static async create(options) {
    var _b, _c, _d;
    __classPrivateFieldSet6(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
    return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : await HttpAgent.create(), scheduleDelay: (_c = options.scheduleDelay) !== null && _c !== void 0 ? _c : 20, validation: (_d = options.validation) !== null && _d !== void 0 ? _d : null }));
  }
  static createSync(options) {
    var _b, _c, _d;
    __classPrivateFieldSet6(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
    return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : HttpAgent.createSync(), scheduleDelay: (_c = options.scheduleDelay) !== null && _c !== void 0 ? _c : 20, validation: (_d = options.validation) !== null && _d !== void 0 ? _d : null }));
  }
  async execute() {
    const scheduled = [...__classPrivateFieldGet6(this, _SignerAgent_scheduled, "f")];
    const validation = __classPrivateFieldGet6(this, _SignerAgent_validation, "f");
    this.clear();
    const pending = scheduled.flat().length;
    if (pending === 0) {
      __classPrivateFieldSet6(this, _SignerAgent_validation, void 0, "f");
      return;
    }
    const needsBatch = pending > 1;
    if (!needsBatch) {
      await __classPrivateFieldGet6(this, _SignerAgent_instances, "m", _SignerAgent_executeQueue).call(this, scheduled);
      return;
    }
    const supportedStandards = await __classPrivateFieldGet6(this, _SignerAgent_queue, "f").schedule(() => this.signer.supportedStandards());
    const supportsBatch = supportedStandards.some((supportedStandard) => supportedStandard.name === "ICRC-112");
    if (supportsBatch) {
      await __classPrivateFieldGet6(this, _SignerAgent_instances, "m", _SignerAgent_executeBatch).call(this, scheduled, validation);
    } else {
      await __classPrivateFieldGet6(this, _SignerAgent_instances, "m", _SignerAgent_executeQueue).call(this, scheduled);
    }
  }
  async call(canisterId, options) {
    canisterId = Principal.from(canisterId);
    await __classPrivateFieldGet6(this, _SignerAgent_options, "f").signer.openChannel();
    const response = await new Promise((resolve, reject) => {
      clearTimeout(__classPrivateFieldGet6(this, _SignerAgent_executeTimeout, "f"));
      __classPrivateFieldGet6(this, _SignerAgent_scheduled, "f").slice(-1)[0].push({
        options: {
          canisterId,
          method: options.methodName,
          arg: options.arg
        },
        resolve,
        reject
      });
      if (__classPrivateFieldGet6(this, _SignerAgent_autoBatch, "f")) {
        __classPrivateFieldSet6(this, _SignerAgent_executeTimeout, setTimeout(() => this.execute(), __classPrivateFieldGet6(this, _SignerAgent_options, "f").scheduleDelay), "f");
      }
    });
    const requestBody = decodeCallRequest(response.contentMap);
    const contentMapMatchesRequest = SubmitRequestType.Call === requestBody.request_type && canisterId.compareTo(requestBody.canister_id) === "eq" && options.methodName === requestBody.method_name && compare(options.arg, requestBody.arg) === 0 && __classPrivateFieldGet6(this, _SignerAgent_options, "f").account.compareTo(Principal.from(requestBody.sender)) === "eq";
    if (!contentMapMatchesRequest) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const requestId = requestIdOf(requestBody);
    const certificate = await Certificate.create({
      certificate: response.certificate,
      rootKey: this.rootKey,
      canisterId,
      maxAgeInMinutes: MAX_AGE_IN_MINUTES
    }).catch(() => {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    });
    const certificateIsResponseToContentMap = certificate.lookup(["request_status", requestId, "status"]).status === LookupStatus.Found;
    if (!certificateIsResponseToContentMap) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const requestKey = toBase64(requestId);
    if (__classPrivateFieldGet6(this, _SignerAgent_certificates, "f").has(requestKey)) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    __classPrivateFieldGet6(this, _SignerAgent_certificates, "f").set(requestKey, response.certificate);
    const now = Date.now();
    const lookupTime = lookupResultToBuffer(certificate.lookup(["time"]));
    if (!lookupTime) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const certificateTime = Number(lebDecode(new PipeArrayBuffer(lookupTime))) / 1e6;
    const expiry = certificateTime - now + MAX_AGE_IN_MINUTES * 60 * 1e3;
    setTimeout(() => __classPrivateFieldGet6(this, _SignerAgent_certificates, "f").delete(requestKey), expiry);
    return {
      requestId,
      response: {
        ok: true,
        status: 202,
        statusText: "Call has been sent over ICRC-25 JSON-RPC",
        body: null,
        headers: []
      }
    };
  }
  async fetchRootKey() {
    return __classPrivateFieldGet6(this, _SignerAgent_options, "f").agent.fetchRootKey();
  }
  async getPrincipal() {
    return __classPrivateFieldGet6(this, _SignerAgent_options, "f").account;
  }
  async query(canisterId, options) {
    canisterId = Principal.from(canisterId);
    const submitResponse = await this.call(canisterId, options);
    const readStateResponse = await this.readState(canisterId, {
      paths: [
        [new TextEncoder().encode("request_status"), submitResponse.requestId]
      ]
    });
    const certificate = await Certificate.create({
      certificate: readStateResponse.certificate,
      rootKey: this.rootKey,
      canisterId
    });
    const status = certificate.lookup([
      "request_status",
      submitResponse.requestId,
      "status"
    ]);
    const reply = certificate.lookup([
      "request_status",
      submitResponse.requestId,
      "reply"
    ]);
    if (status.status !== LookupStatus.Found || new TextDecoder().decode(status.value) !== "replied" || reply.status !== LookupStatus.Found) {
      throw new SignerAgentError("Certificate is missing reply");
    }
    return {
      requestId: submitResponse.requestId,
      status: "replied",
      reply: {
        arg: reply.value
      },
      httpDetails: {
        ok: true,
        status: 202,
        statusText: "Certificate with reply has been received over ICRC-25 JSON-RPC",
        headers: []
      }
    };
  }
  async createReadStateRequest(_options) {
    return {
      body: {
        content: {}
      }
    };
  }
  async readState(_canisterId, options, _identity, _request) {
    if (options.paths.length !== 1 || options.paths[0].length !== 2 || new TextDecoder().decode(options.paths[0][0]) !== "request_status") {
      throw new SignerAgentError("Given paths are not supported");
    }
    const requestId = options.paths[0][1];
    const key = toBase64(requestId);
    const certificate = __classPrivateFieldGet6(this, _SignerAgent_certificates, "f").get(key);
    if (!certificate) {
      throw new SignerAgentError("Certificate could not be found");
    }
    return { certificate };
  }
  async status() {
    return __classPrivateFieldGet6(this, _SignerAgent_options, "f").agent.status();
  }
  replaceAccount(account) {
    __classPrivateFieldGet6(this, _SignerAgent_options, "f").account = account;
  }
  replaceValidation(validation) {
    __classPrivateFieldSet6(this, _SignerAgent_validation, validation, "f");
  }
  /**
   * Enable manual triggering of canister calls execution
   */
  batch() {
    __classPrivateFieldSet6(this, _SignerAgent_autoBatch, false, "f");
    if (__classPrivateFieldGet6(this, _SignerAgent_scheduled, "f").slice(-1)[0].length > 0) {
      __classPrivateFieldGet6(this, _SignerAgent_scheduled, "f").push([]);
    }
  }
  /**
   * Clear scheduled canister calls and switch back to automatic canister calls execution
   */
  clear() {
    __classPrivateFieldSet6(this, _SignerAgent_scheduled, [[]], "f");
    __classPrivateFieldSet6(this, _SignerAgent_autoBatch, true, "f");
  }
};
_a = SignerAgent, _SignerAgent_options = /* @__PURE__ */ new WeakMap(), _SignerAgent_certificates = /* @__PURE__ */ new WeakMap(), _SignerAgent_queue = /* @__PURE__ */ new WeakMap(), _SignerAgent_executeTimeout = /* @__PURE__ */ new WeakMap(), _SignerAgent_scheduled = /* @__PURE__ */ new WeakMap(), _SignerAgent_autoBatch = /* @__PURE__ */ new WeakMap(), _SignerAgent_validation = /* @__PURE__ */ new WeakMap(), _SignerAgent_instances = /* @__PURE__ */ new WeakSet(), _SignerAgent_executeQueue = async function _SignerAgent_executeQueue2(scheduled) {
  await Promise.all(scheduled.flat().map(({ options, resolve, reject }) => __classPrivateFieldGet6(this, _SignerAgent_queue, "f").schedule(async () => {
    try {
      const response = await this.signer.callCanister(Object.assign({ sender: __classPrivateFieldGet6(this, _SignerAgent_options, "f").account }, options));
      resolve(response);
    } catch (error) {
      reject(error);
    }
  })));
}, _SignerAgent_executeBatch = async function _SignerAgent_executeBatch2(scheduled, validation) {
  await __classPrivateFieldGet6(this, _SignerAgent_queue, "f").schedule(async () => {
    try {
      const responses = await this.signer.batchCallCanister({
        sender: __classPrivateFieldGet6(this, _SignerAgent_options, "f").account,
        requests: scheduled.map((entries) => entries.map(({ options }) => options)),
        validation: validation !== null && validation !== void 0 ? validation : void 0
      });
      scheduled.forEach((entries, sequenceIndex) => entries.forEach(({ resolve, reject }, requestIndex) => {
        const response = responses[sequenceIndex][requestIndex];
        if ("result" in response) {
          resolve(response.result);
          return;
        }
        if ("error" in response) {
          reject(new SignerAgentError(`${response.error.code}: ${response.error.message}
${JSON.stringify(response.error.data)}`));
          return;
        }
        reject(new SignerAgentError(INVALID_RESPONSE_MESSAGE));
      }));
    } catch (error) {
      scheduled.flat().forEach(({ reject }) => reject(error));
    }
  });
};
_SignerAgent_isInternalConstructing = { value: false };

// ../../node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value2, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}

// ../../node_modules/@slide-computer/signer-storage/lib/esm/storage.js
var IdbStorage = class {
  get store() {
    if (!this._store) {
      this._store = createStore("signer-db", "signer-store");
    }
    return this._store;
  }
  async get(key) {
    return get(key, this.store);
  }
  async set(key, value2) {
    return set(key, value2, this.store);
  }
  async remove(key) {
    return del(key, this.store);
  }
};

// ../../node_modules/@slide-computer/signer-storage/lib/esm/identity.js
var getIdentity = async (key, storage) => {
  const value2 = await storage.get(`identity-${key}`);
  if (!value2) {
    return;
  }
  return typeof value2 === "string" ? Ed25519KeyIdentity.fromJSON(value2) : ECDSAKeyIdentity.fromKeyPair(value2);
};
var setIdentity = async (key, identity, storage) => {
  const value2 = identity instanceof Ed25519KeyIdentity ? JSON.stringify(identity.toJSON()) : identity.getKeyPair();
  return storage.set(`identity-${key}`, value2);
};
var removeIdentity = async (key, storage) => {
  return storage.remove(`identity-${key}`);
};

// ../../node_modules/@slide-computer/signer-storage/lib/esm/delegation.js
var getDelegationChain = async (key, storage) => {
  const json = await storage.get(`delegation-${key}`);
  if (!json || typeof json !== "string") {
    return;
  }
  return DelegationChain.fromJSON(json);
};
var setDelegationChain = async (key, delegationChain, storage) => {
  return storage.set(`delegation-${key}`, JSON.stringify(delegationChain.toJSON()));
};
var removeDelegationChain = async (key, storage) => {
  return storage.remove(`delegation-${key}`);
};

// ../../node_modules/@dfinity/utils/dist/esm/index.js
init_esm();
var T = ((n) => (n[n.FractionalMoreThan8Decimals = 0] = "FractionalMoreThan8Decimals", n[n.InvalidFormat = 1] = "InvalidFormat", n[n.FractionalTooManyDecimals = 2] = "FractionalTooManyDecimals", n))(T || {});
var h = BigInt(1e8);
var U = class {
  constructor(t, r2, n) {
    this.id = t;
    this.service = r2;
    this.certifiedService = n;
    this.caller = ({ certified: t2 = true }) => t2 ? this.certifiedService : this.service;
  }
  get canisterId() {
    return this.id;
  }
};
var b = (e4) => e4 == null;
var c = (e4) => !b(e4);
var w = () => HttpAgent.createSync({ host: "https://icp-api.io", identity: new AnonymousIdentity() });
var ct = ({ options: { canisterId: e4, serviceOverride: t, certifiedServiceOverride: r2, agent: n, callTransform: i, queryTransform: o }, idlFactory: s, certifiedIdlFactory: a }) => {
  let l = n ?? w(), C2 = t ?? Actor.createActor(s, { agent: l, canisterId: e4, callTransform: i, queryTransform: o }), M2 = r2 ?? Actor.createActor(a, { agent: l, canisterId: e4, callTransform: i, queryTransform: o });
  return { service: C2, certifiedService: M2, agent: l, canisterId: e4 };
};
var yt = (e4) => new Uint8Array(e4);
var At = (e4) => Array.from(e4).map((t) => t.charCodeAt(0));
var ht = (e4) => (e4 instanceof Uint8Array || (e4 = Uint8Array.from(e4)), e4.reduce((t, r2) => t + r2.toString(16).padStart(2, "0"), ""));
var u = "abcdefghijklmnopqrstuvwxyz234567";
var d = /* @__PURE__ */ Object.create(null);
for (let e4 = 0; e4 < u.length; e4++)
  d[u[e4]] = e4;
d[0] = d.o;
d[1] = d.i;
var H = new Uint32Array([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]);
var $ = (e4) => {
  let t = -1;
  for (let r2 = 0; r2 < e4.length; r2++) {
    let i = (e4[r2] ^ t) & 255;
    t = H[i] ^ t >>> 8;
  }
  return (t ^ -1) >>> 0;
};
var Ot = (e4) => {
  let t = new ArrayBuffer(4);
  return new DataView(t).setUint32(0, $(e4), false), new Uint8Array(t);
};
var Yt = (e4) => c(e4) ? [e4] : [];

// ../../node_modules/@dfinity/ledger-icp/dist/esm/chunk-D2JQPN4X.js
var N = Object.create;
var H2 = Object.defineProperty;
var F = Object.getOwnPropertyDescriptor;
var j = Object.getOwnPropertyNames;
var V = Object.getPrototypeOf;
var G = Object.prototype.hasOwnProperty;
var z = (e4, t) => () => (t || e4((t = { exports: {} }).exports, t), t.exports);
var v = (e4, t, n, r2) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of j(t))
      !G.call(e4, o) && o !== n && H2(e4, o, { get: () => t[o], enumerable: !(r2 = F(t, o)) || r2.enumerable });
  return e4;
};
var J = (e4, t, n) => (n = e4 != null ? N(V(e4)) : {}, v(t || !e4 || !e4.__esModule ? H2(n, "default", { value: e4, enumerable: true }) : n, e4));
function W(e4) {
  return e4 instanceof Uint8Array || e4 != null && typeof e4 == "object" && e4.constructor.name === "Uint8Array";
}
function A(e4, ...t) {
  if (!W(e4))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e4.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e4.length}`);
}
function U2(e4, t = true) {
  if (e4.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e4.finished)
    throw new Error("Hash#digest() has already been called");
}
function S(e4, t) {
  A(e4);
  let n = t.outputLen;
  if (e4.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
var g = (e4) => new DataView(e4.buffer, e4.byteOffset, e4.byteLength);
var h2 = (e4, t) => e4 << 32 - t | e4 >>> t;
var tt = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function $2(e4) {
  if (typeof e4 != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e4}`);
  return new Uint8Array(new TextEncoder().encode(e4));
}
function B(e4) {
  return typeof e4 == "string" && (e4 = $2(e4)), A(e4), e4;
}
var d2 = class {
  clone() {
    return this._cloneInto();
  }
};
var et = {}.toString;
function T2(e4) {
  let t = (r2) => e4().update(B(r2)).digest(), n = e4();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e4(), t;
}
function M(e4, t, n, r2) {
  if (typeof e4.setBigUint64 == "function")
    return e4.setBigUint64(t, n, r2);
  let o = BigInt(32), c3 = BigInt(4294967295), i = Number(n >> o & c3), s = Number(n & c3), u2 = r2 ? 4 : 0, a = r2 ? 0 : 4;
  e4.setUint32(t + u2, i, r2), e4.setUint32(t + a, s, r2);
}
var C = (e4, t, n) => e4 & t ^ ~e4 & n;
var k = (e4, t, n) => e4 & t ^ e4 & n ^ t & n;
var w2 = class extends d2 {
  constructor(t, n, r2, o) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r2, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = g(this.buffer);
  }
  update(t) {
    U2(this);
    let { view: n, buffer: r2, blockLen: o } = this;
    t = B(t);
    let c3 = t.length;
    for (let i = 0; i < c3; ) {
      let s = Math.min(o - this.pos, c3 - i);
      if (s === o) {
        let u2 = g(t);
        for (; o <= c3 - i; i += o)
          this.process(u2, i);
        continue;
      }
      r2.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    U2(this), S(t, this), this.finished = true;
    let { buffer: n, view: r2, blockLen: o, isLE: c3 } = this, { pos: i } = this;
    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(r2, 0), i = 0);
    for (let f2 = i; f2 < o; f2++)
      n[f2] = 0;
    M(r2, o - 8, BigInt(this.length * 8), c3), this.process(r2, 0);
    let s = g(t), u2 = this.outputLen;
    if (u2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    let a = u2 / 4, p = this.get();
    if (a > p.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f2 = 0; f2 < a; f2++)
      s.setUint32(4 * f2, p[f2], c3);
  }
  digest() {
    let { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    let r2 = t.slice(0, n);
    return this.destroy(), r2;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    let { blockLen: n, buffer: r2, length: o, finished: c3, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = c3, t.destroyed = i, o % n && t.buffer.set(r2), t;
  }
};
var P = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var x = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var b2 = new Uint32Array(64);
var E = class extends w2 {
  constructor() {
    super(64, 32, 8, false), this.A = x[0] | 0, this.B = x[1] | 0, this.C = x[2] | 0, this.D = x[3] | 0, this.E = x[4] | 0, this.F = x[5] | 0, this.G = x[6] | 0, this.H = x[7] | 0;
  }
  get() {
    let { A: t, B: n, C: r2, D: o, E: c3, F: i, G: s, H: u2 } = this;
    return [t, n, r2, o, c3, i, s, u2];
  }
  set(t, n, r2, o, c3, i, s, u2) {
    this.A = t | 0, this.B = n | 0, this.C = r2 | 0, this.D = o | 0, this.E = c3 | 0, this.F = i | 0, this.G = s | 0, this.H = u2 | 0;
  }
  process(t, n) {
    for (let f2 = 0; f2 < 16; f2++, n += 4)
      b2[f2] = t.getUint32(n, false);
    for (let f2 = 16; f2 < 64; f2++) {
      let y2 = b2[f2 - 15], l = b2[f2 - 2], I = h2(y2, 7) ^ h2(y2, 18) ^ y2 >>> 3, m3 = h2(l, 17) ^ h2(l, 19) ^ l >>> 10;
      b2[f2] = m3 + b2[f2 - 7] + I + b2[f2 - 16] | 0;
    }
    let { A: r2, B: o, C: c3, D: i, E: s, F: u2, G: a, H: p } = this;
    for (let f2 = 0; f2 < 64; f2++) {
      let y2 = h2(s, 6) ^ h2(s, 11) ^ h2(s, 25), l = p + y2 + C(s, u2, a) + P[f2] + b2[f2] | 0, m3 = (h2(r2, 2) ^ h2(r2, 13) ^ h2(r2, 22)) + k(r2, o, c3) | 0;
      p = a, a = u2, u2 = s, s = i + l | 0, i = c3, c3 = o, o = r2, r2 = l + m3 | 0;
    }
    r2 = r2 + this.A | 0, o = o + this.B | 0, c3 = c3 + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u2 = u2 + this.F | 0, a = a + this.G | 0, p = p + this.H | 0, this.set(r2, o, c3, i, s, u2, a, p);
  }
  roundClean() {
    b2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var L = class extends E {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var O = T2(() => new L());
var D = class e {
  constructor(t) {
    this.bytes = t;
  }
  static fromHex(t) {
    return new e(Uint8Array.from(Buffer.from(t, "hex")));
  }
  static fromPrincipal({ principal: t, subAccount: n = _.fromID(0) }) {
    let r2 = At(`
account-id`), o = O.create();
    o.update(yt([...r2, ...t.toUint8Array(), ...n.toUint8Array()]));
    let c3 = o.digest(), i = Ot(c3), s = new Uint8Array([...i, ...c3]);
    return new e(s);
  }
  toHex() {
    return ht(this.bytes);
  }
  toUint8Array() {
    return this.bytes;
  }
  toNumbers() {
    return Array.from(this.bytes);
  }
  toAccountIdentifierHash() {
    return { hash: this.toUint8Array() };
  }
};
var _ = class e2 {
  constructor(t) {
    this.bytes = t;
  }
  static fromBytes(t) {
    return t.length != 32 ? Error("Subaccount length must be 32-bytes") : new e2(t);
  }
  static fromPrincipal(t) {
    let n = new Uint8Array(32).fill(0), r2 = t.toUint8Array();
    n[0] = r2.length;
    for (let o = 0; o < r2.length; o++)
      n[1 + o] = r2[o];
    return new e2(n);
  }
  static fromID(t) {
    if (t < 0)
      throw new Error("Number cannot be negative");
    if (t > Number.MAX_SAFE_INTEGER)
      throw new Error("Number is too large to fit in 32 bytes.");
    let n = new DataView(new ArrayBuffer(32));
    if (typeof n.setBigUint64 == "function")
      n.setBigUint64(24, BigInt(t));
    else {
      let o = BigInt(1) << BigInt(32);
      n.setUint32(24, Number(BigInt(t) >> BigInt(32))), n.setUint32(28, Number(BigInt(t) % o));
    }
    let r2 = new Uint8Array(n.buffer);
    return new e2(r2);
  }
  toUint8Array() {
    return this.bytes;
  }
};

// ../../node_modules/@dfinity/ledger-icp/dist/esm/chunk-CQ4GZJ2C.js
init_esm();
var r = Principal.fromText("ryjl3-tyaaa-aaaaa-aaaba-cai");
var c2 = Principal.fromText("qhbym-qaaaa-aaaaa-aaafq-cai");
var f = (t) => t instanceof D ? t : D.fromHex(t);

// ../../node_modules/@dfinity/ledger-icp/dist/esm/chunk-W2HWVSWO.js
var he = ({ IDL: e4 }) => {
  let o = e4.Vec(e4.Nat8), t = e4.Record({ owner: e4.Principal, subaccount: e4.Opt(o) }), a = e4.Record({ icrc2: e4.Bool }), n = e4.Record({ icrc1_minting_account: e4.Opt(t), feature_flags: e4.Opt(a) }), c3 = e4.Record({ e8s: e4.Nat64 }), _2 = e4.Text, T3 = e4.Record({ secs: e4.Nat64, nanos: e4.Nat32 }), q = e4.Record({ num_blocks_to_archive: e4.Nat64, max_transactions_per_response: e4.Opt(e4.Nat64), trigger_threshold: e4.Nat64, more_controller_ids: e4.Opt(e4.Vec(e4.Principal)), max_message_size_bytes: e4.Opt(e4.Nat64), cycles_for_archive_creation: e4.Opt(e4.Nat64), node_max_memory_size_bytes: e4.Opt(e4.Nat64), controller_id: e4.Principal }), C2 = e4.Record({ send_whitelist: e4.Vec(e4.Principal), token_symbol: e4.Opt(e4.Text), transfer_fee: e4.Opt(c3), minting_account: _2, transaction_window: e4.Opt(T3), max_message_size_bytes: e4.Opt(e4.Nat64), icrc1_minting_account: e4.Opt(t), archive_options: e4.Opt(q), initial_values: e4.Vec(e4.Tuple(_2, c3)), token_name: e4.Opt(e4.Text), feature_flags: e4.Opt(a) }), He = e4.Variant({ Upgrade: e4.Opt(n), Init: C2 }), s = e4.Vec(e4.Nat8), P2 = e4.Record({ account: s }), E2 = e4.Record({ account: _2 }), U3 = e4.Record({ canister_id: e4.Principal }), M2 = e4.Record({ archives: e4.Vec(U3) }), r2 = e4.Nat, S2 = e4.Variant({ Int: e4.Int, Nat: e4.Nat, Blob: e4.Vec(e4.Nat8), Text: e4.Text }), d3 = e4.Nat64, G2 = e4.Record({ to: t, fee: e4.Opt(r2), memo: e4.Opt(e4.Vec(e4.Nat8)), from_subaccount: e4.Opt(o), created_at_time: e4.Opt(d3), amount: r2 }), u2 = e4.Nat, Q = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, BadBurn: e4.Record({ min_burn_amount: r2 }), Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), CreatedInFuture: e4.Record({ ledger_time: e4.Nat64 }), TooOld: e4.Null, InsufficientFunds: e4.Record({ balance: r2 }) }), z2 = e4.Variant({ Ok: u2, Err: Q }), y2 = e4.Record({ utc_offset_minutes: e4.Opt(e4.Int16), language: e4.Text }), H3 = e4.Record({ metadata: y2, device_spec: e4.Opt(e4.Variant({ GenericDisplay: e4.Null, LineDisplay: e4.Record({ characters_per_line: e4.Nat16, lines_per_page: e4.Nat16 }) })) }), J3 = e4.Record({ arg: e4.Vec(e4.Nat8), method: e4.Text, user_preferences: H3 }), $3 = e4.Variant({ LineDisplayMessage: e4.Record({ pages: e4.Vec(e4.Record({ lines: e4.Vec(e4.Text) })) }), GenericDisplayMessage: e4.Text }), K2 = e4.Record({ metadata: y2, consent_message: $3 }), g2 = e4.Record({ description: e4.Text }), Y = e4.Variant({ GenericError: e4.Record({ description: e4.Text, error_code: e4.Nat }), InsufficientPayment: g2, UnsupportedCanisterCall: g2, ConsentMessageUnavailable: g2 }), j3 = e4.Variant({ Ok: K2, Err: Y }), W2 = e4.Record({ account: t, spender: t }), X = e4.Record({ allowance: r2, expires_at: e4.Opt(d3) }), Z = e4.Record({ fee: e4.Opt(r2), memo: e4.Opt(e4.Vec(e4.Nat8)), from_subaccount: e4.Opt(o), created_at_time: e4.Opt(d3), amount: r2, expected_allowance: e4.Opt(r2), expires_at: e4.Opt(d3), spender: t }), I = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), AllowanceChanged: e4.Record({ current_allowance: r2 }), CreatedInFuture: e4.Record({ ledger_time: e4.Nat64 }), TooOld: e4.Null, Expired: e4.Record({ ledger_time: e4.Nat64 }), InsufficientFunds: e4.Record({ balance: r2 }) }), D2 = e4.Variant({ Ok: u2, Err: I }), L2 = e4.Record({ to: t, fee: e4.Opt(r2), spender_subaccount: e4.Opt(o), from: t, memo: e4.Opt(e4.Vec(e4.Nat8)), created_at_time: e4.Opt(d3), amount: r2 }), ee = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, InsufficientAllowance: e4.Record({ allowance: r2 }), BadBurn: e4.Record({ min_burn_amount: r2 }), Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), CreatedInFuture: e4.Record({ ledger_time: d3 }), TooOld: e4.Null, InsufficientFunds: e4.Record({ balance: r2 }) }), te = e4.Variant({ Ok: u2, Err: ee }), i = e4.Nat64, f2 = e4.Record({ start: i, length: e4.Nat64 }), x2 = e4.Nat64, p = e4.Record({ timestamp_nanos: e4.Nat64 }), ce = e4.Variant({ Approve: e4.Record({ fee: c3, from: s, allowance_e8s: e4.Int, allowance: c3, expected_allowance: e4.Opt(c3), expires_at: e4.Opt(p), spender: s }), Burn: e4.Record({ from: s, amount: c3, spender: e4.Opt(s) }), Mint: e4.Record({ to: s, amount: c3 }), Transfer: e4.Record({ to: s, fee: c3, from: s, amount: c3, spender: e4.Opt(e4.Vec(e4.Nat8)) }) }), re = e4.Record({ memo: x2, icrc1_memo: e4.Opt(e4.Vec(e4.Nat8)), operation: e4.Opt(ce), created_at_time: p }), b3 = e4.Record({ transaction: re, timestamp: p, parent_hash: e4.Opt(e4.Vec(e4.Nat8)) }), ne = e4.Record({ blocks: e4.Vec(b3) }), F2 = e4.Variant({ BadFirstBlockIndex: e4.Record({ requested_index: i, first_valid_index: i }), Other: e4.Record({ error_message: e4.Text, error_code: e4.Nat64 }) }), ae = e4.Variant({ Ok: ne, Err: F2 }), oe = e4.Func([f2], [ae], []), se = e4.Record({ callback: oe, start: i, length: e4.Nat64 }), ie = e4.Record({ certificate: e4.Opt(e4.Vec(e4.Nat8)), blocks: e4.Vec(b3), chain_length: e4.Nat64, first_block_index: i, archived_blocks: e4.Vec(se) }), de = e4.Record({ callback: e4.Func([f2], [e4.Variant({ Ok: e4.Vec(e4.Vec(e4.Nat8)), Err: F2 })], []), start: e4.Nat64, length: e4.Nat64 }), ue = e4.Record({ certificate: e4.Opt(e4.Vec(e4.Nat8)), blocks: e4.Vec(e4.Vec(e4.Nat8)), chain_length: e4.Nat64, first_block_index: e4.Nat64, archived_blocks: e4.Vec(de) }), le = e4.Record({ to: _2, fee: c3, memo: x2, from_subaccount: e4.Opt(o), created_at_time: e4.Opt(p), amount: c3 }), _e = e4.Record({ to: s, fee: c3, memo: x2, from_subaccount: e4.Opt(o), created_at_time: e4.Opt(p), amount: c3 }), pe = e4.Variant({ TxTooOld: e4.Record({ allowed_window_nanos: e4.Nat64 }), BadFee: e4.Record({ expected_fee: c3 }), TxDuplicate: e4.Record({ duplicate_of: i }), TxCreatedInFuture: e4.Null, InsufficientFunds: e4.Record({ balance: c3 }) }), me = e4.Variant({ Ok: i, Err: pe }), fe = e4.Record({}), Re = e4.Record({ transfer_fee: c3 });
  return e4.Service({ account_balance: e4.Func([P2], [c3], []), account_balance_dfx: e4.Func([E2], [c3], []), account_identifier: e4.Func([t], [s], []), archives: e4.Func([], [M2], []), decimals: e4.Func([], [e4.Record({ decimals: e4.Nat32 })], []), icrc10_supported_standards: e4.Func([], [e4.Vec(e4.Record({ url: e4.Text, name: e4.Text }))], []), icrc1_balance_of: e4.Func([t], [r2], []), icrc1_decimals: e4.Func([], [e4.Nat8], []), icrc1_fee: e4.Func([], [r2], []), icrc1_metadata: e4.Func([], [e4.Vec(e4.Tuple(e4.Text, S2))], []), icrc1_minting_account: e4.Func([], [e4.Opt(t)], []), icrc1_name: e4.Func([], [e4.Text], []), icrc1_supported_standards: e4.Func([], [e4.Vec(e4.Record({ url: e4.Text, name: e4.Text }))], []), icrc1_symbol: e4.Func([], [e4.Text], []), icrc1_total_supply: e4.Func([], [r2], []), icrc1_transfer: e4.Func([G2], [z2], []), icrc21_canister_call_consent_message: e4.Func([J3], [j3], []), icrc2_allowance: e4.Func([W2], [X], []), icrc2_approve: e4.Func([Z], [D2], []), icrc2_transfer_from: e4.Func([L2], [te], []), is_ledger_ready: e4.Func([], [e4.Bool], []), name: e4.Func([], [e4.Record({ name: e4.Text })], []), query_blocks: e4.Func([f2], [ie], []), query_encoded_blocks: e4.Func([f2], [ue], []), send_dfx: e4.Func([le], [i], []), symbol: e4.Func([], [e4.Record({ symbol: e4.Text })], []), transfer: e4.Func([_e], [me], []), transfer_fee: e4.Func([fe], [Re], []) });
};
var we = ({ IDL: e4 }) => {
  let o = e4.Vec(e4.Nat8), t = e4.Record({ owner: e4.Principal, subaccount: e4.Opt(o) }), a = e4.Record({ icrc2: e4.Bool }), n = e4.Record({ icrc1_minting_account: e4.Opt(t), feature_flags: e4.Opt(a) }), c3 = e4.Record({ e8s: e4.Nat64 }), _2 = e4.Text, T3 = e4.Record({ secs: e4.Nat64, nanos: e4.Nat32 }), q = e4.Record({ num_blocks_to_archive: e4.Nat64, max_transactions_per_response: e4.Opt(e4.Nat64), trigger_threshold: e4.Nat64, more_controller_ids: e4.Opt(e4.Vec(e4.Principal)), max_message_size_bytes: e4.Opt(e4.Nat64), cycles_for_archive_creation: e4.Opt(e4.Nat64), node_max_memory_size_bytes: e4.Opt(e4.Nat64), controller_id: e4.Principal }), C2 = e4.Record({ send_whitelist: e4.Vec(e4.Principal), token_symbol: e4.Opt(e4.Text), transfer_fee: e4.Opt(c3), minting_account: _2, transaction_window: e4.Opt(T3), max_message_size_bytes: e4.Opt(e4.Nat64), icrc1_minting_account: e4.Opt(t), archive_options: e4.Opt(q), initial_values: e4.Vec(e4.Tuple(_2, c3)), token_name: e4.Opt(e4.Text), feature_flags: e4.Opt(a) }), He = e4.Variant({ Upgrade: e4.Opt(n), Init: C2 }), s = e4.Vec(e4.Nat8), P2 = e4.Record({ account: s }), E2 = e4.Record({ account: _2 }), U3 = e4.Record({ canister_id: e4.Principal }), M2 = e4.Record({ archives: e4.Vec(U3) }), r2 = e4.Nat, S2 = e4.Variant({ Int: e4.Int, Nat: e4.Nat, Blob: e4.Vec(e4.Nat8), Text: e4.Text }), d3 = e4.Nat64, G2 = e4.Record({ to: t, fee: e4.Opt(r2), memo: e4.Opt(e4.Vec(e4.Nat8)), from_subaccount: e4.Opt(o), created_at_time: e4.Opt(d3), amount: r2 }), u2 = e4.Nat, Q = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, BadBurn: e4.Record({ min_burn_amount: r2 }), Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), CreatedInFuture: e4.Record({ ledger_time: e4.Nat64 }), TooOld: e4.Null, InsufficientFunds: e4.Record({ balance: r2 }) }), z2 = e4.Variant({ Ok: u2, Err: Q }), y2 = e4.Record({ utc_offset_minutes: e4.Opt(e4.Int16), language: e4.Text }), H3 = e4.Record({ metadata: y2, device_spec: e4.Opt(e4.Variant({ GenericDisplay: e4.Null, LineDisplay: e4.Record({ characters_per_line: e4.Nat16, lines_per_page: e4.Nat16 }) })) }), J3 = e4.Record({ arg: e4.Vec(e4.Nat8), method: e4.Text, user_preferences: H3 }), $3 = e4.Variant({ LineDisplayMessage: e4.Record({ pages: e4.Vec(e4.Record({ lines: e4.Vec(e4.Text) })) }), GenericDisplayMessage: e4.Text }), K2 = e4.Record({ metadata: y2, consent_message: $3 }), g2 = e4.Record({ description: e4.Text }), Y = e4.Variant({ GenericError: e4.Record({ description: e4.Text, error_code: e4.Nat }), InsufficientPayment: g2, UnsupportedCanisterCall: g2, ConsentMessageUnavailable: g2 }), j3 = e4.Variant({ Ok: K2, Err: Y }), W2 = e4.Record({ account: t, spender: t }), X = e4.Record({ allowance: r2, expires_at: e4.Opt(d3) }), Z = e4.Record({ fee: e4.Opt(r2), memo: e4.Opt(e4.Vec(e4.Nat8)), from_subaccount: e4.Opt(o), created_at_time: e4.Opt(d3), amount: r2, expected_allowance: e4.Opt(r2), expires_at: e4.Opt(d3), spender: t }), I = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), AllowanceChanged: e4.Record({ current_allowance: r2 }), CreatedInFuture: e4.Record({ ledger_time: e4.Nat64 }), TooOld: e4.Null, Expired: e4.Record({ ledger_time: e4.Nat64 }), InsufficientFunds: e4.Record({ balance: r2 }) }), D2 = e4.Variant({ Ok: u2, Err: I }), L2 = e4.Record({ to: t, fee: e4.Opt(r2), spender_subaccount: e4.Opt(o), from: t, memo: e4.Opt(e4.Vec(e4.Nat8)), created_at_time: e4.Opt(d3), amount: r2 }), ee = e4.Variant({ GenericError: e4.Record({ message: e4.Text, error_code: e4.Nat }), TemporarilyUnavailable: e4.Null, InsufficientAllowance: e4.Record({ allowance: r2 }), BadBurn: e4.Record({ min_burn_amount: r2 }), Duplicate: e4.Record({ duplicate_of: u2 }), BadFee: e4.Record({ expected_fee: r2 }), CreatedInFuture: e4.Record({ ledger_time: d3 }), TooOld: e4.Null, InsufficientFunds: e4.Record({ balance: r2 }) }), te = e4.Variant({ Ok: u2, Err: ee }), i = e4.Nat64, f2 = e4.Record({ start: i, length: e4.Nat64 }), x2 = e4.Nat64, p = e4.Record({ timestamp_nanos: e4.Nat64 }), ce = e4.Variant({ Approve: e4.Record({ fee: c3, from: s, allowance_e8s: e4.Int, allowance: c3, expected_allowance: e4.Opt(c3), expires_at: e4.Opt(p), spender: s }), Burn: e4.Record({ from: s, amount: c3, spender: e4.Opt(s) }), Mint: e4.Record({ to: s, amount: c3 }), Transfer: e4.Record({ to: s, fee: c3, from: s, amount: c3, spender: e4.Opt(e4.Vec(e4.Nat8)) }) }), re = e4.Record({ memo: x2, icrc1_memo: e4.Opt(e4.Vec(e4.Nat8)), operation: e4.Opt(ce), created_at_time: p }), b3 = e4.Record({ transaction: re, timestamp: p, parent_hash: e4.Opt(e4.Vec(e4.Nat8)) }), ne = e4.Record({ blocks: e4.Vec(b3) }), F2 = e4.Variant({ BadFirstBlockIndex: e4.Record({ requested_index: i, first_valid_index: i }), Other: e4.Record({ error_message: e4.Text, error_code: e4.Nat64 }) }), ae = e4.Variant({ Ok: ne, Err: F2 }), oe = e4.Func([f2], [ae], ["query"]), se = e4.Record({ callback: oe, start: i, length: e4.Nat64 }), ie = e4.Record({ certificate: e4.Opt(e4.Vec(e4.Nat8)), blocks: e4.Vec(b3), chain_length: e4.Nat64, first_block_index: i, archived_blocks: e4.Vec(se) }), de = e4.Record({ callback: e4.Func([f2], [e4.Variant({ Ok: e4.Vec(e4.Vec(e4.Nat8)), Err: F2 })], ["query"]), start: e4.Nat64, length: e4.Nat64 }), ue = e4.Record({ certificate: e4.Opt(e4.Vec(e4.Nat8)), blocks: e4.Vec(e4.Vec(e4.Nat8)), chain_length: e4.Nat64, first_block_index: e4.Nat64, archived_blocks: e4.Vec(de) }), le = e4.Record({ to: _2, fee: c3, memo: x2, from_subaccount: e4.Opt(o), created_at_time: e4.Opt(p), amount: c3 }), _e = e4.Record({ to: s, fee: c3, memo: x2, from_subaccount: e4.Opt(o), created_at_time: e4.Opt(p), amount: c3 }), pe = e4.Variant({ TxTooOld: e4.Record({ allowed_window_nanos: e4.Nat64 }), BadFee: e4.Record({ expected_fee: c3 }), TxDuplicate: e4.Record({ duplicate_of: i }), TxCreatedInFuture: e4.Null, InsufficientFunds: e4.Record({ balance: c3 }) }), me = e4.Variant({ Ok: i, Err: pe }), fe = e4.Record({}), Re = e4.Record({ transfer_fee: c3 });
  return e4.Service({ account_balance: e4.Func([P2], [c3], ["query"]), account_balance_dfx: e4.Func([E2], [c3], ["query"]), account_identifier: e4.Func([t], [s], ["query"]), archives: e4.Func([], [M2], ["query"]), decimals: e4.Func([], [e4.Record({ decimals: e4.Nat32 })], ["query"]), icrc10_supported_standards: e4.Func([], [e4.Vec(e4.Record({ url: e4.Text, name: e4.Text }))], ["query"]), icrc1_balance_of: e4.Func([t], [r2], ["query"]), icrc1_decimals: e4.Func([], [e4.Nat8], ["query"]), icrc1_fee: e4.Func([], [r2], ["query"]), icrc1_metadata: e4.Func([], [e4.Vec(e4.Tuple(e4.Text, S2))], ["query"]), icrc1_minting_account: e4.Func([], [e4.Opt(t)], ["query"]), icrc1_name: e4.Func([], [e4.Text], ["query"]), icrc1_supported_standards: e4.Func([], [e4.Vec(e4.Record({ url: e4.Text, name: e4.Text }))], ["query"]), icrc1_symbol: e4.Func([], [e4.Text], ["query"]), icrc1_total_supply: e4.Func([], [r2], ["query"]), icrc1_transfer: e4.Func([G2], [z2], []), icrc21_canister_call_consent_message: e4.Func([J3], [j3], []), icrc2_allowance: e4.Func([W2], [X], ["query"]), icrc2_approve: e4.Func([Z], [D2], []), icrc2_transfer_from: e4.Func([L2], [te], []), is_ledger_ready: e4.Func([], [e4.Bool], ["query"]), name: e4.Func([], [e4.Record({ name: e4.Text })], ["query"]), query_blocks: e4.Func([f2], [ie], ["query"]), query_encoded_blocks: e4.Func([f2], [ue], ["query"]), send_dfx: e4.Func([le], [i], []), symbol: e4.Func([], [e4.Record({ symbol: e4.Text })], ["query"]), transfer: e4.Func([_e], [me], []), transfer_fee: e4.Func([fe], [Re], ["query"]) });
};
var Xe = BigInt(1095062083);
var Ze = BigInt(1347768404);
var A2 = BigInt(1e4);
var Ie = BigInt(1e8);
var ve = (e4) => ({ e8s: e4 });
var Be = ({ to: e4, amount: o, memo: t, fee: a, fromSubAccount: n, createdAt: c3 }) => ({ to: e4.toUint8Array(), fee: ve(a ?? A2), amount: ve(o), memo: t ?? BigInt(0), created_at_time: c3 !== void 0 ? [{ timestamp_nanos: c3 }] : [], from_subaccount: n === void 0 ? [] : [yt(n)] });
var qe = ({ fromSubAccount: e4, to: o, amount: t, fee: a, icrc1Memo: n, createdAt: c3 }) => ({ to: o, fee: Yt(a ?? A2), amount: t, memo: Yt(n), created_at_time: Yt(c3), from_subaccount: Yt(e4) });
var Ce = ({ fee: e4, createdAt: o, icrc1Memo: t, fromSubAccount: a, expected_allowance: n, expires_at: c3, amount: _2, ...T3 }) => ({ ...T3, fee: Yt(e4 ?? A2), memo: Yt(t), from_subaccount: Yt(a), created_at_time: Yt(o), amount: _2, expected_allowance: Yt(n), expires_at: Yt(c3) });
var Pe = ({ userPreferences: { metadata: { utcOffsetMinutes: e4, language: o }, deriveSpec: t }, ...a }) => ({ ...a, user_preferences: { metadata: { language: o, utc_offset_minutes: Yt(e4) }, device_spec: b(t) ? Yt() : Yt("GenericDisplay" in t ? { GenericDisplay: null } : { LineDisplay: { characters_per_line: t.LineDisplay.charactersPerLine, lines_per_page: t.LineDisplay.linesPerPage } }) } });
var O2 = class extends Error {
};
var R = class extends O2 {
};
var m = class extends O2 {
};
var N2 = class extends O2 {
};
var V2 = class extends R {
  constructor(t) {
    super();
    this.balance = t;
  }
};
var h3 = class extends R {
  constructor(t) {
    super();
    this.allowed_window_secs = t;
  }
};
var w3 = class extends R {
};
var v2 = class extends R {
  constructor(t) {
    super();
    this.duplicateOf = t;
  }
};
var k2 = class extends O2 {
  constructor(t) {
    super();
    this.expectedFee = t;
  }
};
var B2 = class extends m {
  constructor(t, a) {
    super();
    this.message = t;
    this.error_code = a;
  }
};
var ge = class extends m {
};
var xe = class extends m {
  constructor(t) {
    super();
    this.duplicateOf = t;
  }
};
var Oe = class extends m {
  constructor(t) {
    super();
    this.currentAllowance = t;
  }
};
var Ne = class extends m {
};
var Te = class extends m {
};
var ye = class extends m {
  constructor(t) {
    super();
    this.ledgerTime = t;
  }
};
var be = class extends N2 {
};
var Fe = class extends N2 {
};
var Ve = class extends N2 {
};
var Me = (e4) => "TxDuplicate" in e4 ? new v2(e4.TxDuplicate.duplicate_of) : "InsufficientFunds" in e4 ? new V2(e4.InsufficientFunds.balance.e8s) : "TxCreatedInFuture" in e4 ? new w3() : "TxTooOld" in e4 ? new h3(Number(e4.TxTooOld.allowed_window_nanos)) : "BadFee" in e4 ? new k2(e4.BadFee.expected_fee.e8s) : new R(`Unknown error type ${JSON.stringify(e4)}`);
var Se = (e4) => "Duplicate" in e4 ? new v2(e4.Duplicate.duplicate_of) : "InsufficientFunds" in e4 ? new V2(e4.InsufficientFunds.balance) : "CreatedInFuture" in e4 ? new w3() : "TooOld" in e4 ? new h3() : "BadFee" in e4 ? new k2(e4.BadFee.expected_fee) : new R(`Unknown error type ${JSON.stringify(e4)}`);
var Ge = (e4) => "GenericError" in e4 ? new B2(e4.GenericError.message, e4.GenericError.error_code) : "TemporarilyUnavailable" in e4 ? new ge() : "Duplicate" in e4 ? new xe(e4.Duplicate.duplicate_of) : "BadFee" in e4 ? new k2(e4.BadFee.expected_fee) : "AllowanceChanged" in e4 ? new Oe(e4.AllowanceChanged.current_allowance) : "CreatedInFuture" in e4 ? new Ne() : "TooOld" in e4 ? new Te() : "Expired" in e4 ? new ye(e4.Expired.ledger_time) : "InsufficientFunds" in e4 ? new V2(e4.InsufficientFunds.balance) : new m(`Unknown error type ${JSON.stringify(e4)}`);
var Qe = (e4) => "GenericError" in e4 ? new B2(e4.GenericError.description, e4.GenericError.error_code) : "InsufficientPayment" in e4 ? new be(e4.InsufficientPayment.description) : "UnsupportedCanisterCall" in e4 ? new Fe(e4.UnsupportedCanisterCall.description) : "ConsentMessageUnavailable" in e4 ? new Ve(e4.ConsentMessageUnavailable.description) : new N2(`Unknown error type ${JSON.stringify(e4)}`);
var ze = class e3 extends U {
  constructor() {
    super(...arguments);
    this.accountBalance = async ({ accountIdentifier: t, certified: a = true }) => {
      let n = f(t);
      return (await (a ? this.certifiedService : this.service).account_balance({ account: n.toUint8Array() })).e8s;
    };
    this.metadata = (t) => {
      let { icrc1_metadata: a } = this.caller(t);
      return a();
    };
    this.transactionFee = async (t = { certified: false }) => {
      let { transfer_fee: a } = this.caller(t), { transfer_fee: { e8s: n } } = await a({});
      return n;
    };
    this.transfer = async (t) => {
      let a = Be(t), n = await this.certifiedService.transfer(a);
      if ("Err" in n)
        throw Me(n.Err);
      return n.Ok;
    };
    this.icrc1Transfer = async (t) => {
      let a = qe(t), n = await this.certifiedService.icrc1_transfer(a);
      if ("Err" in n)
        throw Se(n.Err);
      return n.Ok;
    };
    this.icrc2Approve = async (t) => {
      let { icrc2_approve: a } = this.caller({ certified: true }), n = await a(Ce(t));
      if ("Err" in n)
        throw Ge(n.Err);
      return n.Ok;
    };
    this.icrc21ConsentMessage = async (t) => {
      let { icrc21_canister_call_consent_message: a } = this.caller({ certified: true }), n = await a(Pe(t));
      if ("Err" in n)
        throw Qe(n.Err);
      return n.Ok;
    };
  }
  static create(t = {}) {
    let a = t.canisterId ?? r, { service: n, certifiedService: c3 } = ct({ options: { ...t, canisterId: a }, idlFactory: we, certifiedIdlFactory: he });
    return new e3(a, n, c3);
  }
};

// ../../node_modules/@dfinity/ledger-icp/dist/esm/index.js
var J2 = z((S2) => {
  "use strict";
  S2.byteLength = gr;
  S2.toByteArray = Ar;
  S2.fromByteArray = Tr;
  var B3 = [], x2 = [], Er = typeof Uint8Array < "u" ? Uint8Array : Array, M2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (g2 = 0, X = M2.length; g2 < X; ++g2)
    B3[g2] = M2[g2], x2[M2.charCodeAt(g2)] = g2;
  var g2, X;
  x2[45] = 62;
  x2[95] = 63;
  function z2(i) {
    var r2 = i.length;
    if (r2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = i.indexOf("=");
    t === -1 && (t = r2);
    var e4 = t === r2 ? 0 : 4 - t % 4;
    return [t, e4];
  }
  function gr(i) {
    var r2 = z2(i), t = r2[0], e4 = r2[1];
    return (t + e4) * 3 / 4 - e4;
  }
  function Ir(i, r2, t) {
    return (r2 + t) * 3 / 4 - t;
  }
  function Ar(i) {
    var r2, t = z2(i), e4 = t[0], n = t[1], o = new Er(Ir(i, e4, n)), u2 = 0, h4 = n > 0 ? e4 - 4 : e4, f2;
    for (f2 = 0; f2 < h4; f2 += 4)
      r2 = x2[i.charCodeAt(f2)] << 18 | x2[i.charCodeAt(f2 + 1)] << 12 | x2[i.charCodeAt(f2 + 2)] << 6 | x2[i.charCodeAt(f2 + 3)], o[u2++] = r2 >> 16 & 255, o[u2++] = r2 >> 8 & 255, o[u2++] = r2 & 255;
    return n === 2 && (r2 = x2[i.charCodeAt(f2)] << 2 | x2[i.charCodeAt(f2 + 1)] >> 4, o[u2++] = r2 & 255), n === 1 && (r2 = x2[i.charCodeAt(f2)] << 10 | x2[i.charCodeAt(f2 + 1)] << 4 | x2[i.charCodeAt(f2 + 2)] >> 2, o[u2++] = r2 >> 8 & 255, o[u2++] = r2 & 255), o;
  }
  function Fr(i) {
    return B3[i >> 18 & 63] + B3[i >> 12 & 63] + B3[i >> 6 & 63] + B3[i & 63];
  }
  function Ur(i, r2, t) {
    for (var e4, n = [], o = r2; o < t; o += 3)
      e4 = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), n.push(Fr(e4));
    return n.join("");
  }
  function Tr(i) {
    for (var r2, t = i.length, e4 = t % 3, n = [], o = 16383, u2 = 0, h4 = t - e4; u2 < h4; u2 += o)
      n.push(Ur(i, u2, u2 + o > h4 ? h4 : u2 + o));
    return e4 === 1 ? (r2 = i[t - 1], n.push(B3[r2 >> 2] + B3[r2 << 4 & 63] + "==")) : e4 === 2 && (r2 = (i[t - 2] << 8) + i[t - 1], n.push(B3[r2 >> 10] + B3[r2 >> 4 & 63] + B3[r2 << 2 & 63] + "=")), n.join("");
  }
});
var K = z(($3) => {
  $3.read = function(i, r2, t, e4, n) {
    var o, u2, h4 = n * 8 - e4 - 1, f2 = (1 << h4) - 1, a = f2 >> 1, s = -7, p = t ? n - 1 : 0, A3 = t ? -1 : 1, w4 = i[r2 + p];
    for (p += A3, o = w4 & (1 << -s) - 1, w4 >>= -s, s += h4; s > 0; o = o * 256 + i[r2 + p], p += A3, s -= 8)
      ;
    for (u2 = o & (1 << -s) - 1, o >>= -s, s += e4; s > 0; u2 = u2 * 256 + i[r2 + p], p += A3, s -= 8)
      ;
    if (o === 0)
      o = 1 - a;
    else {
      if (o === f2)
        return u2 ? NaN : (w4 ? -1 : 1) * (1 / 0);
      u2 = u2 + Math.pow(2, e4), o = o - a;
    }
    return (w4 ? -1 : 1) * u2 * Math.pow(2, o - e4);
  };
  $3.write = function(i, r2, t, e4, n, o) {
    var u2, h4, f2, a = o * 8 - n - 1, s = (1 << a) - 1, p = s >> 1, A3 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w4 = e4 ? 0 : o - 1, L2 = e4 ? 1 : -1, yr = r2 < 0 || r2 === 0 && 1 / r2 < 0 ? 1 : 0;
    for (r2 = Math.abs(r2), isNaN(r2) || r2 === 1 / 0 ? (h4 = isNaN(r2) ? 1 : 0, u2 = s) : (u2 = Math.floor(Math.log(r2) / Math.LN2), r2 * (f2 = Math.pow(2, -u2)) < 1 && (u2--, f2 *= 2), u2 + p >= 1 ? r2 += A3 / f2 : r2 += A3 * Math.pow(2, 1 - p), r2 * f2 >= 2 && (u2++, f2 /= 2), u2 + p >= s ? (h4 = 0, u2 = s) : u2 + p >= 1 ? (h4 = (r2 * f2 - 1) * Math.pow(2, n), u2 = u2 + p) : (h4 = r2 * Math.pow(2, p - 1) * Math.pow(2, n), u2 = 0)); n >= 8; i[t + w4] = h4 & 255, w4 += L2, h4 /= 256, n -= 8)
      ;
    for (u2 = u2 << n | h4, a += n; a > 0; i[t + w4] = u2 & 255, w4 += L2, u2 /= 256, a -= 8)
      ;
    i[t + w4 - L2] |= yr * 128;
  };
});
var lr = z((R2) => {
  "use strict";
  var D2 = J2(), U3 = K(), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  R2.Buffer = c3;
  R2.SlowBuffer = Lr;
  R2.INSPECT_MAX_BYTES = 50;
  var _2 = 2147483647;
  R2.kMaxLength = _2;
  c3.TYPED_ARRAY_SUPPORT = Rr();
  !c3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Rr() {
    try {
      let i = new Uint8Array(1), r2 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r2, Uint8Array.prototype), Object.setPrototypeOf(i, r2), i.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(c3.prototype, "parent", { enumerable: true, get: function() {
    if (c3.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(c3.prototype, "offset", { enumerable: true, get: function() {
    if (c3.isBuffer(this))
      return this.byteOffset;
  } });
  function d3(i) {
    if (i > _2)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    let r2 = new Uint8Array(i);
    return Object.setPrototypeOf(r2, c3.prototype), r2;
  }
  function c3(i, r2, t) {
    if (typeof i == "number") {
      if (typeof r2 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return G2(i);
    }
    return tr(i, r2, t);
  }
  c3.poolSize = 8192;
  function tr(i, r2, t) {
    if (typeof i == "string")
      return Sr(i, r2);
    if (ArrayBuffer.isView(i))
      return _r(i);
    if (i == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    if (m3(i, ArrayBuffer) || i && m3(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (m3(i, SharedArrayBuffer) || i && m3(i.buffer, SharedArrayBuffer)))
      return O3(i, r2, t);
    if (typeof i == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let e4 = i.valueOf && i.valueOf();
    if (e4 != null && e4 !== i)
      return c3.from(e4, r2, t);
    let n = kr(i);
    if (n)
      return n;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return c3.from(i[Symbol.toPrimitive]("string"), r2, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
  }
  c3.from = function(i, r2, t) {
    return tr(i, r2, t);
  };
  Object.setPrototypeOf(c3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(c3, Uint8Array);
  function ir(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function Cr(i, r2, t) {
    return ir(i), i <= 0 ? d3(i) : r2 !== void 0 ? typeof t == "string" ? d3(i).fill(r2, t) : d3(i).fill(r2) : d3(i);
  }
  c3.alloc = function(i, r2, t) {
    return Cr(i, r2, t);
  };
  function G2(i) {
    return ir(i), d3(i < 0 ? 0 : H3(i) | 0);
  }
  c3.allocUnsafe = function(i) {
    return G2(i);
  };
  c3.allocUnsafeSlow = function(i) {
    return G2(i);
  };
  function Sr(i, r2) {
    if ((typeof r2 != "string" || r2 === "") && (r2 = "utf8"), !c3.isEncoding(r2))
      throw new TypeError("Unknown encoding: " + r2);
    let t = er(i, r2) | 0, e4 = d3(t), n = e4.write(i, r2);
    return n !== t && (e4 = e4.slice(0, n)), e4;
  }
  function P2(i) {
    let r2 = i.length < 0 ? 0 : H3(i.length) | 0, t = d3(r2);
    for (let e4 = 0; e4 < r2; e4 += 1)
      t[e4] = i[e4] & 255;
    return t;
  }
  function _r(i) {
    if (m3(i, Uint8Array)) {
      let r2 = new Uint8Array(i);
      return O3(r2.buffer, r2.byteOffset, r2.byteLength);
    }
    return P2(i);
  }
  function O3(i, r2, t) {
    if (r2 < 0 || i.byteLength < r2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r2 + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let e4;
    return r2 === void 0 && t === void 0 ? e4 = new Uint8Array(i) : t === void 0 ? e4 = new Uint8Array(i, r2) : e4 = new Uint8Array(i, r2, t), Object.setPrototypeOf(e4, c3.prototype), e4;
  }
  function kr(i) {
    if (c3.isBuffer(i)) {
      let r2 = H3(i.length) | 0, t = d3(r2);
      return t.length === 0 || i.copy(t, 0, 0, r2), t;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || W2(i.length) ? d3(0) : P2(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return P2(i.data);
  }
  function H3(i) {
    if (i >= _2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _2.toString(16) + " bytes");
    return i | 0;
  }
  function Lr(i) {
    return +i != i && (i = 0), c3.alloc(+i);
  }
  c3.isBuffer = function(r2) {
    return r2 != null && r2._isBuffer === true && r2 !== c3.prototype;
  };
  c3.compare = function(r2, t) {
    if (m3(r2, Uint8Array) && (r2 = c3.from(r2, r2.offset, r2.byteLength)), m3(t, Uint8Array) && (t = c3.from(t, t.offset, t.byteLength)), !c3.isBuffer(r2) || !c3.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r2 === t)
      return 0;
    let e4 = r2.length, n = t.length;
    for (let o = 0, u2 = Math.min(e4, n); o < u2; ++o)
      if (r2[o] !== t[o]) {
        e4 = r2[o], n = t[o];
        break;
      }
    return e4 < n ? -1 : n < e4 ? 1 : 0;
  };
  c3.isEncoding = function(r2) {
    switch (String(r2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  c3.concat = function(r2, t) {
    if (!Array.isArray(r2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r2.length === 0)
      return c3.alloc(0);
    let e4;
    if (t === void 0)
      for (t = 0, e4 = 0; e4 < r2.length; ++e4)
        t += r2[e4].length;
    let n = c3.allocUnsafe(t), o = 0;
    for (e4 = 0; e4 < r2.length; ++e4) {
      let u2 = r2[e4];
      if (m3(u2, Uint8Array))
        o + u2.length > n.length ? (c3.isBuffer(u2) || (u2 = c3.from(u2)), u2.copy(n, o)) : Uint8Array.prototype.set.call(n, u2, o);
      else if (c3.isBuffer(u2))
        u2.copy(n, o);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      o += u2.length;
    }
    return n;
  };
  function er(i, r2) {
    if (c3.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || m3(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
    let t = i.length, e4 = arguments.length > 2 && arguments[2] === true;
    if (!e4 && t === 0)
      return 0;
    let n = false;
    for (; ; )
      switch (r2) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return q(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return ar(i).length;
        default:
          if (n)
            return e4 ? -1 : q(i).length;
          r2 = ("" + r2).toLowerCase(), n = true;
      }
  }
  c3.byteLength = er;
  function br(i, r2, t) {
    let e4 = false;
    if ((r2 === void 0 || r2 < 0) && (r2 = 0), r2 > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r2 >>>= 0, t <= r2))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return Yr(this, r2, t);
        case "utf8":
        case "utf-8":
          return or(this, r2, t);
        case "ascii":
          return Gr(this, r2, t);
        case "latin1":
        case "binary":
          return Hr(this, r2, t);
        case "base64":
          return Or(this, r2, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Wr(this, r2, t);
        default:
          if (e4)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), e4 = true;
      }
  }
  c3.prototype._isBuffer = true;
  function I(i, r2, t) {
    let e4 = i[r2];
    i[r2] = i[t], i[t] = e4;
  }
  c3.prototype.swap16 = function() {
    let r2 = this.length;
    if (r2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r2; t += 2)
      I(this, t, t + 1);
    return this;
  };
  c3.prototype.swap32 = function() {
    let r2 = this.length;
    if (r2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r2; t += 4)
      I(this, t, t + 3), I(this, t + 1, t + 2);
    return this;
  };
  c3.prototype.swap64 = function() {
    let r2 = this.length;
    if (r2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r2; t += 8)
      I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
    return this;
  };
  c3.prototype.toString = function() {
    let r2 = this.length;
    return r2 === 0 ? "" : arguments.length === 0 ? or(this, 0, r2) : br.apply(this, arguments);
  };
  c3.prototype.toLocaleString = c3.prototype.toString;
  c3.prototype.equals = function(r2) {
    if (!c3.isBuffer(r2))
      throw new TypeError("Argument must be a Buffer");
    return this === r2 ? true : c3.compare(this, r2) === 0;
  };
  c3.prototype.inspect = function() {
    let r2 = "", t = R2.INSPECT_MAX_BYTES;
    return r2 = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r2 += " ... "), "<Buffer " + r2 + ">";
  };
  Z && (c3.prototype[Z] = c3.prototype.inspect);
  c3.prototype.compare = function(r2, t, e4, n, o) {
    if (m3(r2, Uint8Array) && (r2 = c3.from(r2, r2.offset, r2.byteLength)), !c3.isBuffer(r2))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r2);
    if (t === void 0 && (t = 0), e4 === void 0 && (e4 = r2 ? r2.length : 0), n === void 0 && (n = 0), o === void 0 && (o = this.length), t < 0 || e4 > r2.length || n < 0 || o > this.length)
      throw new RangeError("out of range index");
    if (n >= o && t >= e4)
      return 0;
    if (n >= o)
      return -1;
    if (t >= e4)
      return 1;
    if (t >>>= 0, e4 >>>= 0, n >>>= 0, o >>>= 0, this === r2)
      return 0;
    let u2 = o - n, h4 = e4 - t, f2 = Math.min(u2, h4), a = this.slice(n, o), s = r2.slice(t, e4);
    for (let p = 0; p < f2; ++p)
      if (a[p] !== s[p]) {
        u2 = a[p], h4 = s[p];
        break;
      }
    return u2 < h4 ? -1 : h4 < u2 ? 1 : 0;
  };
  function nr(i, r2, t, e4, n) {
    if (i.length === 0)
      return -1;
    if (typeof t == "string" ? (e4 = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, W2(t) && (t = n ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
      if (n)
        return -1;
      t = i.length - 1;
    } else if (t < 0)
      if (n)
        t = 0;
      else
        return -1;
    if (typeof r2 == "string" && (r2 = c3.from(r2, e4)), c3.isBuffer(r2))
      return r2.length === 0 ? -1 : Q(i, r2, t, e4, n);
    if (typeof r2 == "number")
      return r2 = r2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(i, r2, t) : Uint8Array.prototype.lastIndexOf.call(i, r2, t) : Q(i, [r2], t, e4, n);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Q(i, r2, t, e4, n) {
    let o = 1, u2 = i.length, h4 = r2.length;
    if (e4 !== void 0 && (e4 = String(e4).toLowerCase(), e4 === "ucs2" || e4 === "ucs-2" || e4 === "utf16le" || e4 === "utf-16le")) {
      if (i.length < 2 || r2.length < 2)
        return -1;
      o = 2, u2 /= 2, h4 /= 2, t /= 2;
    }
    function f2(s, p) {
      return o === 1 ? s[p] : s.readUInt16BE(p * o);
    }
    let a;
    if (n) {
      let s = -1;
      for (a = t; a < u2; a++)
        if (f2(i, a) === f2(r2, s === -1 ? 0 : a - s)) {
          if (s === -1 && (s = a), a - s + 1 === h4)
            return s * o;
        } else
          s !== -1 && (a -= a - s), s = -1;
    } else
      for (t + h4 > u2 && (t = u2 - h4), a = t; a >= 0; a--) {
        let s = true;
        for (let p = 0; p < h4; p++)
          if (f2(i, a + p) !== f2(r2, p)) {
            s = false;
            break;
          }
        if (s)
          return a;
      }
    return -1;
  }
  c3.prototype.includes = function(r2, t, e4) {
    return this.indexOf(r2, t, e4) !== -1;
  };
  c3.prototype.indexOf = function(r2, t, e4) {
    return nr(this, r2, t, e4, true);
  };
  c3.prototype.lastIndexOf = function(r2, t, e4) {
    return nr(this, r2, t, e4, false);
  };
  function Nr(i, r2, t, e4) {
    t = Number(t) || 0;
    let n = i.length - t;
    e4 ? (e4 = Number(e4), e4 > n && (e4 = n)) : e4 = n;
    let o = r2.length;
    e4 > o / 2 && (e4 = o / 2);
    let u2;
    for (u2 = 0; u2 < e4; ++u2) {
      let h4 = parseInt(r2.substr(u2 * 2, 2), 16);
      if (W2(h4))
        return u2;
      i[t + u2] = h4;
    }
    return u2;
  }
  function Mr(i, r2, t, e4) {
    return k3(q(r2, i.length - t), i, t, e4);
  }
  function $r(i, r2, t, e4) {
    return k3(zr(r2), i, t, e4);
  }
  function Dr(i, r2, t, e4) {
    return k3(ar(r2), i, t, e4);
  }
  function Pr(i, r2, t, e4) {
    return k3(Jr(r2, i.length - t), i, t, e4);
  }
  c3.prototype.write = function(r2, t, e4, n) {
    if (t === void 0)
      n = "utf8", e4 = this.length, t = 0;
    else if (e4 === void 0 && typeof t == "string")
      n = t, e4 = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(e4) ? (e4 = e4 >>> 0, n === void 0 && (n = "utf8")) : (n = e4, e4 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o = this.length - t;
    if ((e4 === void 0 || e4 > o) && (e4 = o), r2.length > 0 && (e4 < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    let u2 = false;
    for (; ; )
      switch (n) {
        case "hex":
          return Nr(this, r2, t, e4);
        case "utf8":
        case "utf-8":
          return Mr(this, r2, t, e4);
        case "ascii":
        case "latin1":
        case "binary":
          return $r(this, r2, t, e4);
        case "base64":
          return Dr(this, r2, t, e4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Pr(this, r2, t, e4);
        default:
          if (u2)
            throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), u2 = true;
      }
  };
  c3.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Or(i, r2, t) {
    return r2 === 0 && t === i.length ? D2.fromByteArray(i) : D2.fromByteArray(i.slice(r2, t));
  }
  function or(i, r2, t) {
    t = Math.min(i.length, t);
    let e4 = [], n = r2;
    for (; n < t; ) {
      let o = i[n], u2 = null, h4 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (n + h4 <= t) {
        let f2, a, s, p;
        switch (h4) {
          case 1:
            o < 128 && (u2 = o);
            break;
          case 2:
            f2 = i[n + 1], (f2 & 192) === 128 && (p = (o & 31) << 6 | f2 & 63, p > 127 && (u2 = p));
            break;
          case 3:
            f2 = i[n + 1], a = i[n + 2], (f2 & 192) === 128 && (a & 192) === 128 && (p = (o & 15) << 12 | (f2 & 63) << 6 | a & 63, p > 2047 && (p < 55296 || p > 57343) && (u2 = p));
            break;
          case 4:
            f2 = i[n + 1], a = i[n + 2], s = i[n + 3], (f2 & 192) === 128 && (a & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (f2 & 63) << 12 | (a & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u2 = p));
        }
      }
      u2 === null ? (u2 = 65533, h4 = 1) : u2 > 65535 && (u2 -= 65536, e4.push(u2 >>> 10 & 1023 | 55296), u2 = 56320 | u2 & 1023), e4.push(u2), n += h4;
    }
    return qr(e4);
  }
  var v3 = 4096;
  function qr(i) {
    let r2 = i.length;
    if (r2 <= v3)
      return String.fromCharCode.apply(String, i);
    let t = "", e4 = 0;
    for (; e4 < r2; )
      t += String.fromCharCode.apply(String, i.slice(e4, e4 += v3));
    return t;
  }
  function Gr(i, r2, t) {
    let e4 = "";
    t = Math.min(i.length, t);
    for (let n = r2; n < t; ++n)
      e4 += String.fromCharCode(i[n] & 127);
    return e4;
  }
  function Hr(i, r2, t) {
    let e4 = "";
    t = Math.min(i.length, t);
    for (let n = r2; n < t; ++n)
      e4 += String.fromCharCode(i[n]);
    return e4;
  }
  function Yr(i, r2, t) {
    let e4 = i.length;
    (!r2 || r2 < 0) && (r2 = 0), (!t || t < 0 || t > e4) && (t = e4);
    let n = "";
    for (let o = r2; o < t; ++o)
      n += Kr[i[o]];
    return n;
  }
  function Wr(i, r2, t) {
    let e4 = i.slice(r2, t), n = "";
    for (let o = 0; o < e4.length - 1; o += 2)
      n += String.fromCharCode(e4[o] + e4[o + 1] * 256);
    return n;
  }
  c3.prototype.slice = function(r2, t) {
    let e4 = this.length;
    r2 = ~~r2, t = t === void 0 ? e4 : ~~t, r2 < 0 ? (r2 += e4, r2 < 0 && (r2 = 0)) : r2 > e4 && (r2 = e4), t < 0 ? (t += e4, t < 0 && (t = 0)) : t > e4 && (t = e4), t < r2 && (t = r2);
    let n = this.subarray(r2, t);
    return Object.setPrototypeOf(n, c3.prototype), n;
  };
  function l(i, r2, t) {
    if (i % 1 !== 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + r2 > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  c3.prototype.readUintLE = c3.prototype.readUIntLE = function(r2, t, e4) {
    r2 = r2 >>> 0, t = t >>> 0, e4 || l(r2, t, this.length);
    let n = this[r2], o = 1, u2 = 0;
    for (; ++u2 < t && (o *= 256); )
      n += this[r2 + u2] * o;
    return n;
  };
  c3.prototype.readUintBE = c3.prototype.readUIntBE = function(r2, t, e4) {
    r2 = r2 >>> 0, t = t >>> 0, e4 || l(r2, t, this.length);
    let n = this[r2 + --t], o = 1;
    for (; t > 0 && (o *= 256); )
      n += this[r2 + --t] * o;
    return n;
  };
  c3.prototype.readUint8 = c3.prototype.readUInt8 = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 1, this.length), this[r2];
  };
  c3.prototype.readUint16LE = c3.prototype.readUInt16LE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 2, this.length), this[r2] | this[r2 + 1] << 8;
  };
  c3.prototype.readUint16BE = c3.prototype.readUInt16BE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 2, this.length), this[r2] << 8 | this[r2 + 1];
  };
  c3.prototype.readUint32LE = c3.prototype.readUInt32LE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), (this[r2] | this[r2 + 1] << 8 | this[r2 + 2] << 16) + this[r2 + 3] * 16777216;
  };
  c3.prototype.readUint32BE = c3.prototype.readUInt32BE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), this[r2] * 16777216 + (this[r2 + 1] << 16 | this[r2 + 2] << 8 | this[r2 + 3]);
  };
  c3.prototype.readBigUInt64LE = E2(function(r2) {
    r2 = r2 >>> 0, T3(r2, "offset");
    let t = this[r2], e4 = this[r2 + 7];
    (t === void 0 || e4 === void 0) && C2(r2, this.length - 8);
    let n = t + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 24, o = this[++r2] + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + e4 * 2 ** 24;
    return BigInt(n) + (BigInt(o) << BigInt(32));
  });
  c3.prototype.readBigUInt64BE = E2(function(r2) {
    r2 = r2 >>> 0, T3(r2, "offset");
    let t = this[r2], e4 = this[r2 + 7];
    (t === void 0 || e4 === void 0) && C2(r2, this.length - 8);
    let n = t * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + this[++r2], o = this[++r2] * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + e4;
    return (BigInt(n) << BigInt(32)) + BigInt(o);
  });
  c3.prototype.readIntLE = function(r2, t, e4) {
    r2 = r2 >>> 0, t = t >>> 0, e4 || l(r2, t, this.length);
    let n = this[r2], o = 1, u2 = 0;
    for (; ++u2 < t && (o *= 256); )
      n += this[r2 + u2] * o;
    return o *= 128, n >= o && (n -= Math.pow(2, 8 * t)), n;
  };
  c3.prototype.readIntBE = function(r2, t, e4) {
    r2 = r2 >>> 0, t = t >>> 0, e4 || l(r2, t, this.length);
    let n = t, o = 1, u2 = this[r2 + --n];
    for (; n > 0 && (o *= 256); )
      u2 += this[r2 + --n] * o;
    return o *= 128, u2 >= o && (u2 -= Math.pow(2, 8 * t)), u2;
  };
  c3.prototype.readInt8 = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 1, this.length), this[r2] & 128 ? (255 - this[r2] + 1) * -1 : this[r2];
  };
  c3.prototype.readInt16LE = function(r2, t) {
    r2 = r2 >>> 0, t || l(r2, 2, this.length);
    let e4 = this[r2] | this[r2 + 1] << 8;
    return e4 & 32768 ? e4 | 4294901760 : e4;
  };
  c3.prototype.readInt16BE = function(r2, t) {
    r2 = r2 >>> 0, t || l(r2, 2, this.length);
    let e4 = this[r2 + 1] | this[r2] << 8;
    return e4 & 32768 ? e4 | 4294901760 : e4;
  };
  c3.prototype.readInt32LE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), this[r2] | this[r2 + 1] << 8 | this[r2 + 2] << 16 | this[r2 + 3] << 24;
  };
  c3.prototype.readInt32BE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), this[r2] << 24 | this[r2 + 1] << 16 | this[r2 + 2] << 8 | this[r2 + 3];
  };
  c3.prototype.readBigInt64LE = E2(function(r2) {
    r2 = r2 >>> 0, T3(r2, "offset");
    let t = this[r2], e4 = this[r2 + 7];
    (t === void 0 || e4 === void 0) && C2(r2, this.length - 8);
    let n = this[r2 + 4] + this[r2 + 5] * 2 ** 8 + this[r2 + 6] * 2 ** 16 + (e4 << 24);
    return (BigInt(n) << BigInt(32)) + BigInt(t + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 24);
  });
  c3.prototype.readBigInt64BE = E2(function(r2) {
    r2 = r2 >>> 0, T3(r2, "offset");
    let t = this[r2], e4 = this[r2 + 7];
    (t === void 0 || e4 === void 0) && C2(r2, this.length - 8);
    let n = (t << 24) + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + this[++r2];
    return (BigInt(n) << BigInt(32)) + BigInt(this[++r2] * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + e4);
  });
  c3.prototype.readFloatLE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), U3.read(this, r2, true, 23, 4);
  };
  c3.prototype.readFloatBE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 4, this.length), U3.read(this, r2, false, 23, 4);
  };
  c3.prototype.readDoubleLE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 8, this.length), U3.read(this, r2, true, 52, 8);
  };
  c3.prototype.readDoubleBE = function(r2, t) {
    return r2 = r2 >>> 0, t || l(r2, 8, this.length), U3.read(this, r2, false, 52, 8);
  };
  function y2(i, r2, t, e4, n, o) {
    if (!c3.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r2 > n || r2 < o)
      throw new RangeError('"value" argument is out of bounds');
    if (t + e4 > i.length)
      throw new RangeError("Index out of range");
  }
  c3.prototype.writeUintLE = c3.prototype.writeUIntLE = function(r2, t, e4, n) {
    if (r2 = +r2, t = t >>> 0, e4 = e4 >>> 0, !n) {
      let h4 = Math.pow(2, 8 * e4) - 1;
      y2(this, r2, t, e4, h4, 0);
    }
    let o = 1, u2 = 0;
    for (this[t] = r2 & 255; ++u2 < e4 && (o *= 256); )
      this[t + u2] = r2 / o & 255;
    return t + e4;
  };
  c3.prototype.writeUintBE = c3.prototype.writeUIntBE = function(r2, t, e4, n) {
    if (r2 = +r2, t = t >>> 0, e4 = e4 >>> 0, !n) {
      let h4 = Math.pow(2, 8 * e4) - 1;
      y2(this, r2, t, e4, h4, 0);
    }
    let o = e4 - 1, u2 = 1;
    for (this[t + o] = r2 & 255; --o >= 0 && (u2 *= 256); )
      this[t + o] = r2 / u2 & 255;
    return t + e4;
  };
  c3.prototype.writeUint8 = c3.prototype.writeUInt8 = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 1, 255, 0), this[t] = r2 & 255, t + 1;
  };
  c3.prototype.writeUint16LE = c3.prototype.writeUInt16LE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 2, 65535, 0), this[t] = r2 & 255, this[t + 1] = r2 >>> 8, t + 2;
  };
  c3.prototype.writeUint16BE = c3.prototype.writeUInt16BE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 2, 65535, 0), this[t] = r2 >>> 8, this[t + 1] = r2 & 255, t + 2;
  };
  c3.prototype.writeUint32LE = c3.prototype.writeUInt32LE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 4, 4294967295, 0), this[t + 3] = r2 >>> 24, this[t + 2] = r2 >>> 16, this[t + 1] = r2 >>> 8, this[t] = r2 & 255, t + 4;
  };
  c3.prototype.writeUint32BE = c3.prototype.writeUInt32BE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 4, 4294967295, 0), this[t] = r2 >>> 24, this[t + 1] = r2 >>> 16, this[t + 2] = r2 >>> 8, this[t + 3] = r2 & 255, t + 4;
  };
  function ur(i, r2, t, e4, n) {
    sr(r2, e4, n, i, t, 7);
    let o = Number(r2 & BigInt(4294967295));
    i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
    let u2 = Number(r2 >> BigInt(32) & BigInt(4294967295));
    return i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, t;
  }
  function cr(i, r2, t, e4, n) {
    sr(r2, e4, n, i, t, 7);
    let o = Number(r2 & BigInt(4294967295));
    i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
    let u2 = Number(r2 >> BigInt(32) & BigInt(4294967295));
    return i[t + 3] = u2, u2 = u2 >> 8, i[t + 2] = u2, u2 = u2 >> 8, i[t + 1] = u2, u2 = u2 >> 8, i[t] = u2, t + 8;
  }
  c3.prototype.writeBigUInt64LE = E2(function(r2, t = 0) {
    return ur(this, r2, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  c3.prototype.writeBigUInt64BE = E2(function(r2, t = 0) {
    return cr(this, r2, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  c3.prototype.writeIntLE = function(r2, t, e4, n) {
    if (r2 = +r2, t = t >>> 0, !n) {
      let f2 = Math.pow(2, 8 * e4 - 1);
      y2(this, r2, t, e4, f2 - 1, -f2);
    }
    let o = 0, u2 = 1, h4 = 0;
    for (this[t] = r2 & 255; ++o < e4 && (u2 *= 256); )
      r2 < 0 && h4 === 0 && this[t + o - 1] !== 0 && (h4 = 1), this[t + o] = (r2 / u2 >> 0) - h4 & 255;
    return t + e4;
  };
  c3.prototype.writeIntBE = function(r2, t, e4, n) {
    if (r2 = +r2, t = t >>> 0, !n) {
      let f2 = Math.pow(2, 8 * e4 - 1);
      y2(this, r2, t, e4, f2 - 1, -f2);
    }
    let o = e4 - 1, u2 = 1, h4 = 0;
    for (this[t + o] = r2 & 255; --o >= 0 && (u2 *= 256); )
      r2 < 0 && h4 === 0 && this[t + o + 1] !== 0 && (h4 = 1), this[t + o] = (r2 / u2 >> 0) - h4 & 255;
    return t + e4;
  };
  c3.prototype.writeInt8 = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 1, 127, -128), r2 < 0 && (r2 = 255 + r2 + 1), this[t] = r2 & 255, t + 1;
  };
  c3.prototype.writeInt16LE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 2, 32767, -32768), this[t] = r2 & 255, this[t + 1] = r2 >>> 8, t + 2;
  };
  c3.prototype.writeInt16BE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 2, 32767, -32768), this[t] = r2 >>> 8, this[t + 1] = r2 & 255, t + 2;
  };
  c3.prototype.writeInt32LE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 4, 2147483647, -2147483648), this[t] = r2 & 255, this[t + 1] = r2 >>> 8, this[t + 2] = r2 >>> 16, this[t + 3] = r2 >>> 24, t + 4;
  };
  c3.prototype.writeInt32BE = function(r2, t, e4) {
    return r2 = +r2, t = t >>> 0, e4 || y2(this, r2, t, 4, 2147483647, -2147483648), r2 < 0 && (r2 = 4294967295 + r2 + 1), this[t] = r2 >>> 24, this[t + 1] = r2 >>> 16, this[t + 2] = r2 >>> 8, this[t + 3] = r2 & 255, t + 4;
  };
  c3.prototype.writeBigInt64LE = E2(function(r2, t = 0) {
    return ur(this, r2, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  c3.prototype.writeBigInt64BE = E2(function(r2, t = 0) {
    return cr(this, r2, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function hr(i, r2, t, e4, n, o) {
    if (t + e4 > i.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function fr(i, r2, t, e4, n) {
    return r2 = +r2, t = t >>> 0, n || hr(i, r2, t, 4, 34028234663852886e22, -34028234663852886e22), U3.write(i, r2, t, e4, 23, 4), t + 4;
  }
  c3.prototype.writeFloatLE = function(r2, t, e4) {
    return fr(this, r2, t, true, e4);
  };
  c3.prototype.writeFloatBE = function(r2, t, e4) {
    return fr(this, r2, t, false, e4);
  };
  function pr(i, r2, t, e4, n) {
    return r2 = +r2, t = t >>> 0, n || hr(i, r2, t, 8, 17976931348623157e292, -17976931348623157e292), U3.write(i, r2, t, e4, 52, 8), t + 8;
  }
  c3.prototype.writeDoubleLE = function(r2, t, e4) {
    return pr(this, r2, t, true, e4);
  };
  c3.prototype.writeDoubleBE = function(r2, t, e4) {
    return pr(this, r2, t, false, e4);
  };
  c3.prototype.copy = function(r2, t, e4, n) {
    if (!c3.isBuffer(r2))
      throw new TypeError("argument should be a Buffer");
    if (e4 || (e4 = 0), !n && n !== 0 && (n = this.length), t >= r2.length && (t = r2.length), t || (t = 0), n > 0 && n < e4 && (n = e4), n === e4 || r2.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (e4 < 0 || e4 >= this.length)
      throw new RangeError("Index out of range");
    if (n < 0)
      throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length), r2.length - t < n - e4 && (n = r2.length - t + e4);
    let o = n - e4;
    return this === r2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e4, n) : Uint8Array.prototype.set.call(r2, this.subarray(e4, n), t), o;
  };
  c3.prototype.fill = function(r2, t, e4, n) {
    if (typeof r2 == "string") {
      if (typeof t == "string" ? (n = t, t = 0, e4 = this.length) : typeof e4 == "string" && (n = e4, e4 = this.length), n !== void 0 && typeof n != "string")
        throw new TypeError("encoding must be a string");
      if (typeof n == "string" && !c3.isEncoding(n))
        throw new TypeError("Unknown encoding: " + n);
      if (r2.length === 1) {
        let u2 = r2.charCodeAt(0);
        (n === "utf8" && u2 < 128 || n === "latin1") && (r2 = u2);
      }
    } else
      typeof r2 == "number" ? r2 = r2 & 255 : typeof r2 == "boolean" && (r2 = Number(r2));
    if (t < 0 || this.length < t || this.length < e4)
      throw new RangeError("Out of range index");
    if (e4 <= t)
      return this;
    t = t >>> 0, e4 = e4 === void 0 ? this.length : e4 >>> 0, r2 || (r2 = 0);
    let o;
    if (typeof r2 == "number")
      for (o = t; o < e4; ++o)
        this[o] = r2;
    else {
      let u2 = c3.isBuffer(r2) ? r2 : c3.from(r2, n), h4 = u2.length;
      if (h4 === 0)
        throw new TypeError('The value "' + r2 + '" is invalid for argument "value"');
      for (o = 0; o < e4 - t; ++o)
        this[o + t] = u2[o % h4];
    }
    return this;
  };
  var F2 = {};
  function Y(i, r2, t) {
    F2[i] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: r2.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(n) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  Y("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
    return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Y("ERR_INVALID_ARG_TYPE", function(i, r2) {
    return `The "${i}" argument must be of type number. Received type ${typeof r2}`;
  }, TypeError);
  Y("ERR_OUT_OF_RANGE", function(i, r2, t) {
    let e4 = `The value of "${i}" is out of range.`, n = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = rr(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = rr(n)), n += "n"), e4 += ` It must be ${r2}. Received ${n}`, e4;
  }, RangeError);
  function rr(i) {
    let r2 = "", t = i.length, e4 = i[0] === "-" ? 1 : 0;
    for (; t >= e4 + 4; t -= 3)
      r2 = `_${i.slice(t - 3, t)}${r2}`;
    return `${i.slice(0, t)}${r2}`;
  }
  function jr(i, r2, t) {
    T3(r2, "offset"), (i[r2] === void 0 || i[r2 + t] === void 0) && C2(r2, i.length - (t + 1));
  }
  function sr(i, r2, t, e4, n, o) {
    if (i > t || i < r2) {
      let u2 = typeof r2 == "bigint" ? "n" : "", h4;
      throw o > 3 ? r2 === 0 || r2 === BigInt(0) ? h4 = `>= 0${u2} and < 2${u2} ** ${(o + 1) * 8}${u2}` : h4 = `>= -(2${u2} ** ${(o + 1) * 8 - 1}${u2}) and < 2 ** ${(o + 1) * 8 - 1}${u2}` : h4 = `>= ${r2}${u2} and <= ${t}${u2}`, new F2.ERR_OUT_OF_RANGE("value", h4, i);
    }
    jr(e4, n, o);
  }
  function T3(i, r2) {
    if (typeof i != "number")
      throw new F2.ERR_INVALID_ARG_TYPE(r2, "number", i);
  }
  function C2(i, r2, t) {
    throw Math.floor(i) !== i ? (T3(i, t), new F2.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r2 < 0 ? new F2.ERR_BUFFER_OUT_OF_BOUNDS() : new F2.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r2}`, i);
  }
  var Vr = /[^+/0-9A-Za-z-_]/g;
  function Xr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2)
      return "";
    for (; i.length % 4 !== 0; )
      i = i + "=";
    return i;
  }
  function q(i, r2) {
    r2 = r2 || 1 / 0;
    let t, e4 = i.length, n = null, o = [];
    for (let u2 = 0; u2 < e4; ++u2) {
      if (t = i.charCodeAt(u2), t > 55295 && t < 57344) {
        if (!n) {
          if (t > 56319) {
            (r2 -= 3) > -1 && o.push(239, 191, 189);
            continue;
          } else if (u2 + 1 === e4) {
            (r2 -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          n = t;
          continue;
        }
        if (t < 56320) {
          (r2 -= 3) > -1 && o.push(239, 191, 189), n = t;
          continue;
        }
        t = (n - 55296 << 10 | t - 56320) + 65536;
      } else
        n && (r2 -= 3) > -1 && o.push(239, 191, 189);
      if (n = null, t < 128) {
        if ((r2 -= 1) < 0)
          break;
        o.push(t);
      } else if (t < 2048) {
        if ((r2 -= 2) < 0)
          break;
        o.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r2 -= 3) < 0)
          break;
        o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r2 -= 4) < 0)
          break;
        o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return o;
  }
  function zr(i) {
    let r2 = [];
    for (let t = 0; t < i.length; ++t)
      r2.push(i.charCodeAt(t) & 255);
    return r2;
  }
  function Jr(i, r2) {
    let t, e4, n, o = [];
    for (let u2 = 0; u2 < i.length && !((r2 -= 2) < 0); ++u2)
      t = i.charCodeAt(u2), e4 = t >> 8, n = t % 256, o.push(n), o.push(e4);
    return o;
  }
  function ar(i) {
    return D2.toByteArray(Xr(i));
  }
  function k3(i, r2, t, e4) {
    let n;
    for (n = 0; n < e4 && !(n + t >= r2.length || n >= i.length); ++n)
      r2[n + t] = i[n];
    return n;
  }
  function m3(i, r2) {
    return i instanceof r2 || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r2.name;
  }
  function W2(i) {
    return i !== i;
  }
  var Kr = function() {
    let i = "0123456789abcdef", r2 = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let e4 = t * 16;
      for (let n = 0; n < 16; ++n)
        r2[e4 + n] = i[t] + i[n];
    }
    return r2;
  }();
  function E2(i) {
    return typeof BigInt > "u" ? Zr : i;
  }
  function Zr() {
    throw new Error("BigInt not supported");
  }
});
var j2 = J(lr());

export {
  Ed25519KeyIdentity,
  ECDSAKeyIdentity,
  PartialIdentity,
  Delegation,
  DelegationChain,
  DelegationIdentity,
  PartialDelegationIdentity,
  isDelegationValid,
  INVALID_REQUEST_ERROR,
  NOT_SUPPORTED_ERROR,
  fromBase64,
  toBase64,
  Signer,
  isJsonRpcRequest,
  isJsonRpcResponse,
  SignerAgent,
  IdbStorage,
  getIdentity,
  setIdentity,
  removeIdentity,
  getDelegationChain,
  setDelegationChain,
  removeDelegationChain,
  D,
  _,
  ze
};
/*! Bundled license information:

@dfinity/ledger-icp/dist/esm/chunk-D2JQPN4X.js:
  (*! Bundled license information:
  
  @noble/hashes/esm/utils.js:
    (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  *)

@dfinity/ledger-icp/dist/esm/index.js:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=chunk-A3G77H63.js.map
